# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2019, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-04-21 18:09+0200\n"
"PO-Revision-Date: 2019-05-14 17:37+0200\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: it_IT\n"
"X-Generator: Poedit 2.2.1\n"

#: ../Doc/library/stdtypes.rst:8
msgid "Built-in Types"
msgstr "Tipi Built-in"

#: ../Doc/library/stdtypes.rst:10
msgid ""
"The following sections describe the standard types that are built into the "
"interpreter."
msgstr ""
"Le sezioni seguenti descrivono i tipi standard che sono integrati "
"nell'interprete."

#: ../Doc/library/stdtypes.rst:15
msgid ""
"The principal built-in types are numerics, sequences, mappings, classes, "
"instances and exceptions."
msgstr ""
"I principali tipi built-in sono numeri, sequenze, mappature, classi, istanze "
"ed eccezioni."

#: ../Doc/library/stdtypes.rst:18
msgid ""
"Some collection classes are mutable.  The methods that add, subtract, or "
"rearrange their members in place, and don't return a specific item, never "
"return the collection instance itself but ``None``."
msgstr ""
"Alcune classi collection sono mutevoli. I metodi che aggiungono, sottraggono "
"o riorganizzano i loro membri in place, e non restituiscono un elemento "
"specifico, non restituiscono mai l'istanza stessa della collezione ma "
"``None``."

#: ../Doc/library/stdtypes.rst:22
#, fuzzy
msgid ""
"Some operations are supported by several object types; in particular, "
"practically all objects can be compared, tested for truth value, and "
"converted to a string (with the :func:`repr` function or the slightly "
"different :func:`str` function).  The latter function is implicitly used "
"when an object is written by the :func:`print` function."
msgstr ""
"Alcune operazioni sono supportate da diversi tipi di oggetti; in "
"particolare, praticamente tutti gli oggetti possono essere confrontati, "
"testati per il valore di verità e convertiti in una stringa (con la "
"funzione :func:`repr` o la funzione :func:`str`).  Quest'ultima funzione è "
"implicitamente usata quando un oggetto è scritto dalla funzione :func:"
"`print`."

#: ../Doc/library/stdtypes.rst:32
msgid "Truth Value Testing"
msgstr "Verifica del valore di verità"

#: ../Doc/library/stdtypes.rst:41
#, fuzzy
msgid ""
"Any object can be tested for truth value, for use in an :keyword:`if` or :"
"keyword:`while` condition or as operand of the Boolean operations below."
msgstr ""
"Qualsiasi oggetto può essere testato per il valore di verità, per l'uso in "
"una parola chiave:`if` o :keyword:`while` condition o come operando delle "
"operazioni booleane qui sotto."

#: ../Doc/library/stdtypes.rst:46
#, fuzzy
msgid ""
"By default, an object is considered true unless its class defines either a :"
"meth:`__bool__` method that returns ``False`` or a :meth:`__len__` method "
"that returns zero, when called with the object. [1]_  Here are most of the "
"built-in objects considered false:"
msgstr ""
"Per impostazione predefinita, un oggetto è considerato vero a meno che la "
"sua classe non definisca un metodo :meth:`__bool__` che restituisce "
"``False``` o un metodo :meth:`__len____` che restituisce zero, quando viene "
"chiamato con l'oggetto. [1]_ Ecco la maggior parte degli oggetti incorporati "
"considerati falsi:"

#: ../Doc/library/stdtypes.rst:55
#, fuzzy
msgid "constants defined to be false: ``None`` and ``False``."
msgstr "costanti definite come false: ```Nessuno```` e ``Falso```."

#: ../Doc/library/stdtypes.rst:57
#, fuzzy
msgid ""
"zero of any numeric type: ``0``, ``0.0``, ``0j``, ``Decimal(0)``, "
"``Fraction(0, 1)``"
msgstr ""
"zero di qualsiasi tipo numerico: ``0````, ``0.0.0```, ``0j```, "
"``Decimal(0)``, ``Fraction(0, 1)```"

#: ../Doc/library/stdtypes.rst:60
#, fuzzy
msgid ""
"empty sequences and collections: ``''``, ``()``, ``[]``, ``{}``, ``set()``, "
"``range(0)``"
msgstr ""
"sequenze e collezioni vuote: ```''```, ``(()```, ``[]```, ``{}```, "
"``set()```, ``range(0)```"

#: ../Doc/library/stdtypes.rst:69
#, fuzzy
msgid ""
"Operations and built-in functions that have a Boolean result always return "
"``0`` or ``False`` for false and ``1`` or ``True`` for true, unless "
"otherwise stated. (Important exception: the Boolean operations ``or`` and "
"``and`` always return one of their operands.)"
msgstr ""
"Le operazioni e le funzioni integrate che hanno un risultato booleano "
"restituiscono sempre ``0``` o ``False``` per falso e ``1`` o ``True``` per "
"vero, se non diversamente specificato. (Eccezione importante: le operazioni "
"booleane ``or``` e ```and``` restituiscono sempre uno dei loro operandi)"

#: ../Doc/library/stdtypes.rst:78
#, fuzzy
msgid "Boolean Operations --- :keyword:`!and`, :keyword:`!or`, :keyword:`!not`"
msgstr ""
"Operazioni booleane ----- :parola chiave:`!e`, :parola chiave:`!o`, :parola "
"chiave:`!not`"

#: ../Doc/library/stdtypes.rst:82
msgid "These are the Boolean operations, ordered by ascending priority:"
msgstr "Queste sono le operazioni booleane, ordinate per priorità crescente:"

#: ../Doc/library/stdtypes.rst:85 ../Doc/library/stdtypes.rst:143
#: ../Doc/library/stdtypes.rst:275 ../Doc/library/stdtypes.rst:364
#: ../Doc/library/stdtypes.rst:414 ../Doc/library/stdtypes.rst:856
#: ../Doc/library/stdtypes.rst:1051
msgid "Operation"
msgstr "Operazione"

#: ../Doc/library/stdtypes.rst:85 ../Doc/library/stdtypes.rst:275
#: ../Doc/library/stdtypes.rst:364 ../Doc/library/stdtypes.rst:414
#: ../Doc/library/stdtypes.rst:856 ../Doc/library/stdtypes.rst:1051
msgid "Result"
msgstr "Risultato"

#: ../Doc/library/stdtypes.rst:85 ../Doc/library/stdtypes.rst:275
#: ../Doc/library/stdtypes.rst:414 ../Doc/library/stdtypes.rst:856
#: ../Doc/library/stdtypes.rst:1051 ../Doc/library/stdtypes.rst:2199
#: ../Doc/library/stdtypes.rst:3331
msgid "Notes"
msgstr "Note"

#: ../Doc/library/stdtypes.rst:87
msgid "``x or y``"
msgstr "``x or y``"

#: ../Doc/library/stdtypes.rst:87
msgid "if *x* is false, then *y*, else *x*"
msgstr "se *x* è falso, allora *y*, altrimenti *x*"

#: ../Doc/library/stdtypes.rst:87 ../Doc/library/stdtypes.rst:285
#: ../Doc/library/stdtypes.rst:858 ../Doc/library/stdtypes.rst:861
#: ../Doc/library/stdtypes.rst:1062 ../Doc/library/stdtypes.rst:2205
#: ../Doc/library/stdtypes.rst:3337
msgid "\\(1)"
msgstr "\\(1)"

#: ../Doc/library/stdtypes.rst:90
msgid "``x and y``"
msgstr "``x and y``"

#: ../Doc/library/stdtypes.rst:90
msgid "if *x* is false, then *x*, else *y*"
msgstr "se *x* è falso, allora *x*, altrimenti *y*"

#: ../Doc/library/stdtypes.rst:90 ../Doc/library/stdtypes.rst:288
#: ../Doc/library/stdtypes.rst:308 ../Doc/library/stdtypes.rst:1090
#: ../Doc/library/stdtypes.rst:2209 ../Doc/library/stdtypes.rst:2211
#: ../Doc/library/stdtypes.rst:3341 ../Doc/library/stdtypes.rst:3343
msgid "\\(2)"
msgstr "\\(2)"

#: ../Doc/library/stdtypes.rst:93
msgid "``not x``"
msgstr "``not x``"

#: ../Doc/library/stdtypes.rst:93
msgid "if *x* is false, then ``True``, else ``False``"
msgstr "se *x* è falso, allora ``True``, altrimenti ``False``"

#: ../Doc/library/stdtypes.rst:93 ../Doc/library/stdtypes.rst:870
#: ../Doc/library/stdtypes.rst:1093 ../Doc/library/stdtypes.rst:2213
#: ../Doc/library/stdtypes.rst:2215 ../Doc/library/stdtypes.rst:2217
#: ../Doc/library/stdtypes.rst:2219 ../Doc/library/stdtypes.rst:3345
#: ../Doc/library/stdtypes.rst:3347 ../Doc/library/stdtypes.rst:3349
#: ../Doc/library/stdtypes.rst:3351
msgid "\\(3)"
msgstr "\\(3)"

#: ../Doc/library/stdtypes.rst:102 ../Doc/library/stdtypes.rst:319
#: ../Doc/library/stdtypes.rst:432 ../Doc/library/stdtypes.rst:897
#: ../Doc/library/stdtypes.rst:1101 ../Doc/library/stdtypes.rst:2245
#: ../Doc/library/stdtypes.rst:3381
msgid "Notes:"
msgstr "Note:"

#: ../Doc/library/stdtypes.rst:105
msgid ""
"This is a short-circuit operator, so it only evaluates the second argument "
"if the first one is false."
msgstr ""
"Questo è un operatore corto-circuitati, quindi valuta il secondo argomento "
"solo se il primo è falso."

#: ../Doc/library/stdtypes.rst:109
#, fuzzy
msgid ""
"This is a short-circuit operator, so it only evaluates the second argument "
"if the first one is true."
msgstr ""
"Si tratta di un operatore in cortocircuito, quindi valuta il secondo "
"argomento solo se il primo è vero."

#: ../Doc/library/stdtypes.rst:113
#, fuzzy
msgid ""
"``not`` has a lower priority than non-Boolean operators, so ``not a == b`` "
"is interpreted as ``not (a == b)``, and ``a == not b`` is a syntax error."
msgstr ""
"```not``not`` ha una priorità inferiore rispetto agli operatori non "
"booleani, quindi ``not a ==== b```` è interpretato come ``not (a === b)```, "
"e ``a ===non b```` è un errore di sintassi."

#: ../Doc/library/stdtypes.rst:120
#, fuzzy
msgid "Comparisons"
msgstr "Confronti"

#: ../Doc/library/stdtypes.rst:134
#, fuzzy
msgid ""
"There are eight comparison operations in Python.  They all have the same "
"priority (which is higher than that of the Boolean operations).  Comparisons "
"can be chained arbitrarily; for example, ``x < y <= z`` is equivalent to ``x "
"< y and y <= z``, except that *y* is evaluated only once (but in both cases "
"*z* is not evaluated at all when ``x < y`` is found to be false)."
msgstr ""
"Ci sono otto operazioni di confronto in Python.  Hanno tutti la stessa "
"priorità (che è superiore a quella delle operazioni booleane).  I confronti "
"possono essere concatenati arbitrariamente; per esempio, ``x < y < y <= "
"z```` equivale a ``x < y e y <= z````, tranne che *y* viene valutato una "
"sola volta (ma in entrambi i casi *z* non viene valutato affatto quando ``x "
"< y```` è trovato falso)."

#: ../Doc/library/stdtypes.rst:140
#, fuzzy
msgid "This table summarizes the comparison operations:"
msgstr "La tabella riassume le operazioni a confronto:"

#: ../Doc/library/stdtypes.rst:143 ../Doc/library/stdtypes.rst:2176
#: ../Doc/library/stdtypes.rst:2199 ../Doc/library/stdtypes.rst:3308
#: ../Doc/library/stdtypes.rst:3331
#, fuzzy
msgid "Meaning"
msgstr "Significato"

#: ../Doc/library/stdtypes.rst:145
msgid "``<``"
msgstr "``<``"

#: ../Doc/library/stdtypes.rst:145
msgid "strictly less than"
msgstr "strettamente inferiore a"

#: ../Doc/library/stdtypes.rst:147
msgid "``<=``"
msgstr "``<=``"

#: ../Doc/library/stdtypes.rst:147
msgid "less than or equal"
msgstr "inferiore o uguale"

#: ../Doc/library/stdtypes.rst:149
msgid "``>``"
msgstr "``>``"

#: ../Doc/library/stdtypes.rst:149
msgid "strictly greater than"
msgstr "strettamente superiore a"

#: ../Doc/library/stdtypes.rst:151
msgid "``>=``"
msgstr "``>=``"

#: ../Doc/library/stdtypes.rst:151
msgid "greater than or equal"
msgstr "maggiore o uguale"

#: ../Doc/library/stdtypes.rst:153
msgid "``==``"
msgstr "``==``"

#: ../Doc/library/stdtypes.rst:153
msgid "equal"
msgstr "uguale"

#: ../Doc/library/stdtypes.rst:155
msgid "``!=``"
msgstr "``!=``"

#: ../Doc/library/stdtypes.rst:155
msgid "not equal"
msgstr "non uguale"

#: ../Doc/library/stdtypes.rst:157
msgid "``is``"
msgstr "``is``"

#: ../Doc/library/stdtypes.rst:157
msgid "object identity"
msgstr "identità dell'oggetto"

#: ../Doc/library/stdtypes.rst:159
msgid "``is not``"
msgstr "``is not``"

#: ../Doc/library/stdtypes.rst:159
msgid "negated object identity"
msgstr "identità oggetto negato"

#: ../Doc/library/stdtypes.rst:166
#, fuzzy
msgid ""
"Objects of different types, except different numeric types, never compare "
"equal. Furthermore, some types (for example, function objects) support only "
"a degenerate notion of comparison where any two objects of that type are "
"unequal.  The ``<``, ``<=``, ``>`` and ``>=`` operators will raise a :exc:"
"`TypeError` exception when comparing a complex number with another built-in "
"numeric type, when the objects are of different types that cannot be "
"compared, or in other cases where there is no defined ordering."
msgstr ""
"Oggetti di tipi diversi, ad eccezione dei diversi tipi numerici, non possono "
"mai essere confrontati allo stesso modo. Inoltre, alcuni tipi (ad esempio, "
"gli oggetti funzionali) supportano solo una nozione degenerata di confronto "
"in cui due oggetti di quel tipo sono disuguali.  Gli operatori ```<```, "
"``<=```, ``>``` e ``>=```` sollevano un'eccezione :exc:`TypeError` quando si "
"confronta un numero complesso con un altro tipo numerico incorporato, quando "
"gli oggetti sono di tipi diversi che non possono essere confrontati, o in "
"altri casi in cui non esiste un ordine definito."

#: ../Doc/library/stdtypes.rst:182
#, fuzzy
msgid ""
"Non-identical instances of a class normally compare as non-equal unless the "
"class defines the :meth:`__eq__` method."
msgstr ""
"Le istanze non identiche di una classe normalmente si confrontano come non "
"eguali a meno che la classe non definisca il metodo :meth:`__eq__eq__``."

#: ../Doc/library/stdtypes.rst:185
#, fuzzy
msgid ""
"Instances of a class cannot be ordered with respect to other instances of "
"the same class, or other types of object, unless the class defines enough of "
"the methods :meth:`__lt__`, :meth:`__le__`, :meth:`__gt__`, and :meth:"
"`__ge__` (in general, :meth:`__lt__` and :meth:`__eq__` are sufficient, if "
"you want the conventional meanings of the comparison operators)."
msgstr ""
"Le istanze di una classe non possono essere ordinate rispetto ad altre "
"istanze della stessa classe, o altri tipi di oggetti, a meno che la classe "
"non definisca abbastanza dei metodi: meth:`__lt______`, :meth:`__le__le__`, :"
"meth:`__gt__`, e :meth:`__ge____` (in generale, :meth:`__lt______` e :meth:"
"`__eq____` sono sufficienti, se si vogliono i significati convenzionali "
"degli operatori di confronto)."

#: ../Doc/library/stdtypes.rst:191
#, fuzzy
msgid ""
"The behavior of the :keyword:`is` and :keyword:`is not` operators cannot be "
"customized; also they can be applied to any two objects and never raise an "
"exception."
msgstr ""
"Il comportamento della parola chiave :keyword:`is` e :keyword:`is non `is` "
"non `e` gli operatori non possono essere personalizzati; inoltre possono "
"essere applicati a due oggetti qualsiasi e non sollevano mai un'eccezione."

#: ../Doc/library/stdtypes.rst:199
#, fuzzy
msgid ""
"Two more operations with the same syntactic priority, :keyword:`in` and :"
"keyword:`not in`, are supported by types that are :term:`iterable` or "
"implement the :meth:`__contains__` method."
msgstr ""
"Altre due operazioni con la stessa priorità sintattica, :parola chiave:`in` "
"e :parola chiave:`non in`, sono supportate da tipi che sono :termine:"
"`iterable` o implementano il metodo :meth:`__contains__`."

#: ../Doc/library/stdtypes.rst:206
#, fuzzy
msgid "Numeric Types --- :class:`int`, :class:`float`, :class:`complex`"
msgstr "Tipi numerici ----- :class:`int`, :class:`float`, :class:`complex`"

#: ../Doc/library/stdtypes.rst:216
#, fuzzy
msgid ""
"There are three distinct numeric types: :dfn:`integers`, :dfn:`floating "
"point numbers`, and :dfn:`complex numbers`.  In addition, Booleans are a "
"subtype of integers.  Integers have unlimited precision.  Floating point "
"numbers are usually implemented using :c:type:`double` in C; information "
"about the precision and internal representation of floating point numbers "
"for the machine on which your program is running is available in :data:`sys."
"float_info`.  Complex numbers have a real and imaginary part, which are each "
"a floating point number.  To extract these parts from a complex number *z*, "
"use ``z.real`` and ``z.imag``. (The standard library includes additional "
"numeric types, :mod:`fractions` that hold rationals, and :mod:`decimal` that "
"hold floating-point numbers with user-definable precision.)"
msgstr ""
"Ci sono tre tipi di numeri distinti: :dfn:`integers`, :dfn:`floating point "
"numbers`, e :dfn:`complex numbers`.  Inoltre, i booleani sono un sottotipo "
"di numeri interi.  Gli interi hanno una precisione illimitata.  I numeri in "
"virgola mobile sono solitamente implementati usando: c:type:`double` in C; "
"le informazioni sulla precisione e la rappresentazione interna dei numeri in "
"virgola mobile per la macchina su cui il programma è in esecuzione sono "
"disponibili in :data:`sys.float_info`.  I numeri complessi hanno una parte "
"reale e immaginaria, che sono ciascuno un numero a virgola mobile.  Per "
"estrarre queste parti da un numero complesso *z*, usare ``z.real``` e ``z."
"imag```. (La libreria standard include tipi numerici addizionali, :mod:"
"`frazioni` che contengono razionali, e :mod:`decimale` che contengono numeri "
"a virgola mobile con precisione definibile dall'utente)"

#: ../Doc/library/stdtypes.rst:238
#, fuzzy
msgid ""
"Numbers are created by numeric literals or as the result of built-in "
"functions and operators.  Unadorned integer literals (including hex, octal "
"and binary numbers) yield integers.  Numeric literals containing a decimal "
"point or an exponent sign yield floating point numbers.  Appending ``'j'`` "
"or ``'J'`` to a numeric literal yields an imaginary number (a complex number "
"with a zero real part) which you can add to an integer or float to get a "
"complex number with real and imaginary parts."
msgstr ""
"I numeri sono creati da lettere numeriche o come risultato di funzioni e "
"operatori integrati.  I numeri interi interi non decorati (inclusi numeri "
"esadecimali, ottali e binari) producono numeri interi.  Le lettere letterali "
"numeriche contenenti un punto decimale o un segno esponente producono numeri "
"in virgola mobile.  Aggiungendo ``'j'j'``` o ``'J'``` ad un numero letterale "
"numerico si ottiene un numero immaginario (un numero complesso con una parte "
"reale zero) che è possibile aggiungere ad un numero intero o galleggiante "
"per ottenere un numero complesso con parti reali e immaginarie."

#: ../Doc/library/stdtypes.rst:263
#, fuzzy
msgid ""
"Python fully supports mixed arithmetic: when a binary arithmetic operator "
"has operands of different numeric types, the operand with the \"narrower\" "
"type is widened to that of the other, where integer is narrower than "
"floating point, which is narrower than complex.  Comparisons between numbers "
"of mixed type use the same rule. [2]_ The constructors :func:`int`, :func:"
"`float`, and :func:`complex` can be used to produce numbers of a specific "
"type."
msgstr ""
"Python supporta completamente l'aritmetica mista: quando un operatore "
"aritmetico binario ha operandi di diversi tipi numerici, l'operando con il "
"tipo \"più stretto\" si allarga a quello dell'altro, dove l'intero è più "
"stretto del punto galleggiante, che è più stretto del complesso.  I "
"confronti tra numeri di tipo misto utilizzano la stessa regola. 2]_ I "
"costruttori :func:`int`, :func:`float`, e :func:`complex` può essere usato "
"per produrre numeri di un tipo specifico."

#: ../Doc/library/stdtypes.rst:270
#, fuzzy
msgid ""
"All numeric types (except complex) support the following operations, sorted "
"by ascending priority (all numeric operations have a higher priority than "
"comparison operations):"
msgstr ""
"Tutti i tipi di numeri (eccetto quelli complessi) supportano le seguenti "
"operazioni, ordinate per priorità crescente (tutte le operazioni numeriche "
"hanno una priorità maggiore rispetto alle operazioni di confronto):"

#: ../Doc/library/stdtypes.rst:275
msgid "Full documentation"
msgstr "Documentazione completa"

#: ../Doc/library/stdtypes.rst:277
msgid "``x + y``"
msgstr "``x + y``"

#: ../Doc/library/stdtypes.rst:277
msgid "sum of *x* and *y*"
msgstr "somma di *x* e *y*"

#: ../Doc/library/stdtypes.rst:279
msgid "``x - y``"
msgstr "``x - y``"

#: ../Doc/library/stdtypes.rst:279
msgid "difference of *x* and *y*"
msgstr "differenza di *x* e *y*"

#: ../Doc/library/stdtypes.rst:281
msgid "``x * y``"
msgstr "``x * y``"

#: ../Doc/library/stdtypes.rst:281
msgid "product of *x* and *y*"
msgstr "prodotto di *x* e *y*"

#: ../Doc/library/stdtypes.rst:283
msgid "``x / y``"
msgstr "``x / y``"

#: ../Doc/library/stdtypes.rst:283
msgid "quotient of *x* and *y*"
msgstr "quoziente di *x* e *y*"

#: ../Doc/library/stdtypes.rst:285
msgid "``x // y``"
msgstr "``x // y``"

#: ../Doc/library/stdtypes.rst:285
#, fuzzy
msgid "floored quotient of *x* and *y*"
msgstr "Intero inferiore del quoziente di *x* e *y*"

#: ../Doc/library/stdtypes.rst:288
msgid "``x % y``"
msgstr "``x % y``"

#: ../Doc/library/stdtypes.rst:288
msgid "remainder of ``x / y``"
msgstr "resto di ``x / y``"

#: ../Doc/library/stdtypes.rst:290
msgid "``-x``"
msgstr "``-x``"

#: ../Doc/library/stdtypes.rst:290
msgid "*x* negated"
msgstr "*x* negato"

#: ../Doc/library/stdtypes.rst:292
msgid "``+x``"
msgstr "``+x``"

#: ../Doc/library/stdtypes.rst:292
msgid "*x* unchanged"
msgstr "*x* invariato"

#: ../Doc/library/stdtypes.rst:294
msgid "``abs(x)``"
msgstr "``abs(x)``"

#: ../Doc/library/stdtypes.rst:294
msgid "absolute value or magnitude of *x*"
msgstr "valore assoluto o grandezza di *x*"

#: ../Doc/library/stdtypes.rst:294
msgid ":func:`abs`"
msgstr ":func:`abs`"

#: ../Doc/library/stdtypes.rst:297
msgid "``int(x)``"
msgstr "``int(x)``"

#: ../Doc/library/stdtypes.rst:297
msgid "*x* converted to integer"
msgstr "*x* convertito a intero"

#: ../Doc/library/stdtypes.rst:297
msgid "\\(3)\\(6)"
msgstr "\\(3)\\(6)"

#: ../Doc/library/stdtypes.rst:297
msgid ":func:`int`"
msgstr ":func:`int`"

#: ../Doc/library/stdtypes.rst:299
msgid "``float(x)``"
msgstr "``float(x)``"

#: ../Doc/library/stdtypes.rst:299
msgid "*x* converted to floating point"
msgstr "*x* convertito in virgola mobile"

#: ../Doc/library/stdtypes.rst:299
msgid "\\(4)\\(6)"
msgstr "\\(4)\\(6)"

#: ../Doc/library/stdtypes.rst:299
msgid ":func:`float`"
msgstr ":func:`float`"

#: ../Doc/library/stdtypes.rst:301
msgid "``complex(re, im)``"
msgstr "``complex(re, im)``"

#: ../Doc/library/stdtypes.rst:301
msgid ""
"a complex number with real part *re*, imaginary part *im*. *im* defaults to "
"zero."
msgstr ""
"un numero complesso con parte reale *re*, parte immaginaria *im*. *im* di "
"default a zero."

#: ../Doc/library/stdtypes.rst:301 ../Doc/library/stdtypes.rst:1083
#: ../Doc/library/stdtypes.rst:2207 ../Doc/library/stdtypes.rst:3368
msgid "\\(6)"
msgstr "\\(6)"

#: ../Doc/library/stdtypes.rst:301
msgid ":func:`complex`"
msgstr ":func:`complex`"

#: ../Doc/library/stdtypes.rst:305
msgid "``c.conjugate()``"
msgstr "``c.conjugate()``"

#: ../Doc/library/stdtypes.rst:305
msgid "conjugate of the complex number *c*"
msgstr "coniugato del numero complesso *c*"

#: ../Doc/library/stdtypes.rst:308
msgid "``divmod(x, y)``"
msgstr "``divmod(x, y)``"

#: ../Doc/library/stdtypes.rst:308
msgid "the pair ``(x // y, x % y)``"
msgstr "la coppia ``(x // y, x % y)``"

#: ../Doc/library/stdtypes.rst:308
msgid ":func:`divmod`"
msgstr ":func:`divmod`"

#: ../Doc/library/stdtypes.rst:310
msgid "``pow(x, y)``"
msgstr "``pow(x, y)``"

#: ../Doc/library/stdtypes.rst:310 ../Doc/library/stdtypes.rst:312
msgid "*x* to the power *y*"
msgstr "*x* alla potenza *y*"

#: ../Doc/library/stdtypes.rst:310 ../Doc/library/stdtypes.rst:312
#: ../Doc/library/stdtypes.rst:1072 ../Doc/library/stdtypes.rst:1075
#: ../Doc/library/stdtypes.rst:2232 ../Doc/library/stdtypes.rst:2235
#: ../Doc/library/stdtypes.rst:2238 ../Doc/library/stdtypes.rst:3364
#: ../Doc/library/stdtypes.rst:3371
msgid "\\(5)"
msgstr "\\(5)"

#: ../Doc/library/stdtypes.rst:310
msgid ":func:`pow`"
msgstr ":func:`pow`"

#: ../Doc/library/stdtypes.rst:312
msgid "``x ** y``"
msgstr "``x ** y``"

#: ../Doc/library/stdtypes.rst:322
#, fuzzy
msgid ""
"Also referred to as integer division.  The resultant value is a whole "
"integer, though the result's type is not necessarily int.  The result is "
"always rounded towards minus infinity: ``1//2`` is ``0``, ``(-1)//2`` is "
"``-1``, ``1//(-2)`` is ``-1``, and ``(-1)//(-2)`` is ``0``."
msgstr ""
"Chiamata anche divisione intera.  Il valore risultante è un intero intero, "
"anche se il tipo di risultato non è necessariamente int.  Il risultato è "
"sempre arrotondato verso il meno infinito: ``1//2```` è ``0```, "
"``(-1)//2```` è ``-1``, ``1//(-2)``` è ``-1``, e ``(-1)//(-2)```` è ``0```."

#: ../Doc/library/stdtypes.rst:328
#, fuzzy
msgid ""
"Not for complex numbers.  Instead convert to floats using :func:`abs` if "
"appropriate."
msgstr ""
"Non per i numeri complessi.  Invece convertire in galleggianti usando :func:"
"`abs`, se del caso."

#: ../Doc/library/stdtypes.rst:340
#, fuzzy
msgid ""
"Conversion from floating point to integer may round or truncate as in C; see "
"functions :func:`math.floor` and :func:`math.ceil` for well-defined "
"conversions."
msgstr ""
"La conversione da virgola mobile a intero può arrotondare o troncare come in "
"C; vedi funzioni: func:`math.floor` e :func:`math.ceil` per conversioni ben "
"definite."

#: ../Doc/library/stdtypes.rst:345
#, fuzzy
msgid ""
"float also accepts the strings \"nan\" and \"inf\" with an optional prefix "
"\"+\" or \"-\" for Not a Number (NaN) and positive or negative infinity."
msgstr ""
"float accetta anche le stringhe \"nan\" e \"inf\" con un prefisso opzionale "
"\"+\" o \"-\" per Non un numero (NaN) e infinito positivo o negativo."

#: ../Doc/library/stdtypes.rst:349
#, fuzzy
msgid ""
"Python defines ``pow(0, 0)`` and ``0 ** 0`` to be ``1``, as is common for "
"programming languages."
msgstr ""
"Python definisce ``pow(0, 0)```` e ```0 ** 0```` per essere ``1```, come è "
"comune per i linguaggi di programmazione."

#: ../Doc/library/stdtypes.rst:353
#, fuzzy
msgid ""
"The numeric literals accepted include the digits ``0`` to ``9`` or any "
"Unicode equivalent (code points with the ``Nd`` property)."
msgstr ""
"Le lettere numeriche accettate comprendono le cifre da ``0````` a ``9``` o "
"qualsiasi codice Unicode equivalente (punti di codice con la proprietà "
"```Nd```)."

#: ../Doc/library/stdtypes.rst:356
#, fuzzy
msgid ""
"See http://www.unicode.org/Public/10.0.0/ucd/extracted/DerivedNumericType."
"txt for a complete list of code points with the ``Nd`` property."
msgstr ""
"Vedere http://www.unicode.org/Public/10.0.0/ucd/extracted/DerivedNumericType."
"txt per un elenco completo dei punti di codice con la proprietà ````Nd```."

#: ../Doc/library/stdtypes.rst:360
#, fuzzy
msgid ""
"All :class:`numbers.Real` types (:class:`int` and :class:`float`) also "
"include the following operations:"
msgstr ""
"Tutti i tipi :class:`numbers.Real` (:class:`int` e :class:`float`) includono "
"anche le seguenti operazioni:"

#: ../Doc/library/stdtypes.rst:366
msgid ":func:`math.trunc(\\ x) <math.trunc>`"
msgstr ":func:`math.trunc(\\ x) <math.trunc>`"

#: ../Doc/library/stdtypes.rst:366
msgid "*x* truncated to :class:`~numbers.Integral`"
msgstr "*x* troncato a :class:`~numbers.Integral`"

#: ../Doc/library/stdtypes.rst:369
msgid ":func:`round(x[, n]) <round>`"
msgstr ":func:`round(x[, n]) <round>`"

#: ../Doc/library/stdtypes.rst:369
#, fuzzy
msgid ""
"*x* rounded to *n* digits, rounding half to even. If *n* is omitted, it "
"defaults to 0."
msgstr ""
"*x* arrotondato a *n* cifre, arrotondando la metà a pari. Se *n* è omesso, "
"il valore predefinito è 0."

#: ../Doc/library/stdtypes.rst:373
msgid ":func:`math.floor(\\ x) <math.floor>`"
msgstr ":func:`math.floor(\\ x) <math.floor>`"

#: ../Doc/library/stdtypes.rst:373
#, fuzzy
msgid "the greatest :class:`~numbers.Integral` <= *x*"
msgstr "il più grande :class:`~numbers.Integral` <= *x*"

#: ../Doc/library/stdtypes.rst:376
msgid ":func:`math.ceil(x) <math.ceil>`"
msgstr ":func:`math.ceil(x) <math.ceil>`"

#: ../Doc/library/stdtypes.rst:376
msgid "the least :class:`~numbers.Integral` >= *x*"
msgstr "il minimo :class:`~numbers.Integral` >= *x*"

#: ../Doc/library/stdtypes.rst:380
#, fuzzy
msgid ""
"For additional numeric operations see the :mod:`math` and :mod:`cmath` "
"modules."
msgstr ""
"Per ulteriori operazioni numeriche vedere i moduli :mod:`math` e :mod:"
"`cmath`."

#: ../Doc/library/stdtypes.rst:389
msgid "Bitwise Operations on Integer Types"
msgstr "Operazioni bitwise su tipi interi"

#: ../Doc/library/stdtypes.rst:403
#, fuzzy
msgid ""
"Bitwise operations only make sense for integers. The result of bitwise "
"operations is calculated as though carried out in two's complement with an "
"infinite number of sign bits."
msgstr ""
"Le operazioni in bitwise hanno senso solo per i numeri interi. Il risultato "
"delle operazioni di bitwise è calcolato come se fosse eseguito in due "
"complementi con un numero infinito di bit di segno."

#: ../Doc/library/stdtypes.rst:407
#, fuzzy
msgid ""
"The priorities of the binary bitwise operations are all lower than the "
"numeric operations and higher than the comparisons; the unary operation "
"``~`` has the same priority as the other unary numeric operations (``+`` and "
"``-``)."
msgstr ""
"Le priorità delle operazioni binarie bitwise sono tutte inferiori alle "
"operazioni numeriche e superiori ai confronti; l'operazione unary ``~`~``` "
"ha la stessa priorità delle altre operazioni numeriche unary (``+``` e ``-"
"`````)."

#: ../Doc/library/stdtypes.rst:411
#, fuzzy
msgid "This table lists the bitwise operations sorted in ascending priority:"
msgstr ""
"Questa tabella elenca le operazioni bitwise ordinate in priorità crescente:"

#: ../Doc/library/stdtypes.rst:416
msgid "``x | y``"
msgstr "``x | y``"

#: ../Doc/library/stdtypes.rst:416
msgid "bitwise :dfn:`or` of *x* and *y*"
msgstr "bitwise :dfn:`or` di *x* e *y*"

#: ../Doc/library/stdtypes.rst:416 ../Doc/library/stdtypes.rst:419
#: ../Doc/library/stdtypes.rst:422 ../Doc/library/stdtypes.rst:1096
#: ../Doc/library/stdtypes.rst:2221 ../Doc/library/stdtypes.rst:2225
#: ../Doc/library/stdtypes.rst:3353 ../Doc/library/stdtypes.rst:3357
msgid "\\(4)"
msgstr "\\(4)"

#: ../Doc/library/stdtypes.rst:419
msgid "``x ^ y``"
msgstr "``x ^ y``"

#: ../Doc/library/stdtypes.rst:419
msgid "bitwise :dfn:`exclusive or` of *x* and *y*"
msgstr "bitwise :dfn:`exclusive or` di *x* e *y*"

#: ../Doc/library/stdtypes.rst:422
msgid "``x & y``"
msgstr "``x & y``"

#: ../Doc/library/stdtypes.rst:422
msgid "bitwise :dfn:`and` of *x* and *y*"
msgstr "bitwise :dfn:`and` di *x* e *y*"

#: ../Doc/library/stdtypes.rst:425
msgid "``x << n``"
msgstr "``x << n``"

#: ../Doc/library/stdtypes.rst:425
msgid "*x* shifted left by *n* bits"
msgstr "*x* spostato a sinistra di *n* bit"

#: ../Doc/library/stdtypes.rst:425
msgid "(1)(2)"
msgstr "(1)(2)"

#: ../Doc/library/stdtypes.rst:427
msgid "``x >> n``"
msgstr "``x >> n``"

#: ../Doc/library/stdtypes.rst:427
msgid "*x* shifted right by *n* bits"
msgstr "*x* spostata a destra di *n* bit"

#: ../Doc/library/stdtypes.rst:427
msgid "(1)(3)"
msgstr "(1)(3)"

#: ../Doc/library/stdtypes.rst:429
msgid "``~x``"
msgstr "``~x``"

#: ../Doc/library/stdtypes.rst:429
msgid "the bits of *x* inverted"
msgstr "i bit di *x* invertiti"

#: ../Doc/library/stdtypes.rst:435
#, fuzzy
msgid ""
"Negative shift counts are illegal and cause a :exc:`ValueError` to be raised."
msgstr ""
"I conteggi negativi dei turni sono illegali e causano un aumento di :exc:"
"`ValueError`."

#: ../Doc/library/stdtypes.rst:438
#, fuzzy
msgid ""
"A left shift by *n* bits is equivalent to multiplication by ``pow(2, n)`` "
"without overflow check."
msgstr ""
"Uno spostamento a sinistra di *n* bit equivale alla moltiplicazione per "
"``pow(2, n)``` senza controllo di overflow."

#: ../Doc/library/stdtypes.rst:442
#, fuzzy
msgid ""
"A right shift by *n* bits is equivalent to division by ``pow(2, n)`` without "
"overflow check."
msgstr ""
"Uno spostamento a destra di *n* bit equivale alla divisione per ``pow(2, "
"n)``` senza controllo di overflow."

#: ../Doc/library/stdtypes.rst:446
#, fuzzy
msgid ""
"Performing these calculations with at least one extra sign extension bit in "
"a finite two's complement representation (a working bit-width of ``1 + max(x."
"bit_length(), y.bit_length())`` or more) is sufficient to get the same "
"result as if there were an infinite number of sign bits."
msgstr ""
"Eseguire questi calcoli con almeno un bit di estensione extra del segno in "
"una rappresentazione del complemento finito di due (una larghezza di lavoro "
"di ``1 + max(x.bit_length(), y.bit_length())``` o più) è sufficiente per "
"ottenere lo stesso risultato come se ci fosse un numero infinito di bit del "
"segno."

#: ../Doc/library/stdtypes.rst:453
#, fuzzy
msgid "Additional Methods on Integer Types"
msgstr "Metodi aggiuntivi su tipi interi"

#: ../Doc/library/stdtypes.rst:455
#, fuzzy
msgid ""
"The int type implements the :class:`numbers.Integral` :term:`abstract base "
"class`. In addition, it provides a few more methods:"
msgstr ""
"Il tipo int implementa il tipo :class:`numbers.Integral` :term:`abstract "
"base class`. Inoltre, fornisce alcuni altri metodi:"

#: ../Doc/library/stdtypes.rst:460
#, fuzzy
msgid ""
"Return the number of bits necessary to represent an integer in binary, "
"excluding the sign and leading zeros::"
msgstr ""
"Restituisce il numero di bit necessari per rappresentare un intero in "
"binario, esclusi il segno e gli zeri iniziali::"

#: ../Doc/library/stdtypes.rst:469
#, fuzzy
msgid ""
"More precisely, if ``x`` is nonzero, then ``x.bit_length()`` is the unique "
"positive integer ``k`` such that ``2**(k-1) <= abs(x) < 2**k``. "
"Equivalently, when ``abs(x)`` is small enough to have a correctly rounded "
"logarithm, then ``k = 1 + int(log(abs(x), 2))``. If ``x`` is zero, then ``x."
"bit_length()`` returns ``0``."
msgstr ""
"Più precisamente, se ``x``` non è zero, allora ``x.bit_length()```` è "
"l'unico intero positivo ``k```` tale che ``2**(k-1) <= abs(x) < 2**k`````. "
"Allo stesso modo, quando ``abs(x)``` è abbastanza piccolo da avere un "
"logaritmo correttamente arrotondato, allora ``k = 1 + int(log(abs(x), 2))``. "
"Se ``x````` è zero, allora ``x.bit_length()``` restituisce ``0````."

#: ../Doc/library/stdtypes.rst:475
msgid "Equivalent to::"
msgstr "Equivalente a::"

#: ../Doc/library/stdtypes.rst:486
#, fuzzy
msgid "Return an array of bytes representing an integer."
msgstr "Restituisce un array di byte che rappresentano un intero."

#: ../Doc/library/stdtypes.rst:498
#, fuzzy
msgid ""
"The integer is represented using *length* bytes.  An :exc:`OverflowError` is "
"raised if the integer is not representable with the given number of bytes."
msgstr ""
"Il numero intero è rappresentato utilizzando *lunghezza* byte.  Un:exc:"
"`OverflowError` è sollevato se il numero intero non è rappresentabile con il "
"numero di byte dato."

#: ../Doc/library/stdtypes.rst:502 ../Doc/library/stdtypes.rst:534
#, fuzzy
msgid ""
"The *byteorder* argument determines the byte order used to represent the "
"integer.  If *byteorder* is ``\"big\"``, the most significant byte is at the "
"beginning of the byte array.  If *byteorder* is ``\"little\"``, the most "
"significant byte is at the end of the byte array.  To request the native "
"byte order of the host system, use :data:`sys.byteorder` as the byte order "
"value."
msgstr ""
"L'argomento *byteorder* determina l'ordine di byte utilizzato per "
"rappresentare l'intero.  Se *byteorder* è \"grande\", il byte più "
"significativo è all'inizio dell'array di byte.  Se *byteorder* è \"piccolo"
"\", il byte più significativo è alla fine dell'array di byte.  Per "
"richiedere l'ordine di byte nativo del sistema host, utilizzare:data:`sys."
"byteorder` come valore dell'ordine di byte."

#: ../Doc/library/stdtypes.rst:509
#, fuzzy
msgid ""
"The *signed* argument determines whether two's complement is used to "
"represent the integer.  If *signed* is ``False`` and a negative integer is "
"given, an :exc:`OverflowError` is raised. The default value for *signed* is "
"``False``."
msgstr ""
"L'argomento *firmato* determina se il complemento di due è usato per "
"rappresentare l'intero.  Se *segnalato* è ``Falso``` e viene dato un numero "
"intero negativo, viene sollevato un :exc:`OverflowError`. Il valore "
"predefinito per *firmato* è ``False```."

#: ../Doc/library/stdtypes.rst:518
#, fuzzy
msgid "Return the integer represented by the given array of bytes."
msgstr "Restituisce l'intero rappresentato dall'array di byte dato."

#: ../Doc/library/stdtypes.rst:531
#, fuzzy
msgid ""
"The argument *bytes* must either be a :term:`bytes-like object` or an "
"iterable producing bytes."
msgstr ""
"L'argomento *bytes* deve essere un :termine:`bytes-like object` o un "
"iterable producendo bytes."

#: ../Doc/library/stdtypes.rst:541
#, fuzzy
msgid ""
"The *signed* argument indicates whether two's complement is used to "
"represent the integer."
msgstr ""
"L'argomento *firmato* indica se il complemento di due è usato per "
"rappresentare l'intero."

#: ../Doc/library/stdtypes.rst:548
msgid "Additional Methods on Float"
msgstr "Metodi aggiuntivi su Float"

#: ../Doc/library/stdtypes.rst:550
#, fuzzy
msgid ""
"The float type implements the :class:`numbers.Real` :term:`abstract base "
"class`. float also has the following additional methods."
msgstr ""
"Il tipo float implementa la classe :class:`numbers.Real` :term:`abstract "
"base class`. float ha anche i seguenti metodi aggiuntivi."

#: ../Doc/library/stdtypes.rst:555
#, fuzzy
msgid ""
"Return a pair of integers whose ratio is exactly equal to the original float "
"and with a positive denominator.  Raises :exc:`OverflowError` on infinities "
"and a :exc:`ValueError` on NaNs."
msgstr ""
"Restituisce una coppia di numeri interi il cui rapporto è esattamente uguale "
"al galleggiante originale e con un denominatore positivo.  Aumenta :exc:"
"`OverflowError` su infiniti e a :exc:`ValueError` su NaNs."

#: ../Doc/library/stdtypes.rst:562
#, fuzzy
msgid ""
"Return ``True`` if the float instance is finite with integral value, and "
"``False`` otherwise::"
msgstr ""
"Restituire ``True``` se l'istanza del galleggiante è finita con valore "
"integrale, e ``False``` altrimenti::"

#: ../Doc/library/stdtypes.rst:570
#, fuzzy
msgid ""
"Two methods support conversion to and from hexadecimal strings.  Since "
"Python's floats are stored internally as binary numbers, converting a float "
"to or from a *decimal* string usually involves a small rounding error.  In "
"contrast, hexadecimal strings allow exact representation and specification "
"of floating-point numbers.  This can be useful when debugging, and in "
"numerical work."
msgstr ""
"Due metodi supportano la conversione da e verso stringhe esadecimali.  "
"Poiché i galleggianti di Python sono memorizzati internamente come numeri "
"binari, la conversione di un galleggiante in o da una stringa *decimale* "
"solitamente comporta un piccolo errore di arrotondamento.  Al contrario, le "
"stringhe esadecimali consentono la rappresentazione esatta e la "
"specificazione di numeri a virgola mobile.  Questo può essere utile durante "
"il debug e nel lavoro numerico."

#: ../Doc/library/stdtypes.rst:581
#, fuzzy
msgid ""
"Return a representation of a floating-point number as a hexadecimal string.  "
"For finite floating-point numbers, this representation will always include a "
"leading ``0x`` and a trailing ``p`` and exponent."
msgstr ""
"Restituisce una rappresentazione di un numero in virgola mobile come stringa "
"esadecimale.  Per i numeri a virgola mobile finito, questa rappresentazione "
"includerà sempre un ``0x```` e un ``p`p`` e un esponente."

#: ../Doc/library/stdtypes.rst:589
#, fuzzy
msgid ""
"Class method to return the float represented by a hexadecimal string *s*.  "
"The string *s* may have leading and trailing whitespace."
msgstr ""
"Metodo della classe per restituire il float rappresentato da una stringa "
"esadecimale *s*.  La stringa *s* può avere spazi bianchi iniziali e finali."

#: ../Doc/library/stdtypes.rst:594
#, fuzzy
msgid ""
"Note that :meth:`float.hex` is an instance method, while :meth:`float."
"fromhex` is a class method."
msgstr ""
"Si noti che :meth:`float.hex` è un metodo di istanza, mentre :meth:`float."
"fromhex` è un metodo di classe."

#: ../Doc/library/stdtypes.rst:597
msgid "A hexadecimal string takes the form::"
msgstr "Una stringa esadecimale assume la forma::"

#: ../Doc/library/stdtypes.rst:601
#, fuzzy
msgid ""
"where the optional ``sign`` may by either ``+`` or ``-``, ``integer`` and "
"``fraction`` are strings of hexadecimal digits, and ``exponent`` is a "
"decimal integer with an optional leading sign.  Case is not significant, and "
"there must be at least one hexadecimal digit in either the integer or the "
"fraction.  This syntax is similar to the syntax specified in section 6.4.4.2 "
"of the C99 standard, and also to the syntax used in Java 1.5 onwards.  In "
"particular, the output of :meth:`float.hex` is usable as a hexadecimal "
"floating-point literal in C or Java code, and hexadecimal strings produced "
"by C's ``%a`` format character or Java's ``Double.toHexString`` are accepted "
"by :meth:`float.fromhex`."
msgstr ""
"dove il ```segno``` facoltativo può essere ``+``` o ``-`````, ``integer``` e "
"``fraction``` sono stringhe di cifre esadecimali, e ```exponent``` è un "
"numero intero decimale con un segno iniziale opzionale.  Il caso non è "
"significativo, e deve esserci almeno una cifra esadecimale sia nell'intero "
"che nella frazione.  Questa sintassi è simile a quella specificata nella "
"sezione 6.4.4.4.4.2 dello standard C99, nonché alla sintassi usata in Java "
"1.5 e successivi.  In particolare, l'output di :meth:`float.hex` è "
"utilizzabile come un punto esadecimale a virgola mobile letterale in C o "
"codice Java, e le stringhe esadecimali prodotte dal carattere di formato ```"
"%a``` di C o dal ``Double.toHexString``` di Java sono accettate da :meth:"
"`float.fromhex`."

#: ../Doc/library/stdtypes.rst:614
#, fuzzy
msgid ""
"Note that the exponent is written in decimal rather than hexadecimal, and "
"that it gives the power of 2 by which to multiply the coefficient. For "
"example, the hexadecimal string ``0x3.a7p10`` represents the floating-point "
"number ``(3 + 10./16 + 7./16**2) * 2.0**10``, or ``3740.0``::"
msgstr ""
"Si noti che l'esponente è scritto in decimale piuttosto che in esadecimale, "
"e che dà la potenza di 2 per cui moltiplicare il coefficiente. Per esempio, "
"la stringa esadecimale ``0x3.a7p10``` rappresenta il numero a virgola mobile "
"``(3 + 10./16 + 7./16**2) * 2.0**10```, oppure ``3740.0```::"

#: ../Doc/library/stdtypes.rst:624
#, fuzzy
msgid ""
"Applying the reverse conversion to ``3740.0`` gives a different hexadecimal "
"string representing the same number::"
msgstr ""
"Applicando la conversione inversa a ```3740.0```` si ottiene una stringa "
"esadecimale diversa che rappresenta lo stesso numero::"

#: ../Doc/library/stdtypes.rst:634
msgid "Hashing of numeric types"
msgstr "Hashing di tipi numerici"

#: ../Doc/library/stdtypes.rst:636
#, fuzzy
msgid ""
"For numbers ``x`` and ``y``, possibly of different types, it's a requirement "
"that ``hash(x) == hash(y)`` whenever ``x == y`` (see the :meth:`__hash__` "
"method documentation for more details).  For ease of implementation and "
"efficiency across a variety of numeric types (including :class:`int`, :class:"
"`float`, :class:`decimal.Decimal` and :class:`fractions.Fraction`) Python's "
"hash for numeric types is based on a single mathematical function that's "
"defined for any rational number, and hence applies to all instances of :"
"class:`int` and :class:`fractions.Fraction`, and all finite instances of :"
"class:`float` and :class:`decimal.Decimal`.  Essentially, this function is "
"given by reduction modulo ``P`` for a fixed prime ``P``.  The value of ``P`` "
"is made available to Python as the :attr:`modulus` attribute of :data:`sys."
"hash_info`."
msgstr ""
"Per i numeri ``x``` e ``y``y``, possibilmente di tipi diversi, è un "
"requisito che ``hash(x) == hash(y)``` ogni volta che ``x === y``` (vedere la "
"documentazione del metodo :meth:`__hash__`` per maggiori dettagli).  Per "
"facilitare l'implementazione e l'efficienza in una varietà di tipi numerici "
"(inclusi: class:`int`, :class:`float`, :class:`decimal.decimal` e :class:"
"`fractions.Frazione`) L'hash di Python per i tipi numerici si basa su una "
"singola funzione matematica che è definita per qualsiasi numero razionale, e "
"quindi si applica a tutte le istanze di :class:`int` e :class:`int` e :class:"
"`fractions.Fraction`, e tutte le istanze finite di :class:`float` e :class:"
"`decimal.decimal`.  Essenzialmente, questa funzione è data dal modulo di "
"riduzione ``P```` per un primo fisso ```P````.  Il valore di ``P```` è reso "
"disponibile a Python come attributo :attr:`modulo` di :data:`sys.hash_info`."

#: ../Doc/library/stdtypes.rst:651
#, fuzzy
msgid ""
"Currently, the prime used is ``P = 2**31 - 1`` on machines with 32-bit C "
"longs and ``P = 2**61 - 1`` on machines with 64-bit C longs."
msgstr ""
"Attualmente, il principale utilizzato è ``P = 2**31 - 1``` su macchine con "
"lunghezza C a 32 bit e ``P = 2**61 - 1``` su macchine con lunghezza C a 64 "
"bit."

#: ../Doc/library/stdtypes.rst:654
msgid "Here are the rules in detail:"
msgstr "Ecco le regole in dettaglio:"

#: ../Doc/library/stdtypes.rst:656
#, fuzzy
msgid ""
"If ``x = m / n`` is a nonnegative rational number and ``n`` is not divisible "
"by ``P``, define ``hash(x)`` as ``m * invmod(n, P) % P``, where ``invmod(n, "
"P)`` gives the inverse of ``n`` modulo ``P``."
msgstr ""
"Se ``x = m / n```` è un numero razionale non negativo e ``n'n``` non è "
"divisibile per ``P```, definire ``hash(x)``` come ``m * invmod(n, P) % P```, "
"dove ``invmod(n, P)``` dà l'inverso di ``n``` modulo ``P```."

#: ../Doc/library/stdtypes.rst:660
#, fuzzy
msgid ""
"If ``x = m / n`` is a nonnegative rational number and ``n`` is divisible by "
"``P`` (but ``m`` is not) then ``n`` has no inverse modulo ``P`` and the rule "
"above doesn't apply; in this case define ``hash(x)`` to be the constant "
"value ``sys.hash_info.inf``."
msgstr ""
"Se ``x = m / n```` è un numero razionale non negativo e ``n'n``` è "
"divisibile per ``P``` (ma ``m``` non è) allora ``n'n``n non ha modulo "
"inverso ``P``` e la regola precedente non si applica; in questo caso "
"definire ``hash(x)``` per essere il valore costante ``sys.hash_info.inf```."

#: ../Doc/library/stdtypes.rst:665
#, fuzzy
msgid ""
"If ``x = m / n`` is a negative rational number define ``hash(x)`` as ``-"
"hash(-x)``.  If the resulting hash is ``-1``, replace it with ``-2``."
msgstr ""
"Se ``x = m / n```` è un numero razionale negativo definire ``hash(x)```` "
"come ``-hash(-x)```.  Se l'hash risultante è ``-1````, sostituirlo con "
"``-2```."

#: ../Doc/library/stdtypes.rst:669
#, fuzzy
msgid ""
"The particular values ``sys.hash_info.inf``, ``-sys.hash_info.inf`` and "
"``sys.hash_info.nan`` are used as hash values for positive infinity, "
"negative infinity, or nans (respectively).  (All hashable nans have the same "
"hash value.)"
msgstr ""
"I valori particolari ``sys.hash_info.inf```, ``-sys.hash_info.inf``` e ``sys."
"hash_info.nan``` sono usati come valori hash per l'infinito positivo, "
"infinito negativo o nans (rispettivamente).  (Tutti gli hashable nan hanno "
"lo stesso valore di hashish.)"

#: ../Doc/library/stdtypes.rst:674
#, fuzzy
msgid ""
"For a :class:`complex` number ``z``, the hash values of the real and "
"imaginary parts are combined by computing ``hash(z.real) + sys.hash_info."
"imag * hash(z.imag)``, reduced modulo ``2**sys.hash_info.width`` so that it "
"lies in ``range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - "
"1))``.  Again, if the result is ``-1``, it's replaced with ``-2``."
msgstr ""
"Per un :class:`complex` numero ``z```, i valori hash delle parti reali e "
"immaginarie sono combinati dal calcolo ``hash(z.real) + sys.hash_info.imag * "
"hash(z.imag)``, modulo ridotto ``2**sys.hash_info.width```, in modo che si "
"trovi in ``range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - "
"1))``.  Di nuovo, se il risultato è ``-1````, viene sostituito con ``-2````."

#: ../Doc/library/stdtypes.rst:682
#, fuzzy
msgid ""
"To clarify the above rules, here's some example Python code, equivalent to "
"the built-in hash, for computing the hash of a rational number, :class:"
"`float`, or :class:`complex`::"
msgstr ""
"Per chiarire le regole di cui sopra, ecco un esempio di codice Python, "
"equivalente all'hash integrato, per calcolare l'hash di un numero "
"razionale, :class:`float`, o :class:`complex`::"

#: ../Doc/library/stdtypes.rst:737
msgid "Iterator Types"
msgstr "Tipi Iteratori"

#: ../Doc/library/stdtypes.rst:745
#, fuzzy
msgid ""
"Python supports a concept of iteration over containers.  This is implemented "
"using two distinct methods; these are used to allow user-defined classes to "
"support iteration.  Sequences, described below in more detail, always "
"support the iteration methods."
msgstr ""
"Python supporta un concetto di iterazione sui contenitori.  Questo è "
"implementato usando due metodi distinti; questi sono usati per permettere a "
"classi definite dall'utente di supportare l'iterazione.  Le sequenze, "
"descritte più in dettaglio di seguito, supportano sempre i metodi di "
"iterazione."

#: ../Doc/library/stdtypes.rst:750
#, fuzzy
msgid ""
"One method needs to be defined for container objects to provide iteration "
"support:"
msgstr ""
"Un metodo deve essere definito per gli oggetti contenitore per fornire "
"supporto all'iterazione:"

#: ../Doc/library/stdtypes.rst:757
#, fuzzy
msgid ""
"Return an iterator object.  The object is required to support the iterator "
"protocol described below.  If a container supports different types of "
"iteration, additional methods can be provided to specifically request "
"iterators for those iteration types.  (An example of an object supporting "
"multiple forms of iteration would be a tree structure which supports both "
"breadth-first and depth-first traversal.)  This method corresponds to the :c:"
"member:`~PyTypeObject.tp_iter` slot of the type structure for Python objects "
"in the Python/C API."
msgstr ""
"Restituire un oggetto iterator.  L'oggetto è necessario per supportare il "
"protocollo iterator descritto di seguito.  Se un contenitore supporta "
"diversi tipi di iterazione, possono essere forniti metodi aggiuntivi per "
"richiedere iteratori specifici per questi tipi di iterazione.  (Un esempio "
"di un oggetto che supporta forme multiple di iterazione sarebbe una "
"struttura ad albero che supporta sia la larghezza-prima che la profondità-"
"prima traversata.)  Questo metodo corrisponde allo slot :c:member:"
"`~PyTypeObject.tp_iter` della struttura dei tipi di oggetti Python nelle API "
"Python/C."

#: ../Doc/library/stdtypes.rst:766
#, fuzzy
msgid ""
"The iterator objects themselves are required to support the following two "
"methods, which together form the :dfn:`iterator protocol`:"
msgstr ""
"Gli stessi oggetti iterator sono tenuti a supportare i due metodi seguenti, "
"che insieme formano il :dfn:`protocollo iterator`:"

#: ../Doc/library/stdtypes.rst:772
#, fuzzy
msgid ""
"Return the iterator object itself.  This is required to allow both "
"containers and iterators to be used with the :keyword:`for` and :keyword:"
"`in` statements. This method corresponds to the :c:member:`~PyTypeObject."
"tp_iter` slot of the type structure for Python objects in the Python/C API."
msgstr ""
"Restituire l'oggetto iterator stesso.  Questo è necessario per permettere "
"che sia i contenitori che gli iteratori siano usati con la parola chiave:"
"`for` e :keyword:`in` statements. Questo metodo corrisponde allo slot :c:"
"member:`~PyTypeObject.tp_iter` della struttura dei tipi di oggetti Python "
"nelle API Python/C."

#: ../Doc/library/stdtypes.rst:780
#, fuzzy
msgid ""
"Return the next item from the container.  If there are no further items, "
"raise the :exc:`StopIteration` exception.  This method corresponds to the :c:"
"member:`~PyTypeObject.tp_iternext` slot of the type structure for Python "
"objects in the Python/C API."
msgstr ""
"Restituire l'articolo successivo dal contenitore.  Se non ci sono altri "
"elementi, sollevare l'eccezione :exc:`StopIteration`.  Questo metodo "
"corrisponde allo slot :c:member:`~PyTypeObject.tp_iternext` della struttura "
"di tipo per gli oggetti Python nelle API Python/C."

#: ../Doc/library/stdtypes.rst:785
#, fuzzy
msgid ""
"Python defines several iterator objects to support iteration over general "
"and specific sequence types, dictionaries, and other more specialized "
"forms.  The specific types are not important beyond their implementation of "
"the iterator protocol."
msgstr ""
"Python definisce diversi oggetti iteratori per supportare l'iterazione su "
"tipi di sequenza generale e specifica, dizionari e altre forme più "
"specializzate.  I tipi specifici non sono importanti al di là della loro "
"attuazione del protocollo iterator."

#: ../Doc/library/stdtypes.rst:790
#, fuzzy
msgid ""
"Once an iterator's :meth:`~iterator.__next__` method raises :exc:"
"`StopIteration`, it must continue to do so on subsequent calls. "
"Implementations that do not obey this property are deemed broken."
msgstr ""
"Una volta che il metodo di un iterator's :meth:`~iterator.__next__` solleva :"
"exc:`StopIteration`, deve continuare a farlo per le chiamate successive. Le "
"implementazioni che non obbediscono a questa proprietà sono considerate "
"rotte."

#: ../Doc/library/stdtypes.rst:798
msgid "Generator Types"
msgstr "Tipi generatori"

#: ../Doc/library/stdtypes.rst:800
msgid ""
"Python's :term:`generator`\\s provide a convenient way to implement the "
"iterator protocol.  If a container object's :meth:`__iter__` method is "
"implemented as a generator, it will automatically return an iterator object "
"(technically, a generator object) supplying the :meth:`__iter__` and :meth:"
"`~generator.__next__` methods. More information about generators can be "
"found in :ref:`the documentation for the yield expression <yieldexpr>`."
msgstr ""
"Il :termine:`generator`\\s Python fornisce un modo conveniente per "
"implementare il protocollo iteratore.  Se il metodo :meth:`__iter____` di un "
"oggetto contenitore è implementato come generatore, l’oggetto restituirà "
"automaticamente un oggetto iteratore (tecnicamente, un oggetto generatore) "
"fornendo i metodi :meth:`__iter____` e :meth:`~generator.__next__`. Maggiori "
"informazioni sui generatori si possono trovare in :ref:`the documentation "
"for the yield expression <yieldexpr>`."

#: ../Doc/library/stdtypes.rst:812
msgid "Sequence Types --- :class:`list`, :class:`tuple`, :class:`range`"
msgstr "Tipi di sequenza — :class:`list`, :class:`tuple`, :class:`range`"

#: ../Doc/library/stdtypes.rst:814
msgid ""
"There are three basic sequence types: lists, tuples, and range objects. "
"Additional sequence types tailored for processing of :ref:`binary data "
"<binaryseq>` and :ref:`text strings <textseq>` are described in dedicated "
"sections."
msgstr ""
"Ci sono tre tipi di sequenza base: liste, tuple e oggetti range. I tipi di "
"sequenze aggiuntive per l'elaborazione di :ref:`binary data <binaryseq>`e :"
"ref:`text strings <textseq>` sono descritti in sezioni dedicate."

#: ../Doc/library/stdtypes.rst:823
msgid "Common Sequence Operations"
msgstr "Sequence Operation comuni"

#: ../Doc/library/stdtypes.rst:827
#, fuzzy
msgid ""
"The operations in the following table are supported by most sequence types, "
"both mutable and immutable. The :class:`collections.abc.Sequence` ABC is "
"provided to make it easier to correctly implement these operations on custom "
"sequence types."
msgstr ""
"Le operazioni nella seguente tabella sono supportate dalla maggior parte dei "
"tipi di sequenza, sia mutabili che immutabili. Il file :class:`collections."
"abc.abc.Sequence` ABC è fornito per rendere più facile la corretta "
"implementazione di queste operazioni su tipi di sequenza personalizzati."

#: ../Doc/library/stdtypes.rst:832
#, fuzzy
msgid ""
"This table lists the sequence operations sorted in ascending priority.  In "
"the table, *s* and *t* are sequences of the same type, *n*, *i*, *j* and *k* "
"are integers and *x* is an arbitrary object that meets any type and value "
"restrictions imposed by *s*."
msgstr ""
"Questa tabella elenca le operazioni di sequenza ordinate in priorità "
"crescente.  Nella tabella, *s* e *t* sono sequenze dello stesso tipo, *n*, "
"*i*, *i*, *j* e *k* sono interi e *x* è un oggetto arbitrario che soddisfa "
"qualsiasi tipo e restrizione di valore imposta da *s*."

#: ../Doc/library/stdtypes.rst:837
#, fuzzy
msgid ""
"The ``in`` and ``not in`` operations have the same priorities as the "
"comparison operations. The ``+`` (concatenation) and ``*`` (repetition) "
"operations have the same priority as the corresponding numeric operations. "
"[3]_"
msgstr ""
"Le operazioni \"in\" e \"non in\" hanno le stesse priorità delle operazioni "
"di confronto. Le operazioni ``++``` (concatenazione) e ``*``` (ripetizione) "
"hanno la stessa priorità delle corrispondenti operazioni numeriche. [3]_"

#: ../Doc/library/stdtypes.rst:858
msgid "``x in s``"
msgstr "``x in s``"

#: ../Doc/library/stdtypes.rst:858
msgid "``True`` if an item of *s* is equal to *x*, else ``False``"
msgstr "``True`` se un elemento di *s* è uguale a *x*, altrimenti ``False``"

#: ../Doc/library/stdtypes.rst:861
msgid "``x not in s``"
msgstr "``x non in s``"

#: ../Doc/library/stdtypes.rst:861
msgid "``False`` if an item of *s* is equal to *x*, else ``True``"
msgstr "``False`` se un elemento di *s* è uguale a *x*, altrimenti ``True``"

#: ../Doc/library/stdtypes.rst:864
msgid "``s + t``"
msgstr "``s + t``"

#: ../Doc/library/stdtypes.rst:864
msgid "the concatenation of *s* and *t*"
msgstr "la concatenazione di *s* e *t*"

#: ../Doc/library/stdtypes.rst:864
msgid "(6)(7)"
msgstr "(6)(7)"

#: ../Doc/library/stdtypes.rst:867
msgid "``s * n`` or ``n * s``"
msgstr "``s * n`` o ``n * s``"

#: ../Doc/library/stdtypes.rst:867
msgid "equivalent to adding *s* to itself *n* times"
msgstr "equivalente all'aggiunta di *s* a se stesso *n* volte"

#: ../Doc/library/stdtypes.rst:867
msgid "(2)(7)"
msgstr "(2)(7)"

#: ../Doc/library/stdtypes.rst:870
msgid "``s[i]``"
msgstr "``s[i]``"

#: ../Doc/library/stdtypes.rst:870
msgid "*i*\\ th item of *s*, origin 0"
msgstr "l’oggetto *i*\\ di *s*, origine 0"

#: ../Doc/library/stdtypes.rst:872
msgid "``s[i:j]``"
msgstr "``s[i:j]``"

#: ../Doc/library/stdtypes.rst:872
#, fuzzy
msgid "slice of *s* from *i* to *j*"
msgstr "fetta di *s* da *i* a *j*"

#: ../Doc/library/stdtypes.rst:872
msgid "(3)(4)"
msgstr "(3)(4)"

#: ../Doc/library/stdtypes.rst:874
msgid "``s[i:j:k]``"
msgstr "``s[i:j:k]``"

#: ../Doc/library/stdtypes.rst:874
#, fuzzy
msgid "slice of *s* from *i* to *j* with step *k*"
msgstr "fetta di *s* da *i* a *j* con passo *k*"

#: ../Doc/library/stdtypes.rst:874
msgid "(3)(5)"
msgstr "(3)(5)"

#: ../Doc/library/stdtypes.rst:877
msgid "``len(s)``"
msgstr "``len(s)``"

#: ../Doc/library/stdtypes.rst:877
msgid "length of *s*"
msgstr "lunghezza di *s*"

#: ../Doc/library/stdtypes.rst:879
msgid "``min(s)``"
msgstr "``min(s)``"

#: ../Doc/library/stdtypes.rst:879
msgid "smallest item of *s*"
msgstr "oggetto più piccolo di *s*"

#: ../Doc/library/stdtypes.rst:881
msgid "``max(s)``"
msgstr "``max(s)``"

#: ../Doc/library/stdtypes.rst:881
msgid "largest item of *s*"
msgstr "oggetto più grande di *s*"

#: ../Doc/library/stdtypes.rst:883
msgid "``s.index(x[, i[, j]])``"
msgstr "``s.index(x[, i[, j]])``"

#: ../Doc/library/stdtypes.rst:883
#, fuzzy
msgid ""
"index of the first occurrence of *x* in *s* (at or after index *i* and "
"before index *j*)"
msgstr ""
"indice della prima occorrenza di *x* in *s* (a o dopo l'indice *i* e prima "
"dell'indice *j*)"

#: ../Doc/library/stdtypes.rst:883 ../Doc/library/stdtypes.rst:3339
msgid "\\(8)"
msgstr "\\(8)"

#: ../Doc/library/stdtypes.rst:887
msgid "``s.count(x)``"
msgstr "``s.count(x)``"

#: ../Doc/library/stdtypes.rst:887
msgid "total number of occurrences of *x* in *s*"
msgstr "numero totale di occorrenze di *x* in *s*"

#: ../Doc/library/stdtypes.rst:891
#, fuzzy
msgid ""
"Sequences of the same type also support comparisons.  In particular, tuples "
"and lists are compared lexicographically by comparing corresponding "
"elements. This means that to compare equal, every element must compare equal "
"and the two sequences must be of the same type and have the same length.  "
"(For full details see :ref:`comparisons` in the language reference.)"
msgstr ""
"Sequenze dello stesso tipo supportano anche i confronti.  In particolare, le "
"tuple e gli elenchi sono confrontati lessicograficamente confrontando gli "
"elementi corrispondenti. Questo significa che per fare un confronto uguale, "
"ogni elemento deve essere uguale e le due sequenze devono essere dello "
"stesso tipo e avere la stessa lunghezza.  (Per maggiori dettagli vedere :ref:"
"`comparazioni` nella lingua di riferimento.)"

#: ../Doc/library/stdtypes.rst:900
#, fuzzy
msgid ""
"While the ``in`` and ``not in`` operations are used only for simple "
"containment testing in the general case, some specialised sequences (such "
"as :class:`str`, :class:`bytes` and :class:`bytearray`) also use them for "
"subsequence testing::"
msgstr ""
"Mentre le operazioni ``in```` e ``'not in``` sono usate solo per semplici "
"test di contenimento nel caso generale, alcune sequenze specializzate (come :"
"class:`str`, :class:`bytes` e :class:`bytearray`) le usano anche per i test "
"successivi:"

#: ../Doc/library/stdtypes.rst:909
#, fuzzy
msgid ""
"Values of *n* less than ``0`` are treated as ``0`` (which yields an empty "
"sequence of the same type as *s*).  Note that items in the sequence *s* are "
"not copied; they are referenced multiple times.  This often haunts new "
"Python programmers; consider::"
msgstr ""
"I valori di *n* inferiori a ``0```` vengono trattati come ``0``` (che "
"produce una sequenza vuota dello stesso tipo di *s*).  Si noti che le voci "
"della sequenza *s* non vengono copiate; sono riferite più volte.  Questo "
"spesso infesta nuovi programmatori Python; considerare:.:"

#: ../Doc/library/stdtypes.rst:921
#, fuzzy
msgid ""
"What has happened is that ``[[]]`` is a one-element list containing an empty "
"list, so all three elements of ``[[]] * 3`` are references to this single "
"empty list.  Modifying any of the elements of ``lists`` modifies this single "
"list. You can create a list of different lists this way::"
msgstr ""
"Quello che è successo è che ``[[[[]]`` è una lista ad un elemento contenente "
"una lista vuota, quindi tutti e tre gli elementi di ``[[[]]] * 3```` sono "
"riferimenti a questo unico elenco vuoto.  Modificare uno qualsiasi degli "
"elementi delle ``liste``` modifica questa singola lista. È possibile creare "
"una lista di liste diverse in questo modo::"

#: ../Doc/library/stdtypes.rst:933
#, fuzzy
msgid ""
"Further explanation is available in the FAQ entry :ref:`faq-multidimensional-"
"list`."
msgstr ""
"Ulteriori spiegazioni sono disponibili nella voce FAQ: ref:`faq-"
"multidimensional-list`."

#: ../Doc/library/stdtypes.rst:937
#, fuzzy
msgid ""
"If *i* or *j* is negative, the index is relative to the end of sequence *s*: "
"``len(s) + i`` or ``len(s) + j`` is substituted.  But note that ``-0`` is "
"still ``0``."
msgstr ""
"Se *i* o *j* è negativo, l'indice è relativo alla fine della sequenza *s*: "
"``len(s) + i``` o ``len(s) + j```` è sostituito.  Ma nota che ``-0```` è "
"ancora ``0````."

#: ../Doc/library/stdtypes.rst:942
#, fuzzy
msgid ""
"The slice of *s* from *i* to *j* is defined as the sequence of items with "
"index *k* such that ``i <= k < j``.  If *i* or *j* is greater than "
"``len(s)``, use ``len(s)``.  If *i* is omitted or ``None``, use ``0``.  If "
"*j* is omitted or ``None``, use ``len(s)``.  If *i* is greater than or equal "
"to *j*, the slice is empty."
msgstr ""
"La fetta di *s* da *i* a *j* è definita come la sequenza di elementi con "
"indice *k* tale che ``i <= k <= k < j````.  Se *i* o *j* è maggiore di "
"``len(s)```, usare ``len(s)``.  Se *i* è omesso o ```No`````, usare "
"``0````.  Se *j* è omesso o ```Nessuno```, usare ``len(s)```.  Se *i* è "
"maggiore o uguale a *j*, la fetta è vuota."

#: ../Doc/library/stdtypes.rst:949
#, fuzzy
msgid ""
"The slice of *s* from *i* to *j* with step *k* is defined as the sequence of "
"items with index  ``x = i + n*k`` such that ``0 <= n < (j-i)/k``.  In other "
"words, the indices are ``i``, ``i+k``, ``i+2*k``, ``i+3*k`` and so on, "
"stopping when *j* is reached (but never including *j*).  When *k* is "
"positive, *i* and *j* are reduced to ``len(s)`` if they are greater. When "
"*k* is negative, *i* and *j* are reduced to ``len(s) - 1`` if they are "
"greater.  If *i* or *j* are omitted or ``None``, they become \"end\" values "
"(which end depends on the sign of *k*).  Note, *k* cannot be zero. If *k* is "
"``None``, it is treated like ``1``."
msgstr ""
"La porzione di *s* da *i* a *j* con passo *k* è definita come la sequenza di "
"elementi con indice ``x = i + n*k``` tale che ``0 <= n <= n < (j-i)/k```.  "
"In altre parole, gli indici sono ``i``i``, ``i+k```, ``i+2*k``, ``i+3*k``` e "
"così via, fermandosi quando si raggiunge *j* (ma senza mai includere *j*).  "
"Quando *k* è positivo, *i* e *j* sono ridotti a ``len(s)`` se sono maggiori. "
"Quando *k* è negativo, *i* e *j* sono ridotti a ``len(i) - 1``` se sono "
"maggiori.  Se *i* o *j* sono omessi o ``'Nessuno````, diventano valori "
"\"finali\" (il cui termine dipende dal segno di *k*).  Nota: *k* non può "
"essere zero. Se *k* è ``\"Nessuno````, viene trattato come ``1```."

#: ../Doc/library/stdtypes.rst:960
#, fuzzy
msgid ""
"Concatenating immutable sequences always results in a new object.  This "
"means that building up a sequence by repeated concatenation will have a "
"quadratic runtime cost in the total sequence length.  To get a linear "
"runtime cost, you must switch to one of the alternatives below:"
msgstr ""
"Concatenando sequenze immutabili si ottiene sempre un nuovo oggetto.  Ciò "
"significa che la costruzione di una sequenza per concatenazione ripetuta "
"avrà un costo di esecuzione quadratico nella lunghezza totale della "
"sequenza.  Per ottenere un costo di esercizio lineare, è necessario passare "
"ad una delle seguenti alternative:"

#: ../Doc/library/stdtypes.rst:965
#, fuzzy
msgid ""
"if concatenating :class:`str` objects, you can build a list and use :meth:"
"`str.join` at the end or else write to an :class:`io.StringIO` instance and "
"retrieve its value when complete"
msgstr ""
"se concatenando gli oggetti :class:`str`, è possibile costruire una lista e "
"utilizzare :meth:`str.join` alla fine oppure scrivere in un'istanza :class:"
"`io.StringIO` e recuperare il suo valore una volta completata"

#: ../Doc/library/stdtypes.rst:969
#, fuzzy
msgid ""
"if concatenating :class:`bytes` objects, you can similarly use :meth:`bytes."
"join` or :class:`io.BytesIO`, or you can do in-place concatenation with a :"
"class:`bytearray` object.  :class:`bytearray` objects are mutable and have "
"an efficient overallocation mechanism"
msgstr ""
"se si concatenano gli oggetti :class:`bytes`, si possono usare allo stesso "
"modo :meth:`bytes.join` o :class:`io.BytesIO`, oppure si può fare una "
"concatenazione in-place con un oggetto :class:`bytearray`. :class:"
"`bytearray` gli oggetti sono mutevoli e hanno un efficiente meccanismo di "
"sovraallocazione"

#: ../Doc/library/stdtypes.rst:974
#, fuzzy
msgid "if concatenating :class:`tuple` objects, extend a :class:`list` instead"
msgstr ""
"se si concatenano gli oggetti :class:`tuple`, estendere un oggetto :class:"
"`list`` invece"

#: ../Doc/library/stdtypes.rst:976
#, fuzzy
msgid "for other types, investigate the relevant class documentation"
msgstr ""
"per gli altri tipi, esaminare la documentazione relativa alla classe di "
"appartenenza"

#: ../Doc/library/stdtypes.rst:980
#, fuzzy
msgid ""
"Some sequence types (such as :class:`range`) only support item sequences "
"that follow specific patterns, and hence don't support sequence "
"concatenation or repetition."
msgstr ""
"Alcuni tipi di sequenza (come :class:`range`) supportano solo sequenze di "
"elementi che seguono schemi specifici, e quindi non supportano la "
"concatenazione o la ripetizione di sequenze."

#: ../Doc/library/stdtypes.rst:985
#, fuzzy
msgid ""
"``index`` raises :exc:`ValueError` when *x* is not found in *s*. Not all "
"implementations support passing the additional arguments *i* and *j*. These "
"arguments allow efficient searching of subsections of the sequence. Passing "
"the extra arguments is roughly equivalent to using ``s[i:j].index(x)``, only "
"without copying any data and with the returned index being relative to the "
"start of the sequence rather than the start of the slice."
msgstr ""
"``indice```` aumenta :exc:``ValueError` quando *x* non si trova in *s*. Non "
"tutte le implementazioni supportano il passaggio degli argomenti aggiuntivi "
"*i* e *j*. Questi argomenti permettono una ricerca efficiente di "
"sottosezioni della sequenza. Passare gli argomenti extra equivale "
"approssimativamente ad usare ``s[i:j].index(x)``, solo senza copiare alcun "
"dato e con l'indice restituito relativo all'inizio della sequenza piuttosto "
"che all'inizio della fetta."

#: ../Doc/library/stdtypes.rst:996
msgid "Immutable Sequence Types"
msgstr "Tipi di sequenze immutabili"

#: ../Doc/library/stdtypes.rst:1003
#, fuzzy
msgid ""
"The only operation that immutable sequence types generally implement that is "
"not also implemented by mutable sequence types is support for the :func:"
"`hash` built-in."
msgstr ""
"L'unica operazione che i tipi di sequenza immutabile generalmente "
"implementare che non è implementato anche da tipi di sequenza mutevole è il "
"supporto per il :func:`hash` built-in."

#: ../Doc/library/stdtypes.rst:1007
#, fuzzy
msgid ""
"This support allows immutable sequences, such as :class:`tuple` instances, "
"to be used as :class:`dict` keys and stored in :class:`set` and :class:"
"`frozenset` instances."
msgstr ""
"Questo supporto permette di utilizzare sequenze immutabili, come ad esempio :"
"class:`tuple` istanze, da usare come chiavi :class:`dict` e memorizzate in :"
"class:`set` e :class:`frozenset` istanze."

#: ../Doc/library/stdtypes.rst:1011
#, fuzzy
msgid ""
"Attempting to hash an immutable sequence that contains unhashable values "
"will result in :exc:`TypeError`."
msgstr ""
"Il tentativo di hash una sequenza immutabile che contiene valori non "
"modificabili si tradurrà in:exc:`TypeError`."

#: ../Doc/library/stdtypes.rst:1018
#, fuzzy
msgid "Mutable Sequence Types"
msgstr "Tipi di sequenza mutevole"

#: ../Doc/library/stdtypes.rst:1025
#, fuzzy
msgid ""
"The operations in the following table are defined on mutable sequence types. "
"The :class:`collections.abc.MutableSequence` ABC is provided to make it "
"easier to correctly implement these operations on custom sequence types."
msgstr ""
"Le operazioni della seguente tabella sono definite su tipi di sequenza "
"mutevoli. Il file :class:`collections.abc.abc.MutableSequence` ABC è fornito "
"per rendere più facile la corretta implementazione di queste operazioni su "
"tipi di sequenza personalizzati."

#: ../Doc/library/stdtypes.rst:1029
#, fuzzy
msgid ""
"In the table *s* is an instance of a mutable sequence type, *t* is any "
"iterable object and *x* is an arbitrary object that meets any type and value "
"restrictions imposed by *s* (for example, :class:`bytearray` only accepts "
"integers that meet the value restriction ``0 <= x <= 255``)."
msgstr ""
"Nella tabella *s* è un'istanza di un tipo di sequenza mutevole, *t* è un "
"qualsiasi oggetto iterabile e *x* è un oggetto arbitrario che soddisfa "
"qualsiasi tipo e restrizione di valore imposta da *s* (per esempio, :class:"
"`bytearray` accetta solo interi che soddisfano la restrizione di valore ``0 "
"<= x <= <= 255```)."

#: ../Doc/library/stdtypes.rst:1053
msgid "``s[i] = x``"
msgstr "``s[i] = x``"

#: ../Doc/library/stdtypes.rst:1053
msgid "item *i* of *s* is replaced by *x*"
msgstr "l’oggetto *i* di *s* è sostituito da *x*"

#: ../Doc/library/stdtypes.rst:1056
msgid "``s[i:j] = t``"
msgstr "``s[i:j] = t``"

#: ../Doc/library/stdtypes.rst:1056
msgid ""
"slice of *s* from *i* to *j* is replaced by the contents of the iterable *t*"
msgstr ""
"la fetta di *s* da *i* a *j* è sostituita dal contenuto dell’iterabile *t*"

#: ../Doc/library/stdtypes.rst:1060
msgid "``del s[i:j]``"
msgstr "``del s[i:j]``"

#: ../Doc/library/stdtypes.rst:1060
msgid "same as ``s[i:j] = []``"
msgstr "come ``s[i:j] = []``"

#: ../Doc/library/stdtypes.rst:1062
msgid "``s[i:j:k] = t``"
msgstr "``s[i:j:k] = t``"

#: ../Doc/library/stdtypes.rst:1062
msgid "the elements of ``s[i:j:k]`` are replaced by those of *t*"
msgstr "gli elementi di ``s[i:j:j:k]`` sono sostituiti da quelli di *t*"

#: ../Doc/library/stdtypes.rst:1065
msgid "``del s[i:j:k]``"
msgstr "``del s[i:j:k]``"

#: ../Doc/library/stdtypes.rst:1065
msgid "removes the elements of ``s[i:j:k]`` from the list"
msgstr "rimuove gli elementi di ``s[i:j:k:k]`` dalla lista"

#: ../Doc/library/stdtypes.rst:1068
msgid "``s.append(x)``"
msgstr "``s.append(x)``"

#: ../Doc/library/stdtypes.rst:1068
msgid ""
"appends *x* to the end of the sequence (same as ``s[len(s):len(s)] = [x]``)"
msgstr ""
"aggiunge *x* alla fine della sequenza (come ``s[len(s):len(s)] = [x]``)"

#: ../Doc/library/stdtypes.rst:1072
msgid "``s.clear()``"
msgstr "``s.clear()``"

#: ../Doc/library/stdtypes.rst:1072
msgid "removes all items from *s* (same as ``del s[:]``)"
msgstr "rimuove tutti gli elementi da *s* (come ``del s[:]``)"

#: ../Doc/library/stdtypes.rst:1075
msgid "``s.copy()``"
msgstr "``s.copy()``"

#: ../Doc/library/stdtypes.rst:1075
msgid "creates a shallow copy of *s* (same as ``s[:]``)"
msgstr "crea una shallow copy di *s* (come ``s[:]``)"

#: ../Doc/library/stdtypes.rst:1078
msgid "``s.extend(t)`` or ``s += t``"
msgstr "``s.extend(t)`` o ``s += t``"

#: ../Doc/library/stdtypes.rst:1078
msgid ""
"extends *s* with the contents of *t* (for the most part the same as "
"``s[len(s):len(s)] = t``)"
msgstr ""
"estende *s* con il contenuto di *t* (per la maggior parte uguale a "
"``s[len(s):len(s)] = t``)"

#: ../Doc/library/stdtypes.rst:1083
msgid "``s *= n``"
msgstr "``s *= n``"

#: ../Doc/library/stdtypes.rst:1083
msgid "updates *s* with its contents repeated *n* times"
msgstr "aggiorna *s* con i suoi contenuti ripetuti *n* volte"

#: ../Doc/library/stdtypes.rst:1086
msgid "``s.insert(i, x)``"
msgstr "``s.insert(i, x)``"

#: ../Doc/library/stdtypes.rst:1086
msgid ""
"inserts *x* into *s* at the index given by *i* (same as ``s[i:i] = [x]``)"
msgstr "inserisce *x* in *s* nell'indice dato da *i* (come ``s[i:i] = [x]``)"

#: ../Doc/library/stdtypes.rst:1090
msgid "``s.pop([i])``"
msgstr "``s.pop([i])``"

#: ../Doc/library/stdtypes.rst:1090
msgid "retrieves the item at *i* and also removes it from *s*"
msgstr "recupera l’elemento in *i* e lo rimuove anche da *s*"

#: ../Doc/library/stdtypes.rst:1093
msgid "``s.remove(x)``"
msgstr "``s.remove(x)``"

#: ../Doc/library/stdtypes.rst:1093
msgid "remove the first item from *s* where ``s[i]`` is equal to *x*"
msgstr "rimuovere il primo elemento da *s* dove ``s[i]`` è uguale a *x*"

#: ../Doc/library/stdtypes.rst:1096
msgid "``s.reverse()``"
msgstr "``s.reverse()``"

#: ../Doc/library/stdtypes.rst:1096
msgid "reverses the items of *s* in place"
msgstr "inverte gli elementi di *s* in place"

#: ../Doc/library/stdtypes.rst:1104
msgid "*t* must have the same length as the slice it is replacing."
msgstr "*t* deve avere la stessa lunghezza della parte che sta sostituendo."

#: ../Doc/library/stdtypes.rst:1107
msgid ""
"The optional argument *i* defaults to ``-1``, so that by default the last "
"item is removed and returned."
msgstr ""
"L'argomento opzionale *i* predefinito è ``-1``, in modo che per default "
"l'ultimo elemento venga rimosso e restituito."

#: ../Doc/library/stdtypes.rst:1111
msgid "``remove`` raises :exc:`ValueError` when *x* is not found in *s*."
msgstr ""
"``remove`` solleva :exc:`ValueError` quando *x* non viene trovato in *s*."

#: ../Doc/library/stdtypes.rst:1114
msgid ""
"The :meth:`reverse` method modifies the sequence in place for economy of "
"space when reversing a large sequence.  To remind users that it operates by "
"side effect, it does not return the reversed sequence."
msgstr ""
"Il metodo :meth:`reverse` modifica la sequenza in place per il risparmio di "
"spazio quando si inverte una grande sequenza. Per ricordare agli utenti che "
"opera per side effect, non restituisce la sequenza invertita."

#: ../Doc/library/stdtypes.rst:1119
#, fuzzy
msgid ""
":meth:`clear` and :meth:`!copy` are included for consistency with the "
"interfaces of mutable containers that don't support slicing operations (such "
"as :class:`dict` and :class:`set`)"
msgstr ""
":meth:`clear` e :meth:`!copy` sono inclusi per coerenza con le interfacce di "
"contenitori mutevoli che non supportano le operazioni di taglio (come :class:"
"`dict` e :class:`set`)"

#: ../Doc/library/stdtypes.rst:1123
msgid ":meth:`clear` and :meth:`!copy` methods."
msgstr "Metodi :meth:`clear` e :meth:`!copy`."

#: ../Doc/library/stdtypes.rst:1127
#, fuzzy
msgid ""
"The value *n* is an integer, or an object implementing :meth:`~object."
"__index__`.  Zero and negative values of *n* clear the sequence.  Items in "
"the sequence are not copied; they are referenced multiple times, as "
"explained for ``s * n`` under :ref:`typesseq-common`."
msgstr ""
"Il valore *n* è un intero, o un oggetto che implementa :meth:`~object."
"__index____`.  I valori zero e negativi di *n* cancellano la sequenza.  Gli "
"elementi della sequenza non vengono copiati; essi sono riferiti più volte, "
"come spiegato per ``s *`s * n```` sotto :ref:`typesseq-common`."

#: ../Doc/library/stdtypes.rst:1136
msgid "Lists"
msgstr "Liste"

#: ../Doc/library/stdtypes.rst:1140
#, fuzzy
msgid ""
"Lists are mutable sequences, typically used to store collections of "
"homogeneous items (where the precise degree of similarity will vary by "
"application)."
msgstr ""
"Gli elenchi sono sequenze mutevoli, tipicamente utilizzate per memorizzare "
"collezioni di articoli omogenei (dove il grado preciso di somiglianza varia "
"a seconda dell'applicazione)."

#: ../Doc/library/stdtypes.rst:1146
msgid "Lists may be constructed in several ways:"
msgstr "Le liste possono essere costruite in diversi modi:"

#: ../Doc/library/stdtypes.rst:1148
#, fuzzy
msgid "Using a pair of square brackets to denote the empty list: ``[]``"
msgstr ""
"Utilizzando una coppia di parentesi quadre per indicare la lista vuota: "
"``[]``"

#: ../Doc/library/stdtypes.rst:1149
#, fuzzy
msgid ""
"Using square brackets, separating items with commas: ``[a]``, ``[a, b, c]``"
msgstr ""
"Usando le parentesi quadre, separando gli elementi con virgole: ``[a]```, "
"``[a, b, c]```"

#: ../Doc/library/stdtypes.rst:1150
#, fuzzy
msgid "Using a list comprehension: ``[x for x in iterable]``"
msgstr "Utilizzando una lista di comprensione: ``[x per x in iterable]````"

#: ../Doc/library/stdtypes.rst:1151
#, fuzzy
msgid "Using the type constructor: ``list()`` or ``list(iterable)``"
msgstr ""
"Utilizzando il costruttore del tipo: ``list()``` o ``list(iterable)````"

#: ../Doc/library/stdtypes.rst:1153
#, fuzzy
msgid ""
"The constructor builds a list whose items are the same and in the same order "
"as *iterable*'s items.  *iterable* may be either a sequence, a container "
"that supports iteration, or an iterator object.  If *iterable* is already a "
"list, a copy is made and returned, similar to ``iterable[:]``. For example, "
"``list('abc')`` returns ``['a', 'b', 'c']`` and ``list( (1, 2, 3) )`` "
"returns ``[1, 2, 3]``. If no argument is given, the constructor creates a "
"new empty list, ``[]``."
msgstr ""
"Il costruttore costruisce una lista i cui elementi sono gli stessi e nello "
"stesso ordine degli elementi *letterabili*.  *iterable* può essere sia una "
"sequenza, un contenitore che supporta l'iterazione, o un oggetto iterator.  "
"Se *iterable* è già una lista, viene fatta e restituita una copia, simile a "
"``iterable[:]```. Per esempio, ``list('abc')```` restituisce ``['a', 'b', "
"'c']``` e ``list( (1, 2, 3) )``` restituisce ``[1, 2, 3]``. Se non viene "
"dato alcun argomento, il costruttore crea una nuova lista vuota, ``[]````."

#: ../Doc/library/stdtypes.rst:1162
#, fuzzy
msgid ""
"Many other operations also produce lists, including the :func:`sorted` built-"
"in."
msgstr ""
"Molte altre operazioni producono anche liste, tra cui :func:`sorted` built-"
"in."

#: ../Doc/library/stdtypes.rst:1165
msgid ""
"Lists implement all of the :ref:`common <typesseq-common>` and :ref:`mutable "
"<typesseq-mutable>` sequence operations. Lists also provide the following "
"additional method:"
msgstr ""
"Le liste implementano tutte le operazioni :ref:`common <typesseq-common>` e :"
"ref:`mutable <typesseq-mutable>`. Le liste forniscono inoltre questi metodi "
"addizionali:"

#: ../Doc/library/stdtypes.rst:1171
#, fuzzy
msgid ""
"This method sorts the list in place, using only ``<`` comparisons between "
"items. Exceptions are not suppressed - if any comparison operations fail, "
"the entire sort operation will fail (and the list will likely be left in a "
"partially modified state)."
msgstr ""
"Questo metodo ordina l'elenco in vigore, utilizzando solo i confronti "
"``<`<```` tra gli elementi. Le eccezioni non sono soppresse - se una "
"qualsiasi operazione di confronto fallisce, l'intera operazione di "
"ordinamento fallirà (e l'elenco sarà probabilmente lasciato in uno stato "
"parzialmente modificato)."

#: ../Doc/library/stdtypes.rst:1176
#, fuzzy
msgid ""
":meth:`sort` accepts two arguments that can only be passed by keyword (:ref:"
"`keyword-only arguments <keyword-only_parameter>`):"
msgstr ""
":meth:`sort` accetta due argomenti che possono essere passati solo per "
"parola chiave (:ref:`keyword-only_parameter>`):"

#: ../Doc/library/stdtypes.rst:1179
#, fuzzy
msgid ""
"*key* specifies a function of one argument that is used to extract a "
"comparison key from each list element (for example, ``key=str.lower``). The "
"key corresponding to each item in the list is calculated once and then used "
"for the entire sorting process. The default value of ``None`` means that "
"list items are sorted directly without calculating a separate key value."
msgstr ""
"*key* specifica una funzione di un argomento utilizzato per estrarre una "
"chiave di confronto da ogni elemento della lista (per esempio, ``key=str."
"lower```). La chiave corrispondente a ciascun elemento dell'elenco viene "
"calcolata una volta e poi utilizzata per l'intero processo di ordinamento. "
"Il valore predefinito di ```Nessuno``` significa che gli elementi della "
"lista sono ordinati direttamente senza calcolare un valore chiave separato."

#: ../Doc/library/stdtypes.rst:1186
#, fuzzy
msgid ""
"The :func:`functools.cmp_to_key` utility is available to convert a 2.x style "
"*cmp* function to a *key* function."
msgstr ""
"L'utilità :func:`functools.cmp_to_key` è disponibile per convertire una "
"funzione *cmp* di stile 2.x in una funzione *chiave*."

#: ../Doc/library/stdtypes.rst:1189
#, fuzzy
msgid ""
"*reverse* is a boolean value.  If set to ``True``, then the list elements "
"are sorted as if each comparison were reversed."
msgstr ""
"*reverse* è un valore booleano.  Se impostato su ``True```, allora gli "
"elementi della lista sono ordinati come se ogni confronto fosse invertito."

#: ../Doc/library/stdtypes.rst:1192
#, fuzzy
msgid ""
"This method modifies the sequence in place for economy of space when sorting "
"a large sequence.  To remind users that it operates by side effect, it does "
"not return the sorted sequence (use :func:`sorted` to explicitly request a "
"new sorted list instance)."
msgstr ""
"Questo metodo modifica la sequenza in atto per l'economia di spazio durante "
"l'ordinamento di una grande sequenza.  Per ricordare agli utenti che opera "
"per effetto collaterale, non restituisce la sequenza ordinata (usare :func:"
"`sorted` per richiedere esplicitamente una nuova istanza di lista ordinata)."

#: ../Doc/library/stdtypes.rst:1197
#, fuzzy
msgid ""
"The :meth:`sort` method is guaranteed to be stable.  A sort is stable if it "
"guarantees not to change the relative order of elements that compare equal "
"--- this is helpful for sorting in multiple passes (for example, sort by "
"department, then by salary grade)."
msgstr ""
"Il metodo :meth:`sort` è garantito per essere stabile.  Un ordinamento è "
"stabile se garantisce di non modificare l'ordine relativo degli elementi che "
"confrontano uguali ----- questo è utile per l'ordinamento in passaggi "
"multipli (per esempio, ordinamento per reparto, poi per grado di stipendio)."

#: ../Doc/library/stdtypes.rst:1204
#, fuzzy
msgid ""
"While a list is being sorted, the effect of attempting to mutate, or even "
"inspect, the list is undefined.  The C implementation of Python makes the "
"list appear empty for the duration, and raises :exc:`ValueError` if it can "
"detect that the list has been mutated during a sort."
msgstr ""
"Mentre un elenco è in fase di ordinamento, l'effetto del tentativo di "
"mutazione, o addirittura di ispezione, l'elenco è indefinito.  "
"L'implementazione C di Python fa apparire la lista vuota per la durata, e "
"solleva: exc:`ValueError` se è in grado di rilevare che la lista è stata "
"modificata durante un ordinamento."

#: ../Doc/library/stdtypes.rst:1213
msgid "Tuples"
msgstr "Tuple"

#: ../Doc/library/stdtypes.rst:1217
#, fuzzy
msgid ""
"Tuples are immutable sequences, typically used to store collections of "
"heterogeneous data (such as the 2-tuples produced by the :func:`enumerate` "
"built-in). Tuples are also used for cases where an immutable sequence of "
"homogeneous data is needed (such as allowing storage in a :class:`set` or :"
"class:`dict` instance)."
msgstr ""
"Le tuple sono sequenze immutabili, tipicamente utilizzate per memorizzare "
"collezioni di dati eterogenei (come le 2 triple prodotte da :func:"
"`enumerate` built-in). Le tuple sono utilizzate anche per i casi in cui è "
"necessaria una sequenza immutabile di dati omogenei (come ad esempio per "
"consentire la memorizzazione in un'istanza :class:`set` o :class:`dict`)."

#: ../Doc/library/stdtypes.rst:1225
msgid "Tuples may be constructed in a number of ways:"
msgstr "Le tuple possono essere costruite in vari modi:"

#: ../Doc/library/stdtypes.rst:1227
#, fuzzy
msgid "Using a pair of parentheses to denote the empty tuple: ``()``"
msgstr "Usando una coppia di parentesi per indicare la tupla vuota: ``()``"

#: ../Doc/library/stdtypes.rst:1228
#, fuzzy
msgid "Using a trailing comma for a singleton tuple: ``a,`` or ``(a,)``"
msgstr ""
"Usando una virgola trailing per una tupla singleton: ``a,``` o ```(a,)```"

#: ../Doc/library/stdtypes.rst:1229
#, fuzzy
msgid "Separating items with commas: ``a, b, c`` or ``(a, b, c)``"
msgstr "Separare le voci con virgole: ``a, b, c``` o ``(a, b, c)```"

#: ../Doc/library/stdtypes.rst:1230
#, fuzzy
msgid "Using the :func:`tuple` built-in: ``tuple()`` or ``tuple(iterable)``"
msgstr "Usando il :func:``tuple` built-in: ``tuple()``` o ``tuple(iterable)```"

#: ../Doc/library/stdtypes.rst:1232
#, fuzzy
msgid ""
"The constructor builds a tuple whose items are the same and in the same "
"order as *iterable*'s items.  *iterable* may be either a sequence, a "
"container that supports iteration, or an iterator object.  If *iterable* is "
"already a tuple, it is returned unchanged. For example, ``tuple('abc')`` "
"returns ``('a', 'b', 'c')`` and ``tuple( [1, 2, 3] )`` returns ``(1, 2, "
"3)``. If no argument is given, the constructor creates a new empty tuple, "
"``()``."
msgstr ""
"Il costruttore costruisce una tupla i cui elementi sono gli stessi e nello "
"stesso ordine degli elementi *letterabili*.  *iterable* può essere sia una "
"sequenza, un contenitore che supporta l'iterazione, o un oggetto iterator.  "
"Se *iterable* è già una tupla, viene restituita invariata. Per esempio, "
"```tuple('abc')```` restituisce ``('a', 'b', 'c')``` e ``tuple( [1, 2, "
"3] )``` restituisce ``(1, 2, 3)```. Se non viene dato alcun argomento, il "
"costruttore crea una nuova tupla vuota, ``(`()```."

#: ../Doc/library/stdtypes.rst:1240
#, fuzzy
msgid ""
"Note that it is actually the comma which makes a tuple, not the parentheses. "
"The parentheses are optional, except in the empty tuple case, or when they "
"are needed to avoid syntactic ambiguity. For example, ``f(a, b, c)`` is a "
"function call with three arguments, while ``f((a, b, c))`` is a function "
"call with a 3-tuple as the sole argument."
msgstr ""
"Si noti che in realtà è la virgola che fa una tupla, non le parentesi. Le "
"parentesi sono facoltative, tranne che nel caso di tuple vuote, o quando "
"sono necessarie per evitare ambiguità sintattica. Per esempio, ``f(a, b, "
"c)``` è una chiamata di funzione con tre argomenti, mentre ``f((a, b, c))``` "
"è una chiamata di funzione con un 3-tuple come unico argomento."

#: ../Doc/library/stdtypes.rst:1246
msgid ""
"Tuples implement all of the :ref:`common <typesseq-common>` sequence "
"operations."
msgstr ""
"Le tuple implementano tutte le operazioni :ref:`common <typesseq-common>`."

#: ../Doc/library/stdtypes.rst:1249
#, fuzzy
msgid ""
"For heterogeneous collections of data where access by name is clearer than "
"access by index, :func:`collections.namedtuple` may be a more appropriate "
"choice than a simple tuple object."
msgstr ""
"Per raccolte eterogenee di dati in cui l'accesso per nome è più chiaro "
"dell'accesso per indice, :func:`collections.namedtuple` può essere una "
"scelta più appropriata di un semplice oggetto tuple."

#: ../Doc/library/stdtypes.rst:1257
msgid "Ranges"
msgstr "Cappe"

#: ../Doc/library/stdtypes.rst:1261
#, fuzzy
msgid ""
"The :class:`range` type represents an immutable sequence of numbers and is "
"commonly used for looping a specific number of times in :keyword:`for` loops."
msgstr ""
"Il tipo :class:`range` rappresenta una sequenza immutabile di numeri ed è "
"comunemente usato per il looping di un numero specifico di volte in :keyword:"
"`for` loop."

#: ../Doc/library/stdtypes.rst:1268
#, fuzzy
msgid ""
"The arguments to the range constructor must be integers (either built-in :"
"class:`int` or any object that implements the ``__index__`` special "
"method).  If the *step* argument is omitted, it defaults to ``1``. If the "
"*start* argument is omitted, it defaults to ``0``. If *step* is zero, :exc:"
"`ValueError` is raised."
msgstr ""
"Gli argomenti per il costruttore della gamma devono essere interi (sia built-"
"in :class:`int`` o qualsiasi oggetto che implementi il metodo speciale "
"``__index__index__```).  Se l'argomento *passo* viene omesso, il valore "
"predefinito è ``1```. Se l'argomento *start* viene omesso, l'impostazione "
"predefinita è ``0````. Se *step* è zero, :exc:`ValueError` è aumentato."

#: ../Doc/library/stdtypes.rst:1274
#, fuzzy
msgid ""
"For a positive *step*, the contents of a range ``r`` are determined by the "
"formula ``r[i] = start + step*i`` where ``i >= 0`` and ``r[i] < stop``."
msgstr ""
"Per un *passo* positivo, il contenuto di un intervallo ``r```` è determinato "
"dalla formula ``r[i] = start + step*i``` dove ``i >= 0```` e ``r[i] < "
"stop```."

#: ../Doc/library/stdtypes.rst:1278
#, fuzzy
msgid ""
"For a negative *step*, the contents of the range are still determined by the "
"formula ``r[i] = start + step*i``, but the constraints are ``i >= 0`` and "
"``r[i] > stop``."
msgstr ""
"Per un *passo* negativo, il contenuto dell'intervallo è ancora determinato "
"dalla formula ``r[i] = start + step*i```, ma i vincoli sono ``i >= 0```` e "
"``r[i] > stop```."

#: ../Doc/library/stdtypes.rst:1282
#, fuzzy
msgid ""
"A range object will be empty if ``r[0]`` does not meet the value constraint. "
"Ranges do support negative indices, but these are interpreted as indexing "
"from the end of the sequence determined by the positive indices."
msgstr ""
"Un oggetto range sarà vuoto se ```r[0]``` non soddisfa il vincolo di valore. "
"Gli intervalli supportano gli indici negativi, ma questi sono interpretati "
"come indicizzazione a partire dalla fine della sequenza determinata dagli "
"indici positivi."

#: ../Doc/library/stdtypes.rst:1287
#, fuzzy
msgid ""
"Ranges containing absolute values larger than :data:`sys.maxsize` are "
"permitted but some features (such as :func:`len`) may raise :exc:"
"`OverflowError`."
msgstr ""
"Gli intervalli contenenti valori assoluti più grandi di :data:`sys.maxsize` "
"sono consentiti, ma alcune caratteristiche (come :func:`len`) possono "
"aumentare :exc:`OverflowError`."

#: ../Doc/library/stdtypes.rst:1291
msgid "Range examples::"
msgstr "Esempi di range::"

#: ../Doc/library/stdtypes.rst:1308
#, fuzzy
msgid ""
"Ranges implement all of the :ref:`common <typesseq-common>` sequence "
"operations except concatenation and repetition (due to the fact that range "
"objects can only represent sequences that follow a strict pattern and "
"repetition and concatenation will usually violate that pattern)."
msgstr ""
"I Ranges implementano tutte le <typesseq-common>operazioni di sequenza</"
"typesseq-common> :ref:`common `common ` ad <typesseq-common>eccezione della "
"concatenazione e della ripetizione (a causa del fatto che gli oggetti range "
"possono rappresentare solo sequenze che seguono uno schema rigoroso e la "
"ripetizione e la concatenazione di solito viola quello schema).</typesseq-"
"common>"

#: ../Doc/library/stdtypes.rst:1315
#, fuzzy
msgid ""
"The value of the *start* parameter (or ``0`` if the parameter was not "
"supplied)"
msgstr ""
"Il valore del parametro *start* (o ``0```` se il parametro non è stato "
"fornito)"

#: ../Doc/library/stdtypes.rst:1320
msgid "The value of the *stop* parameter"
msgstr "Il valore del parametro *stop*"

#: ../Doc/library/stdtypes.rst:1324
#, fuzzy
msgid ""
"The value of the *step* parameter (or ``1`` if the parameter was not "
"supplied)"
msgstr ""
"Il valore del parametro *step* (o ``1```` se il parametro non è stato "
"fornito)"

#: ../Doc/library/stdtypes.rst:1327
#, fuzzy
msgid ""
"The advantage of the :class:`range` type over a regular :class:`list` or :"
"class:`tuple` is that a :class:`range` object will always take the same "
"(small) amount of memory, no matter the size of the range it represents (as "
"it only stores the ``start``, ``stop`` and ``step`` values, calculating "
"individual items and subranges as needed)."
msgstr ""
"Il vantaggio del tipo :class:``range`` rispetto ad un normale oggetto :class:"
"`list` o :class:``tuple` è che un oggetto :class:``range` prenderà sempre la "
"stessa (piccola) quantità di memoria, indipendentemente dalle dimensioni "
"della gamma che rappresenta (in quanto memorizza solo i valori ``start````, "
"``stop`` e ``step```, calcolando i singoli elementi e sottogruppi secondo "
"necessità)."

#: ../Doc/library/stdtypes.rst:1333
#, fuzzy
msgid ""
"Range objects implement the :class:`collections.abc.Sequence` ABC, and "
"provide features such as containment tests, element index lookup, slicing "
"and support for negative indices (see :ref:`typesseq`):"
msgstr ""
"Gli oggetti range implementano il file :class:`collections.abc.abc.Sequence` "
"ABC, e forniscono caratteristiche come i test di contenimento, la ricerca "
"degli indici degli elementi, il slicing e il supporto per gli indici "
"negativi (vedi :ref:`typesseq`):"

#: ../Doc/library/stdtypes.rst:1353
#, fuzzy
msgid ""
"Testing range objects for equality with ``==`` and ``!=`` compares them as "
"sequences.  That is, two range objects are considered equal if they "
"represent the same sequence of values.  (Note that two range objects that "
"compare equal might have different :attr:`~range.start`, :attr:`~range.stop` "
"and :attr:`~range.step` attributes, for example ``range(0) == range(2, 1, "
"3)`` or ``range(0, 3, 2) == range(0, 4, 2)``.)"
msgstr ""
"Testando gli oggetti della gamma per l'uguaglianza con ``====```` e ``!=```` "
"li confronta come sequenze.  Cioè, due oggetti range sono considerati uguali "
"se rappresentano la stessa sequenza di valori.  (Si noti che due oggetti di "
"distanza che confrontano uguali potrebbero avere diversi attributi :attr:"
"`~range.start`, :attr:`~range.stop` e :attr:`~range.step`, per esempio "
"``range(0) == range(2, 1, 3)`` o ``range(0, 3, 2) == range(0, 4, 2)``.)"

#: ../Doc/library/stdtypes.rst:1360
#, fuzzy
msgid ""
"Implement the Sequence ABC. Support slicing and negative indices. Test :"
"class:`int` objects for membership in constant time instead of iterating "
"through all items."
msgstr ""
"Implementare la Sequenza ABC. Supporto affettatura e indici negativi. Test: "
"class:`int` oggetti per l'appartenenza in tempo costante invece di iterare "
"attraverso tutti gli elementi."

#: ../Doc/library/stdtypes.rst:1366
#, fuzzy
msgid ""
"Define '==' and '!=' to compare range objects based on the sequence of "
"values they define (instead of comparing based on object identity)."
msgstr ""
"Definire '===' e '!=' per confrontare gli oggetti range in base alla "
"sequenza di valori che definiscono (invece di confrontarli in base "
"all'identità dell'oggetto)."

#: ../Doc/library/stdtypes.rst:1371
#, fuzzy
msgid ""
"The :attr:`~range.start`, :attr:`~range.stop` and :attr:`~range.step` "
"attributes."
msgstr ""
"Il :attr:`~range.start`, :attr:`~range.stop` e :attr:`~range.step` attributi."

#: ../Doc/library/stdtypes.rst:1377
#, fuzzy
msgid ""
"The `linspace recipe <http://code.activestate.com/recipes/579000/>`_ shows "
"how to implement a lazy version of range suitable for floating point "
"applications."
msgstr ""
"La `ricetta linspace <http://code.activestate.com/recipes/579000/>`_ mostra "
"come implementare una versione pigra della gamma adatta per applicazioni in "
"virgola mobile."

#: ../Doc/library/stdtypes.rst:1389
#, fuzzy
msgid "Text Sequence Type --- :class:`str`"
msgstr "Tipo di sequenza di testi --- :class:`str`"

#: ../Doc/library/stdtypes.rst:1391
#, fuzzy
msgid ""
"Textual data in Python is handled with :class:`str` objects, or :dfn:"
"`strings`. Strings are immutable :ref:`sequences <typesseq>` of Unicode code "
"points.  String literals are written in a variety of ways:"
msgstr ""
"I dati testuali in Python sono gestiti con :class:`str` objects, oppure :dfn:"
"`strings`. Le stringhe sono immutabili :ref:`sequenze <typesseq>`di punti di "
"codice Unicode.  Le lettere letterali delle stringhe sono scritte in vari "
"modi:</typesseq>"

#: ../Doc/library/stdtypes.rst:1396
#, fuzzy
msgid "Single quotes: ``'allows embedded \"double\" quotes'``"
msgstr "Citazioni singole: ```'permette di inserire \"doppie\" virgolette ````"

#: ../Doc/library/stdtypes.rst:1397
#, fuzzy
msgid "Double quotes: ``\"allows embedded 'single' quotes\"``."
msgstr "Citazioni doppie: ```\"permette di inserire 'singole' virgolette\"``."

#: ../Doc/library/stdtypes.rst:1398
#, fuzzy
msgid ""
"Triple quoted: ``'''Three single quotes'''``, ``\"\"\"Three double quotes"
"\"\"\"``"
msgstr ""
"Triplo citato: ```''''Tre citazioni singole''''``, ```\"\"\"Tre citazioni "
"doppie\"\"\"\"```"

#: ../Doc/library/stdtypes.rst:1400
#, fuzzy
msgid ""
"Triple quoted strings may span multiple lines - all associated whitespace "
"will be included in the string literal."
msgstr ""
"Le stringhe triple citate possono estendersi su più righe - tutti gli spazi "
"bianchi associati saranno inclusi nella stringa letterale."

#: ../Doc/library/stdtypes.rst:1403
#, fuzzy
msgid ""
"String literals that are part of a single expression and have only "
"whitespace between them will be implicitly converted to a single string "
"literal. That is, ``(\"spam \" \"eggs\") == \"spam eggs\"``."
msgstr ""
"Le stringhe letterali che fanno parte di una singola espressione e hanno "
"solo spazi bianchi tra di loro saranno implicitamente convertite in una "
"singola stringa letterale. Cioè, ``(\"spam\" \"uova\") == \"uova di spam\"."

#: ../Doc/library/stdtypes.rst:1407
#, fuzzy
msgid ""
"See :ref:`strings` for more about the various forms of string literal, "
"including supported escape sequences, and the ``r`` (\"raw\") prefix that "
"disables most escape sequence processing."
msgstr ""
"Vedere :ref:``strings` per maggiori informazioni sulle varie forme di "
"stringa letterale, incluse le sequenze di escape supportate, e il prefisso "
"``r``` (\"raw\") che disabilita la maggior parte delle sequenze di escape "
"processing."

#: ../Doc/library/stdtypes.rst:1411
#, fuzzy
msgid ""
"Strings may also be created from other objects using the :class:`str` "
"constructor."
msgstr ""
"Le stringhe possono anche essere create da altri oggetti usando il "
"costruttore :class:`str`."

#: ../Doc/library/stdtypes.rst:1414
#, fuzzy
msgid ""
"Since there is no separate \"character\" type, indexing a string produces "
"strings of length 1. That is, for a non-empty string *s*, ``s[0] == s[0:1]``."
msgstr ""
"Poiché non esiste un tipo di \"carattere\" separato, l'indicizzazione di una "
"stringa produce stringhe di lunghezza 1. Cioè, per una stringa non vuota "
"*s*, ``s[0] === s[0:1]```."

#: ../Doc/library/stdtypes.rst:1420
#, fuzzy
msgid ""
"There is also no mutable string type, but :meth:`str.join` or :class:`io."
"StringIO` can be used to efficiently construct strings from multiple "
"fragments."
msgstr ""
"Non c'è anche nessun tipo di stringa mutevole, ma :meth:`str.join` o :class:"
"`io.StringIO` può essere usato per costruire in modo efficiente stringhe da "
"frammenti multipli."

#: ../Doc/library/stdtypes.rst:1424
#, fuzzy
msgid ""
"For backwards compatibility with the Python 2 series, the ``u`` prefix is "
"once again permitted on string literals. It has no effect on the meaning of "
"string literals and cannot be combined with the ``r`` prefix."
msgstr ""
"Per la retrocompatibilità con la serie Python 2, il prefisso ``u```` è "
"ancora una volta consentito sulle stringhe letterali. Non ha alcun effetto "
"sul significato delle lettere letterali delle stringhe e non può essere "
"combinato con il prefisso ``r````."

#: ../Doc/library/stdtypes.rst:1436
#, fuzzy
msgid ""
"Return a :ref:`string <textseq>` version of *object*.  If *object* is not "
"provided, returns the empty string.  Otherwise, the behavior of ``str()`` "
"depends on whether *encoding* or *errors* is given, as follows."
msgstr ""
"Restituire una <textseq>versione</textseq> :ref:`string <textseq>` di "
"*oggetto*.  Se *oggetto* non viene fornito, restituisce la stringa vuota.  "
"Altrimenti, il comportamento di ``str()``` dipende dal fatto che *codifica* "
"o *errore* sia dato, come segue.</textseq>"

#: ../Doc/library/stdtypes.rst:1440
#, fuzzy
msgid ""
"If neither *encoding* nor *errors* is given, ``str(object)`` returns :meth:"
"`object.__str__() <object.__str__>`, which is the \"informal\" or nicely "
"printable string representation of *object*.  For string objects, this is "
"the string itself.  If *object* does not have a :meth:`~object.__str__` "
"method, then :func:`str` falls back to returning :meth:`repr(object) <repr>`."
msgstr ""
"Se non vengono dati né *codifica* né *errore*, ``str(object)``` restituisce :"
"meth:`object.__str__() <object.__str__>`, che è la rappresentazione "
"\"informale\" o ben stampabile di *oggetto*.  Per gli oggetti stringa, "
"questa è la stringa stessa.  Se *oggetto* non ha un metodo :meth:`~object."
"__str__`, allora :func:`str` torna a restituire :meth:`repr(</object."
"__str__>object) <object.__str__><repr>`.</repr></object.__str__>"

#: ../Doc/library/stdtypes.rst:1451
#, fuzzy
msgid ""
"If at least one of *encoding* or *errors* is given, *object* should be a :"
"term:`bytes-like object` (e.g. :class:`bytes` or :class:`bytearray`).  In "
"this case, if *object* is a :class:`bytes` (or :class:`bytearray`) object, "
"then ``str(bytes, encoding, errors)`` is equivalent to :meth:`bytes."
"decode(encoding, errors) <bytes.decode>`.  Otherwise, the bytes object "
"underlying the buffer object is obtained before calling :meth:`bytes."
"decode`.  See :ref:`binaryseq` and :ref:`bufferobjects` for information on "
"buffer objects."
msgstr ""
"Se almeno uno dei *codifica* o *errore* è dato, *oggetto* dovrebbe essere "
"un :termine:`bytes-like object` (es. :class:`bytes` o :class:`byte` o :class:"
"`bytearray`).  In questo caso, se *oggetto* è un oggetto :class:`bytes` (o :"
"class:`bytearray`), allora ``str(bytes, encoding, errors)``` equivale a :"
"meth:`bytes.decode(encoding, errors) <bytes.decode>`.  Altrimenti, l'oggetto "
"byte sottostante l'oggetto buffer si ottiene prima di chiamare :meth:`bytes."
"decode`.  Vedere :ref:`binaryseq` e :ref:`bufferobjects` per informazioni "
"sugli oggetti buffer."

#: ../Doc/library/stdtypes.rst:1460
#, fuzzy
msgid ""
"Passing a :class:`bytes` object to :func:`str` without the *encoding* or "
"*errors* arguments falls under the first case of returning the informal "
"string representation (see also the :option:`-b` command-line option to "
"Python).  For example::"
msgstr ""
"Passare un oggetto :class:`bytes` a :func:`str` senza gli argomenti "
"*encoding* o *errors* rientra nel primo caso di restituzione della "
"rappresentazione informale delle stringhe (vedere anche l'opzione :option:`-"
"b` opzione da riga di comando a Python).  Per esempio::"

#: ../Doc/library/stdtypes.rst:1468
#, fuzzy
msgid ""
"For more information on the ``str`` class and its methods, see :ref:"
"`textseq` and the :ref:`string-methods` section below.  To output formatted "
"strings, see the :ref:`f-strings` and :ref:`formatstrings` sections.  In "
"addition, see the :ref:`stringservices` section."
msgstr ""
"Per ulteriori informazioni sulla classe ``str```` e i suoi metodi, vedere :"
"ref:`textseq` e la sezione :ref:`string-methods` sotto.  Per produrre "
"stringhe formattate, vedere le sezioni :ref:`f-strings` e :ref:"
"`formatstrings`.  Inoltre, vedere la sezione :ref:`stringservices`."

#: ../Doc/library/stdtypes.rst:1480
msgid "String Methods"
msgstr "Metodi string"

#: ../Doc/library/stdtypes.rst:1485
#, fuzzy
msgid ""
"Strings implement all of the :ref:`common <typesseq-common>` sequence "
"operations, along with the additional methods described below."
msgstr ""
"Le stringhe implementano tutte le <typesseq-common>operazioni di sequenza</"
"typesseq-common> :ref:`common `common `common <typesseq-common>`, insieme ai "
"metodi aggiuntivi descritti di seguito.</typesseq-common>"

#: ../Doc/library/stdtypes.rst:1488
#, fuzzy
msgid ""
"Strings also support two styles of string formatting, one providing a large "
"degree of flexibility and customization (see :meth:`str.format`, :ref:"
"`formatstrings` and :ref:`string-formatting`) and the other based on C "
"``printf`` style formatting that handles a narrower range of types and is "
"slightly harder to use correctly, but is often faster for the cases it can "
"handle (:ref:`old-string-formatting`)."
msgstr ""
"Le stringhe supportano anche due stili di formattazione delle stringhe, uno "
"che fornisce un ampio grado di flessibilità e personalizzazione (vedi :meth:"
"`str.format`, :ref:`formatstrings` e :ref:`string-formatting`) e l'altro "
"basato su C ``printf`` style formatting che gestisce una gamma più ristretta "
"di tipi ed è leggermente più difficile da usare correttamente, ma è spesso "
"più veloce per i casi che può gestire (:ref:`vecchio-string-formatting`)."

#: ../Doc/library/stdtypes.rst:1495
#, fuzzy
msgid ""
"The :ref:`textservices` section of the standard library covers a number of "
"other modules that provide various text related utilities (including regular "
"expression support in the :mod:`re` module)."
msgstr ""
"La sezione :ref:`textservices` della libreria standard copre una serie di "
"altri moduli che forniscono varie utilità relative al testo (incluso il "
"supporto per le espressioni regolari nel modulo :mod:`re`)."

#: ../Doc/library/stdtypes.rst:1501
#, fuzzy
msgid ""
"Return a copy of the string with its first character capitalized and the "
"rest lowercased."
msgstr ""
"Restituire una copia della stringa con il primo carattere in maiuscolo e il "
"resto in minuscolo."

#: ../Doc/library/stdtypes.rst:1507
#, fuzzy
msgid ""
"Return a casefolded copy of the string. Casefolded strings may be used for "
"caseless matching."
msgstr ""
"Restituire una copia ripiegata della stringa. Le corde piegate possono "
"essere utilizzate per l'abbinamento senza involucro."

#: ../Doc/library/stdtypes.rst:1510
#, fuzzy
msgid ""
"Casefolding is similar to lowercasing but more aggressive because it is "
"intended to remove all case distinctions in a string. For example, the "
"German lowercase letter ``'ß'`` is equivalent to ``\"ss\"``. Since it is "
"already lowercase, :meth:`lower` would do nothing to ``'ß'``; :meth:"
"`casefold` converts it to ``\"ss\"``."
msgstr ""
"La piegatura della custodia è simile alla custodia più bassa ma più "
"aggressiva, in quanto ha lo scopo di rimuovere tutte le distinzioni della "
"custodia in una corda. Per esempio, la lettera minuscola tedesca ``'ß'ß'``` "
"equivale a ``'s's```. Poiché è già minuscola, :meth:``basso` non farebbe "
"nulla per ``'ß'```; :meth:`casefold` lo converte in ``'s`'s```."

#: ../Doc/library/stdtypes.rst:1516
#, fuzzy
msgid ""
"The casefolding algorithm is described in section 3.13 of the Unicode "
"Standard."
msgstr ""
"L'algoritmo di casefolding è descritto nella sezione 3.13 dell'Unicode "
"Standard."

#: ../Doc/library/stdtypes.rst:1524
#, fuzzy
msgid ""
"Return centered in a string of length *width*. Padding is done using the "
"specified *fillchar* (default is an ASCII space). The original string is "
"returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"Ritorno centrato in una stringa di lunghezza *larghezza*. Il riempimento "
"viene effettuato utilizzando il *fillchar* specificato (il valore "
"predefinito è uno spazio ASCII). La stringa originale viene restituita se "
"*larghezza* è inferiore o uguale a ``len(s)``."

#: ../Doc/library/stdtypes.rst:1532
#, fuzzy
msgid ""
"Return the number of non-overlapping occurrences of substring *sub* in the "
"range [*start*, *end*].  Optional arguments *start* and *end* are "
"interpreted as in slice notation."
msgstr ""
"Restituisce il numero di occorrenze non sovrapponibili del substrato *sub* "
"nell'intervallo [*inizio*, *fine*].  Gli argomenti facoltativi *start* e "
"*end* sono interpretati come una notazione di fetta."

#: ../Doc/library/stdtypes.rst:1539
#, fuzzy
msgid ""
"Return an encoded version of the string as a bytes object. Default encoding "
"is ``'utf-8'``. *errors* may be given to set a different error handling "
"scheme. The default for *errors* is ``'strict'``, meaning that encoding "
"errors raise a :exc:`UnicodeError`. Other possible values are ``'ignore'``, "
"``'replace'``, ``'xmlcharrefreplace'``, ``'backslashreplace'`` and any other "
"name registered via :func:`codecs.register_error`, see section :ref:`error-"
"handlers`. For a list of possible encodings, see section :ref:`standard-"
"encodings`."
msgstr ""
"Restituisce una versione codificata della stringa come oggetto byte. La "
"codifica predefinita è ``'utf-8'````. *errori* possono essere forniti per "
"impostare un diverso schema di gestione degli errori. Il valore predefinito "
"per *errori* è ``'strict'````, il che significa che gli errori di codifica "
"generano un :exc:`UnicodeError`. Altri valori possibili sono ``'ignore'```, "
"``'replace'```, ``'xmlcharrefreplace'``, ``'backslashreplace'``` e qualsiasi "
"altro nome registrato tramite :func:`codecs.register_error`, vedere la "
"sezione :ref:`error-handlers`. Per un elenco delle codifiche possibili, "
"vedere la sezione :ref:`codifiche standard`."

#: ../Doc/library/stdtypes.rst:1548
msgid "Support for keyword arguments added."
msgstr "Aggiunto il supporto per i keyword argument."

#: ../Doc/library/stdtypes.rst:1554
#, fuzzy
msgid ""
"Return ``True`` if the string ends with the specified *suffix*, otherwise "
"return ``False``.  *suffix* can also be a tuple of suffixes to look for.  "
"With optional *start*, test beginning at that position.  With optional "
"*end*, stop comparing at that position."
msgstr ""
"Restituire ``True``` se la stringa termina con il *suffisso* specificato, "
"altrimenti restituire ``False```.  ** può anche essere una tupla di suffissi "
"da cercare.  Con *start* opzionale, il test inizia in quella posizione.  Con "
"*fine* opzionale, interrompere il confronto in quella posizione."

#: ../Doc/library/stdtypes.rst:1562
#, fuzzy
msgid ""
"Return a copy of the string where all tab characters are replaced by one or "
"more spaces, depending on the current column and the given tab size.  Tab "
"positions occur every *tabsize* characters (default is 8, giving tab "
"positions at columns 0, 8, 16 and so on).  To expand the string, the current "
"column is set to zero and the string is examined character by character.  If "
"the character is a tab (``\\t``), one or more space characters are inserted "
"in the result until the current column is equal to the next tab position. "
"(The tab character itself is not copied.)  If the character is a newline (``"
"\\n``) or return (``\\r``), it is copied and the current column is reset to "
"zero.  Any other character is copied unchanged and the current column is "
"incremented by one regardless of how the character is represented when "
"printed."
msgstr ""
"Restituisce una copia della stringa in cui tutti i caratteri delle schede "
"sono sostituiti da uno o più spazi, a seconda della colonna corrente e della "
"dimensione della scheda data.  Le posizioni delle schede si verificano ogni "
"*tabsize* caratteri (il valore predefinito è 8, dando posizioni delle schede "
"alle colonne 0, 8, 16 e così via).  Per espandere la stringa, la colonna "
"corrente è impostata a zero e la stringa viene esaminata carattere per "
"carattere.  Se il carattere è una scheda (``\\t```), uno o più caratteri di "
"spazio vengono inseriti nel risultato fino a quando la colonna corrente è "
"uguale alla posizione della scheda successiva. Se il carattere è una nuova "
"linea (``\\n```) o un ritorno (``\\r```), viene copiato e la colonna "
"corrente viene azzerata.  Qualsiasi altro carattere viene copiato invariato "
"e la colonna corrente viene incrementata di uno, indipendentemente da come "
"il carattere viene rappresentato quando viene stampato."

#: ../Doc/library/stdtypes.rst:1583
#, fuzzy
msgid ""
"Return the lowest index in the string where substring *sub* is found within "
"the slice ``s[start:end]``.  Optional arguments *start* and *end* are "
"interpreted as in slice notation.  Return ``-1`` if *sub* is not found."
msgstr ""
"Restituisce l'indice più basso della stringa in cui si trova la sottostringa "
"*sub* all'interno della fetta ``s[start:end]``.  Gli argomenti facoltativi "
"*start* e *end* sono interpretati come una notazione di fetta.  Restituire "
"``-1```` se *sub* non viene trovato."

#: ../Doc/library/stdtypes.rst:1589
#, fuzzy
msgid ""
"The :meth:`~str.find` method should be used only if you need to know the "
"position of *sub*.  To check if *sub* is a substring or not, use the :"
"keyword:`in` operator::"
msgstr ""
"Il metodo :meth:`~str.find` dovrebbe essere usato solo se avete bisogno di "
"conoscere la posizione di *sub*.  Per verificare se *sub* è un substrato o "
"meno, usare la parola chiave :keyword:`in` operator::"

#: ../Doc/library/stdtypes.rst:1599
#, fuzzy
msgid ""
"Perform a string formatting operation.  The string on which this method is "
"called can contain literal text or replacement fields delimited by braces "
"``{}``.  Each replacement field contains either the numeric index of a "
"positional argument, or the name of a keyword argument.  Returns a copy of "
"the string where each replacement field is replaced with the string value of "
"the corresponding argument."
msgstr ""
"Eseguire un'operazione di formattazione delle stringhe.  La stringa su cui "
"questo metodo è chiamato può contenere testo letterale o campi di "
"sostituzione delimitati da parentesi ``{{}````.  Ogni campo di sostituzione "
"contiene o l'indice numerico di un argomento di posizione, o il nome di un "
"argomento di parola chiave.  Restituisce una copia della stringa in cui ogni "
"campo di sostituzione viene sostituito con il valore della stringa "
"dell'argomento corrispondente."

#: ../Doc/library/stdtypes.rst:1609
#, fuzzy
msgid ""
"See :ref:`formatstrings` for a description of the various formatting options "
"that can be specified in format strings."
msgstr ""
"Vedere :ref:`formatstrings` per una descrizione delle varie opzioni di "
"formattazione che possono essere specificate nelle stringhe di formato."

#: ../Doc/library/stdtypes.rst:1613
#, fuzzy
msgid ""
"When formatting a number (:class:`int`, :class:`float`, :class:`complex`, :"
"class:`decimal.Decimal` and subclasses) with the ``n`` type (ex: ``'{:n}'."
"format(1234)``), the function temporarily sets the ``LC_CTYPE`` locale to "
"the ``LC_NUMERIC`` locale to decode ``decimal_point`` and ``thousands_sep`` "
"fields of :c:func:`localeconv` if they are non-ASCII or longer than 1 byte, "
"and the ``LC_NUMERIC`` locale is different than the ``LC_CTYPE`` locale.  "
"This temporary change affects other threads."
msgstr ""
"Quando si formatta un numero (:class:`int`, :class:`float`, :class:"
"`complex`, :class:`decimal.decimal` e sottoclassi) con il tipo ``n```` (es: "
"``'{:n}'.(1234)```), la funzione imposta temporaneamente il locale "
"``LC_CTYPE``` al locale ``LC_NUMERIC``` per decodificare i campi "
"``decimal_point``` e ``thousands_sep``` di :c:func:``localeconv`` se non "
"sono non-ASCII o più lunghi di 1 byte, e il locale ``LC_NUMERIC```` è "
"diverso dal locale ``LC_CTYPE```.  Questa modifica temporanea influisce su "
"altri thread."

#: ../Doc/library/stdtypes.rst:1622
#, fuzzy
msgid ""
"When formatting a number with the ``n`` type, the function sets temporarily "
"the ``LC_CTYPE`` locale to the ``LC_NUMERIC`` locale in some cases."
msgstr ""
"Quando si formatta un numero con il tipo ```n````, la funzione imposta "
"temporaneamente il locale ``LC_CTYPE``` al locale ``LC_NUMERIC``` locale in "
"alcuni casi."

#: ../Doc/library/stdtypes.rst:1630
#, fuzzy
msgid ""
"Similar to ``str.format(**mapping)``, except that ``mapping`` is used "
"directly and not copied to a :class:`dict`.  This is useful if for example "
"``mapping`` is a dict subclass:"
msgstr ""
"Simile a ``str.format(**mapping)```, tranne che ```mapping``` è usato "
"direttamente e non copiato in un :class:``dict`.  Questo è utile se ad "
"esempio ```mapping```` è una sottoclasse dict:"

#: ../Doc/library/stdtypes.rst:1646
#, fuzzy
msgid ""
"Like :meth:`~str.find`, but raise :exc:`ValueError` when the substring is "
"not found."
msgstr ""
"Come :meth:`~str.find`, ma alza :exc:`ValueError` quando il substrato non "
"viene trovato."

#: ../Doc/library/stdtypes.rst:1652
#, fuzzy
msgid ""
"Return true if all characters in the string are alphanumeric and there is at "
"least one character, false otherwise.  A character ``c`` is alphanumeric if "
"one of the following returns ``True``: ``c.isalpha()``, ``c.isdecimal()``, "
"``c.isdigit()``, or ``c.isnumeric()``."
msgstr ""
"Ritorna vero se tutti i caratteri della stringa sono alfanumerici e c'è "
"almeno un carattere, altrimenti falso.  Un carattere ``c```` è alfanumerico "
"se uno dei seguenti restituisce ``True```: ``c.isalpha()```, ``c."
"isdecimal()```, ``c.isdigit()```, o ``c.isdecimal()```."

#: ../Doc/library/stdtypes.rst:1660
#, fuzzy
msgid ""
"Return true if all characters in the string are alphabetic and there is at "
"least one character, false otherwise.  Alphabetic characters are those "
"characters defined in the Unicode character database as \"Letter\", i.e., "
"those with general category property being one of \"Lm\", \"Lt\", \"Lu\", "
"\"Ll\", or \"Lo\".  Note that this is different from the \"Alphabetic\" "
"property defined in the Unicode Standard."
msgstr ""
"Ritorna vero se tutti i caratteri della stringa sono in ordine alfabetico e "
"c'è almeno un carattere, altrimenti falso.  I caratteri alfabetici sono "
"quelli definiti nel database dei caratteri Unicode come \"Lettera\", cioè "
"quelli con proprietà di categoria generale di \"Lm\", \"Lt\", \"Lu\", \"Ll"
"\", \"Ll\" o \"Lo\".  Si noti che questa è diversa dalla proprietà "
"\"Alfabetico\" definita nello Standard Unicode."

#: ../Doc/library/stdtypes.rst:1669
#, fuzzy
msgid ""
"Return true if the string is empty or all characters in the string are "
"ASCII, false otherwise. ASCII characters have code points in the range U"
"+0000-U+007F."
msgstr ""
"Restituisce true se la stringa è vuota o tutti i caratteri della stringa "
"sono ASCII, altrimenti false. I caratteri ASCII hanno punti di codice "
"nell'intervallo U+000000-U+007F."

#: ../Doc/library/stdtypes.rst:1678
#, fuzzy
msgid ""
"Return true if all characters in the string are decimal characters and there "
"is at least one character, false otherwise. Decimal characters are those "
"that can be used to form numbers in base 10, e.g. U+0660, ARABIC-INDIC DIGIT "
"ZERO.  Formally a decimal character is a character in the Unicode General "
"Category \"Nd\"."
msgstr ""
"Ritorna vero se tutti i caratteri della stringa sono caratteri decimali e "
"c'è almeno un carattere, altrimenti falso. I caratteri decimali sono quelli "
"che possono essere utilizzati per formare numeri in base 10, ad esempio U"
"+0660, ARABIC-INDIC DIGIT ZERO.  Formalmente un carattere decimale è un "
"carattere della categoria generale Unicode \"Nd\"."

#: ../Doc/library/stdtypes.rst:1688
#, fuzzy
msgid ""
"Return true if all characters in the string are digits and there is at least "
"one character, false otherwise.  Digits include decimal characters and "
"digits that need special handling, such as the compatibility superscript "
"digits. This covers digits which cannot be used to form numbers in base 10, "
"like the Kharosthi numbers.  Formally, a digit is a character that has the "
"property value Numeric_Type=Digit or Numeric_Type=Decimal."
msgstr ""
"Ritorna vero se tutti i caratteri della stringa sono cifre e c'è almeno un "
"carattere, altrimenti falso.  Le cifre comprendono i caratteri decimali e le "
"cifre che richiedono una gestione speciale, come le cifre superscript di "
"compatibilità. Si tratta di cifre che non possono essere utilizzate per "
"formare numeri in base 10, come i numeri Kharosthi.  Formalmente, una cifra "
"è un carattere che ha il valore della proprietà Numeric_Type=Cifra o "
"Numeric_Type=Decimale."

#: ../Doc/library/stdtypes.rst:1698
#, fuzzy
msgid ""
"Return true if the string is a valid identifier according to the language "
"definition, section :ref:`identifiers`."
msgstr ""
"Restituire vero se la stringa è un identificatore valido secondo la "
"definizione della lingua, sezione :ref:`identifiers`."

#: ../Doc/library/stdtypes.rst:1701
#, fuzzy
msgid ""
"Use :func:`keyword.iskeyword` to test for reserved identifiers such as :"
"keyword:`def` and :keyword:`class`."
msgstr ""
"Usa :func:`keyword.iskeyword.iskeyword` per testare gli identificatori "
"riservati come :keyword:`def` e :keyword:`class`."

#: ../Doc/library/stdtypes.rst:1706
#, fuzzy
msgid ""
"Return true if all cased characters [4]_ in the string are lowercase and "
"there is at least one cased character, false otherwise."
msgstr ""
"Ritorna vero se tutti i caratteri cased [4]_ nella stringa sono minuscoli e "
"c'è almeno un carattere cased, altrimenti falso."

#: ../Doc/library/stdtypes.rst:1712
#, fuzzy
msgid ""
"Return true if all characters in the string are numeric characters, and "
"there is at least one character, false otherwise. Numeric characters include "
"digit characters, and all characters that have the Unicode numeric value "
"property, e.g. U+2155, VULGAR FRACTION ONE FIFTH.  Formally, numeric "
"characters are those with the property value Numeric_Type=Digit, "
"Numeric_Type=Decimal or Numeric_Type=Numeric."
msgstr ""
"Ritorna vero se tutti i caratteri della stringa sono caratteri numerici, e "
"c'è almeno un carattere, altrimenti falso. I caratteri numerici includono "
"caratteri numerici e tutti i caratteri che hanno la proprietà di valore "
"numerico Unicode, ad esempio U+2155, VULGAR FRACTION ONE FIFTH.  "
"Formalmente, i caratteri numerici sono quelli con il valore della proprietà "
"Numeric_Type=Cifra, Numeric_Type=Decimale o Numeric_Type=Numerico."

#: ../Doc/library/stdtypes.rst:1722
#, fuzzy
msgid ""
"Return true if all characters in the string are printable or the string is "
"empty, false otherwise.  Nonprintable characters are those characters "
"defined in the Unicode character database as \"Other\" or \"Separator\", "
"excepting the ASCII space (0x20) which is considered printable.  (Note that "
"printable characters in this context are those which should not be escaped "
"when :func:`repr` is invoked on a string.  It has no bearing on the handling "
"of strings written to :data:`sys.stdout` or :data:`sys.stderr`.)"
msgstr ""
"Restituisce true se tutti i caratteri della stringa sono stampabili o se la "
"stringa è vuota, altrimenti false.  I caratteri non stampabili sono quelli "
"definiti nel database dei caratteri Unicode come \"Altro\" o \"Separatore\", "
"ad eccezione dello spazio ASCII (0x20) che è considerato stampabile.  (Si "
"noti che i caratteri stampabili in questo contesto sono quelli che non "
"dovrebbero essere esclusi quando :func:`repr` è invocato su una stringa.  "
"Non ha alcuna influenza sulla gestione delle stringhe scritte in :data:`sys."
"stdout` o :data:`sys.stderr`.)"

#: ../Doc/library/stdtypes.rst:1733
#, fuzzy
msgid ""
"Return true if there are only whitespace characters in the string and there "
"is at least one character, false otherwise.  Whitespace characters  are "
"those characters defined in the Unicode character database as \"Other\" or "
"\"Separator\" and those with bidirectional property being one of \"WS\", \"B"
"\", or \"S\"."
msgstr ""
"Ritorna vero se ci sono solo caratteri dello spazio bianco nella stringa e "
"c'è almeno un carattere, altrimenti falso.  I caratteri degli spazi bianchi "
"sono quelli definiti nel database dei caratteri Unicode come \"Altro\" o "
"\"Separatore\" e quelli con proprietà bidirezionali di \"WS\", \"B\" o \"S\"."

#: ../Doc/library/stdtypes.rst:1740
#, fuzzy
msgid ""
"Return true if the string is a titlecased string and there is at least one "
"character, for example uppercase characters may only follow uncased "
"characters and lowercase characters only cased ones.  Return false otherwise."
msgstr ""
"Ritorna vero se la stringa è una stringa con titolo e c'è almeno un "
"carattere, ad esempio i caratteri maiuscoli possono seguire solo i caratteri "
"non maiuscoli e i caratteri minuscoli solo quelli cased.  Altrimenti, "
"restituisci falso."

#: ../Doc/library/stdtypes.rst:1747
#, fuzzy
msgid ""
"Return true if all cased characters [4]_ in the string are uppercase and "
"there is at least one cased character, false otherwise."
msgstr ""
"Ritorna vero se tutti i caratteri cased [4]_ nella stringa sono maiuscoli e "
"c'è almeno un carattere cased, altrimenti falso."

#: ../Doc/library/stdtypes.rst:1753
#, fuzzy
msgid ""
"Return a string which is the concatenation of the strings in *iterable*. A :"
"exc:`TypeError` will be raised if there are any non-string values in "
"*iterable*, including :class:`bytes` objects.  The separator between "
"elements is the string providing this method."
msgstr ""
"Restituisce una stringa che è la concatenazione delle stringhe in "
"*iterable*. R:exc:`TypeError` sarà sollevato se ci sono valori non stringhe "
"in *iterable*, inclusi gli oggetti :class:`bytes`.  Il separatore tra gli "
"elementi è la stringa che fornisce questo metodo."

#: ../Doc/library/stdtypes.rst:1761
#, fuzzy
msgid ""
"Return the string left justified in a string of length *width*. Padding is "
"done using the specified *fillchar* (default is an ASCII space). The "
"original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"Restituire la stringa sinistra giustificata in una stringa di lunghezza "
"*larghezza*. Il riempimento viene effettuato utilizzando il *fillchar* "
"specificato (il valore predefinito è uno spazio ASCII). La stringa originale "
"viene restituita se *larghezza* è inferiore o uguale a ``len(s)``."

#: ../Doc/library/stdtypes.rst:1768
#, fuzzy
msgid ""
"Return a copy of the string with all the cased characters [4]_ converted to "
"lowercase."
msgstr ""
"Riportare una copia della stringa con tutti i caratteri cased [4]_ "
"convertiti in minuscolo."

#: ../Doc/library/stdtypes.rst:1771
#, fuzzy
msgid ""
"The lowercasing algorithm used is described in section 3.13 of the Unicode "
"Standard."
msgstr ""
"L'algoritmo di \"lowercasing\" utilizzato è descritto nella sezione 3.13 "
"dello Standard Unicode."

#: ../Doc/library/stdtypes.rst:1777
#, fuzzy
msgid ""
"Return a copy of the string with leading characters removed.  The *chars* "
"argument is a string specifying the set of characters to be removed.  If "
"omitted or ``None``, the *chars* argument defaults to removing whitespace.  "
"The *chars* argument is not a prefix; rather, all combinations of its values "
"are stripped::"
msgstr ""
"Restituisce una copia della stringa con i caratteri iniziali rimossi.  "
"L'argomento *chars* è una stringa che specifica l'insieme di caratteri da "
"rimuovere.  Se omesso o \"Nessuno\", l'argomento *cars* predefinito è la "
"rimozione dello spazio bianco.  L'argomento *chars* non è un prefisso; "
"piuttosto, tutte le combinazioni dei suoi valori sono eliminate::"

#: ../Doc/library/stdtypes.rst:1790
#, fuzzy
msgid ""
"This static method returns a translation table usable for :meth:`str."
"translate`."
msgstr ""
"Questo metodo statico restituisce una tabella di traduzione utilizzabile "
"per :meth:`str.translate`."

#: ../Doc/library/stdtypes.rst:1792
#, fuzzy
msgid ""
"If there is only one argument, it must be a dictionary mapping Unicode "
"ordinals (integers) or characters (strings of length 1) to Unicode ordinals, "
"strings (of arbitrary lengths) or ``None``.  Character keys will then be "
"converted to ordinals."
msgstr ""
"Se c'è un solo argomento, deve essere un dizionario che mappatura ordinali "
"Unicode (interi) o caratteri (stringhe di lunghezza 1) in ordinali Unicode, "
"stringhe (di lunghezza arbitraria) o ```Nessuno````.  I tasti dei caratteri "
"saranno poi convertiti in ordinali."

#: ../Doc/library/stdtypes.rst:1797
#, fuzzy
msgid ""
"If there are two arguments, they must be strings of equal length, and in the "
"resulting dictionary, each character in x will be mapped to the character at "
"the same position in y.  If there is a third argument, it must be a string, "
"whose characters will be mapped to ``None`` in the result."
msgstr ""
"Se ci sono due argomenti, devono essere stringhe di uguale lunghezza, e nel "
"dizionario risultante, ogni carattere in x sarà mappato al carattere nella "
"stessa posizione in y. Se c'è un terzo argomento, deve essere una stringa, i "
"cui caratteri saranno mappati a ```Nessuno```` nel risultato."

#: ../Doc/library/stdtypes.rst:1805
#, fuzzy
msgid ""
"Split the string at the first occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself, and the part "
"after the separator.  If the separator is not found, return a 3-tuple "
"containing the string itself, followed by two empty strings."
msgstr ""
"Dividere la stringa alla prima occorrenza di *sep*, e restituire una 3-"
"tuplice contenente la parte prima del separatore, il separatore stesso, e la "
"parte dopo il separatore.  Se il separatore non viene trovato, restituire "
"una 3-tuple contenente la stringa stessa, seguita da due stringhe vuote."

#: ../Doc/library/stdtypes.rst:1813
#, fuzzy
msgid ""
"Return a copy of the string with all occurrences of substring *old* replaced "
"by *new*.  If the optional argument *count* is given, only the first *count* "
"occurrences are replaced."
msgstr ""
"Restituire una copia della stringa con tutte le occorrenze della "
"sottostringa *vecchio* sostituito da *nuovo*.  Se viene fornito l'argomento "
"opzionale *contare*, vengono sostituite solo le prime occorrenze *contare*."

#: ../Doc/library/stdtypes.rst:1820
#, fuzzy
msgid ""
"Return the highest index in the string where substring *sub* is found, such "
"that *sub* is contained within ``s[start:end]``.  Optional arguments *start* "
"and *end* are interpreted as in slice notation.  Return ``-1`` on failure."
msgstr ""
"Restituisce l'indice più alto nella stringa in cui si trova la sottostringa "
"*sub*, in modo tale che *sub* sia contenuto all'interno di ``s[start:"
"end]``.  Gli argomenti facoltativi *start* e *end* sono interpretati come "
"una notazione di fetta.  Ritorno ``-1```` in caso di guasto."

#: ../Doc/library/stdtypes.rst:1827
#, fuzzy
msgid ""
"Like :meth:`rfind` but raises :exc:`ValueError` when the substring *sub* is "
"not found."
msgstr ""
"Come :meth:`rfind` ma aumenta :exc:`ValueError` quando il substrato *sub* "
"non viene trovato."

#: ../Doc/library/stdtypes.rst:1833
#, fuzzy
msgid ""
"Return the string right justified in a string of length *width*. Padding is "
"done using the specified *fillchar* (default is an ASCII space). The "
"original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"Riportare la stringa a destra giustificata in una stringa di lunghezza "
"*larghezza*. Il riempimento viene effettuato utilizzando il *fillchar* "
"specificato (il valore predefinito è uno spazio ASCII). La stringa originale "
"viene restituita se *larghezza* è inferiore o uguale a ``len(s)``."

#: ../Doc/library/stdtypes.rst:1840
#, fuzzy
msgid ""
"Split the string at the last occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself, and the part "
"after the separator.  If the separator is not found, return a 3-tuple "
"containing two empty strings, followed by the string itself."
msgstr ""
"Dividere la stringa all'ultima occorrenza di *sep*, e restituire una 3-"
"tuplice contenente la parte prima del separatore, il separatore stesso, e la "
"parte dopo il separatore.  Se il separatore non viene trovato, restituire "
"una 3-tuple contenente due stringhe vuote, seguite dalla stringa stessa."

#: ../Doc/library/stdtypes.rst:1848
#, fuzzy
msgid ""
"Return a list of the words in the string, using *sep* as the delimiter "
"string. If *maxsplit* is given, at most *maxsplit* splits are done, the "
"*rightmost* ones.  If *sep* is not specified or ``None``, any whitespace "
"string is a separator.  Except for splitting from the right, :meth:`rsplit` "
"behaves like :meth:`split` which is described in detail below."
msgstr ""
"Restituisce un elenco delle parole nella stringa, usando *sep* come stringa "
"delimitatrice. Se *maxsplit* è dato, al massimo *maxsplit* spaccate, le "
"spaccate più giuste.  Se *sep* non è specificato o ```Nessuno```, qualsiasi "
"stringa di spazi bianchi è un separatore.  Ad eccezione della separazione da "
"destra, :meth:`rsplit` si comporta come :meth:`split` che è descritto in "
"dettaglio qui sotto."

#: ../Doc/library/stdtypes.rst:1857
#, fuzzy
msgid ""
"Return a copy of the string with trailing characters removed.  The *chars* "
"argument is a string specifying the set of characters to be removed.  If "
"omitted or ``None``, the *chars* argument defaults to removing whitespace.  "
"The *chars* argument is not a suffix; rather, all combinations of its values "
"are stripped::"
msgstr ""
"Restituisce una copia della stringa con i caratteri di trascinamento "
"rimossi.  L'argomento *chars* è una stringa che specifica l'insieme di "
"caratteri da rimuovere.  Se omesso o \"Nessuno\", l'argomento *cars* "
"predefinito è la rimozione dello spazio bianco.  L'argomento *chars* non è "
"un suffisso; piuttosto, tutte le combinazioni dei suoi valori sono "
"eliminate::"

#: ../Doc/library/stdtypes.rst:1870
#, fuzzy
msgid ""
"Return a list of the words in the string, using *sep* as the delimiter "
"string.  If *maxsplit* is given, at most *maxsplit* splits are done (thus, "
"the list will have at most ``maxsplit+1`` elements).  If *maxsplit* is not "
"specified or ``-1``, then there is no limit on the number of splits (all "
"possible splits are made)."
msgstr ""
"Restituisce un elenco delle parole nella stringa, usando *sep* come stringa "
"delimitatrice.  Se *maxsplit* è dato, al massimo *maxsplit* sono fatte le "
"suddivisioni (quindi, l'elenco avrà al massimo ``maxsplit+1``` elementi).  "
"Se *maxsplit* non è specificato o ``-1````, allora non c'è limite al numero "
"di spaccature (tutte le spaccature possibili sono fatte)."

#: ../Doc/library/stdtypes.rst:1876
#, fuzzy
msgid ""
"If *sep* is given, consecutive delimiters are not grouped together and are "
"deemed to delimit empty strings (for example, ``'1,,2'.split(',')`` returns "
"``['1', '', '2']``).  The *sep* argument may consist of multiple characters "
"(for example, ``'1<>2<>3'.split('<>')`` returns ``['1', '2', '3']``). "
"Splitting an empty string with a specified separator returns ``['']``."
msgstr ""
"Se *sep* è dato, i delimitatori consecutivi non sono raggruppati insieme e "
"si ritiene che delimitino stringhe vuote (per esempio, ``'1,,2'."
"split(',',')``` restituisce ``['1'', ''', '2']``).  L'argomento *sep* può "
"consistere di caratteri multipli (per esempio, ```'1<>2<>2<>3'."
"split('<>'')``` restituisce ``['1', '2', '3']``). Dividendo una stringa "
"vuota con un separatore specificato si ottiene ``['''']``."

#: ../Doc/library/stdtypes.rst:1882 ../Doc/library/stdtypes.rst:1898
#: ../Doc/library/stdtypes.rst:1950 ../Doc/library/stdtypes.rst:2018
#: ../Doc/library/stdtypes.rst:2082 ../Doc/library/stdtypes.rst:2843
#: ../Doc/library/stdtypes.rst:2859 ../Doc/library/stdtypes.rst:2950
#: ../Doc/library/stdtypes.rst:2966 ../Doc/library/stdtypes.rst:2991
#: ../Doc/library/stdtypes.rst:3005 ../Doc/library/stdtypes.rst:3033
#: ../Doc/library/stdtypes.rst:3047 ../Doc/library/stdtypes.rst:3065
#: ../Doc/library/stdtypes.rst:3092 ../Doc/library/stdtypes.rst:3115
#: ../Doc/library/stdtypes.rst:3142 ../Doc/library/stdtypes.rst:3184
#: ../Doc/library/stdtypes.rst:3208
msgid "For example::"
msgstr "Per esempio::"

#: ../Doc/library/stdtypes.rst:1891
#, fuzzy
msgid ""
"If *sep* is not specified or is ``None``, a different splitting algorithm is "
"applied: runs of consecutive whitespace are regarded as a single separator, "
"and the result will contain no empty strings at the start or end if the "
"string has leading or trailing whitespace.  Consequently, splitting an empty "
"string or a string consisting of just whitespace with a ``None`` separator "
"returns ``[]``."
msgstr ""
"Se *sep* non è specificato o non è ``Nessuno```, viene applicato un diverso "
"algoritmo di divisione: le corse di spazi bianchi consecutivi sono "
"considerate come un singolo separatore, e il risultato non conterrà stringhe "
"vuote all'inizio o alla fine se la stringa ha spazi bianchi iniziali o "
"finali.  Di conseguenza, dividendo una stringa vuota o una stringa composta "
"da soli spazi bianchi con un separatore ```None````` restituisce ``[]```."

#: ../Doc/library/stdtypes.rst:1913
#, fuzzy
msgid ""
"Return a list of the lines in the string, breaking at line boundaries.  Line "
"breaks are not included in the resulting list unless *keepends* is given and "
"true."
msgstr ""
"Restituisce un elenco delle linee della stringa, che si rompe ai confini "
"della linea.  Le interruzioni di riga non sono incluse nell'elenco "
"risultante a meno che non sia indicato e vero."

#: ../Doc/library/stdtypes.rst:1917
#, fuzzy
msgid ""
"This method splits on the following line boundaries.  In particular, the "
"boundaries are a superset of :term:`universal newlines`."
msgstr ""
"Questo metodo si divide sui seguenti confini di linea.  In particolare, i "
"confini sono un superset di :termine:`universal newlines`."

#: ../Doc/library/stdtypes.rst:1921
msgid "Representation"
msgstr "Rappresentazione"

#: ../Doc/library/stdtypes.rst:1921
msgid "Description"
msgstr "Descrizione"

#: ../Doc/library/stdtypes.rst:1923
msgid "``\\n``"
msgstr "``\\n``"

#: ../Doc/library/stdtypes.rst:1923
#, fuzzy
msgid "Line Feed"
msgstr "Avanzamento di linea"

#: ../Doc/library/stdtypes.rst:1925
msgid "``\\r``"
msgstr "``\\r``"

#: ../Doc/library/stdtypes.rst:1925
#, fuzzy
msgid "Carriage Return"
msgstr "Ritorno a capo"

#: ../Doc/library/stdtypes.rst:1927
msgid "``\\r\\n``"
msgstr "``\\r\\n``"

#: ../Doc/library/stdtypes.rst:1927
#, fuzzy
msgid "Carriage Return + Line Feed"
msgstr "Ritorno a capo + avanzamento di linea"

#: ../Doc/library/stdtypes.rst:1929
msgid "``\\v`` or ``\\x0b``"
msgstr "``\\v`` o ``\\x0b``"

#: ../Doc/library/stdtypes.rst:1929
#, fuzzy
msgid "Line Tabulation"
msgstr "Tabulazione di linea"

#: ../Doc/library/stdtypes.rst:1931
msgid "``\\f`` or ``\\x0c``"
msgstr "``\\f`` o ``\\x0c``"

#: ../Doc/library/stdtypes.rst:1931
#, fuzzy
msgid "Form Feed"
msgstr "Mangimi"

#: ../Doc/library/stdtypes.rst:1933
msgid "``\\x1c``"
msgstr "``\\x1c``"

#: ../Doc/library/stdtypes.rst:1933
#, fuzzy
msgid "File Separator"
msgstr "Separatore di file"

#: ../Doc/library/stdtypes.rst:1935
msgid "``\\x1d``"
msgstr "``\\x1d``"

#: ../Doc/library/stdtypes.rst:1935
#, fuzzy
msgid "Group Separator"
msgstr "Separatore di gruppo"

#: ../Doc/library/stdtypes.rst:1937
msgid "``\\x1e``"
msgstr "``\\x1e``"

#: ../Doc/library/stdtypes.rst:1937
#, fuzzy
msgid "Record Separator"
msgstr "Separatore di record"

#: ../Doc/library/stdtypes.rst:1939
msgid "``\\x85``"
msgstr "``\\x85``"

#: ../Doc/library/stdtypes.rst:1939
msgid "Next Line (C1 Control Code)"
msgstr "Riga successiva (codice di controllo C1)"

#: ../Doc/library/stdtypes.rst:1941
msgid "``\\u2028``"
msgstr "``\\u2028``"

#: ../Doc/library/stdtypes.rst:1941
#, fuzzy
msgid "Line Separator"
msgstr "Separatore di linea"

#: ../Doc/library/stdtypes.rst:1943
msgid "``\\u2029``"
msgstr "``\\u2029``"

#: ../Doc/library/stdtypes.rst:1943
msgid "Paragraph Separator"
msgstr "Separatore di Paragrafo"

#: ../Doc/library/stdtypes.rst:1948
#, fuzzy
msgid "``\\v`` and ``\\f`` added to list of line boundaries."
msgstr "````\\v``` e ```\\f``` aggiunto all'elenco dei confini delle linee."

#: ../Doc/library/stdtypes.rst:1957
#, fuzzy
msgid ""
"Unlike :meth:`~str.split` when a delimiter string *sep* is given, this "
"method returns an empty list for the empty string, and a terminal line break "
"does not result in an extra line::"
msgstr ""
"A differenza di :meth:`~str.split` quando viene data una stringa "
"delimitatrice *sep*, questo metodo restituisce una lista vuota per la "
"stringa vuota, e un'interruzione di linea terminale non si traduce in una "
"riga extra::"

#: ../Doc/library/stdtypes.rst:1966
#, fuzzy
msgid "For comparison, ``split('\\n')`` gives::"
msgstr "Per confronto, ```split('\\n'')`` dà::"

#: ../Doc/library/stdtypes.rst:1976
#, fuzzy
msgid ""
"Return ``True`` if string starts with the *prefix*, otherwise return "
"``False``. *prefix* can also be a tuple of prefixes to look for.  With "
"optional *start*, test string beginning at that position.  With optional "
"*end*, stop comparing string at that position."
msgstr ""
"Restituire ``True``` se la stringa inizia con il *prefisso*, altrimenti "
"restituire ``False```. *prefisso* può anche essere una tupla di prefissi da "
"cercare.  Con *start* opzionale, la stringa di prova inizia in quella "
"posizione.  Con *fine* opzionale, smettere di confrontare la stringa in "
"quella posizione."

#: ../Doc/library/stdtypes.rst:1984
#, fuzzy
msgid ""
"Return a copy of the string with the leading and trailing characters "
"removed. The *chars* argument is a string specifying the set of characters "
"to be removed. If omitted or ``None``, the *chars* argument defaults to "
"removing whitespace. The *chars* argument is not a prefix or suffix; rather, "
"all combinations of its values are stripped::"
msgstr ""
"Restituire una copia della stringa con i caratteri iniziali e finali "
"rimossi. L'argomento *chars* è una stringa che specifica l'insieme di "
"caratteri da rimuovere. Se omesso o \"Nessuno\", l'argomento *cars* "
"predefinito è la rimozione dello spazio bianco. L'argomento *chars* non è un "
"prefisso o un suffisso; piuttosto, tutte le combinazioni dei suoi valori "
"sono eliminate::"

#: ../Doc/library/stdtypes.rst:1995
#, fuzzy
msgid ""
"The outermost leading and trailing *chars* argument values are stripped from "
"the string. Characters are removed from the leading end until reaching a "
"string character that is not contained in the set of characters in *chars*. "
"A similar action takes place on the trailing end. For example::"
msgstr ""
"I valori più esterni dell'argomento *carri* in entrata e in uscita vengono "
"rimossi dalla stringa. I caratteri vengono rimossi dall'estremità iniziale "
"fino a raggiungere un carattere di stringa che non è contenuto nell'insieme "
"di caratteri in *cars*. Un'azione simile si svolge sul lato finale. Per "
"esempio::"

#: ../Doc/library/stdtypes.rst:2008
#, fuzzy
msgid ""
"Return a copy of the string with uppercase characters converted to lowercase "
"and vice versa. Note that it is not necessarily true that ``s.swapcase()."
"swapcase() == s``."
msgstr ""
"Restituisce una copia della stringa con caratteri maiuscoli convertiti in "
"minuscole e viceversa. Si noti che non è necessariamente vero che ``s."
"swapcase().swapcase().swapcase() === s````."

#: ../Doc/library/stdtypes.rst:2015
#, fuzzy
msgid ""
"Return a titlecased version of the string where words start with an "
"uppercase character and the remaining characters are lowercase."
msgstr ""
"Restituisce una versione per titolo della stringa in cui le parole iniziano "
"con un carattere maiuscolo e i caratteri rimanenti sono in minuscolo."

#: ../Doc/library/stdtypes.rst:2023 ../Doc/library/stdtypes.rst:3152
#, fuzzy
msgid ""
"The algorithm uses a simple language-independent definition of a word as "
"groups of consecutive letters.  The definition works in many contexts but it "
"means that apostrophes in contractions and possessives form word boundaries, "
"which may not be the desired result::"
msgstr ""
"L'algoritmo utilizza una semplice definizione, indipendente dalla lingua, di "
"una parola come gruppi di lettere consecutive.  La definizione funziona in "
"molti contesti, ma significa che gli apostrofi in contrazioni e possessivi "
"formano i confini delle parole, il che potrebbe non essere il risultato "
"desiderato::"

#: ../Doc/library/stdtypes.rst:2031 ../Doc/library/stdtypes.rst:3160
#, fuzzy
msgid ""
"A workaround for apostrophes can be constructed using regular expressions::"
msgstr ""
"Una soluzione per gli apostrofi può essere costruita utilizzando espressioni "
"regolari::"

#: ../Doc/library/stdtypes.rst:2046
#, fuzzy
msgid ""
"Return a copy of the string in which each character has been mapped through "
"the given translation table.  The table must be an object that implements "
"indexing via :meth:`__getitem__`, typically a :term:`mapping` or :term:"
"`sequence`.  When indexed by a Unicode ordinal (an integer), the table "
"object can do any of the following: return a Unicode ordinal or a string, to "
"map the character to one or more other characters; return ``None``, to "
"delete the character from the return string; or raise a :exc:`LookupError` "
"exception, to map the character to itself."
msgstr ""
"Restituisce una copia della stringa in cui ogni carattere è stato mappato "
"attraverso la tabella di traduzione data.  La tabella deve essere un oggetto "
"che implementa l'indicizzazione tramite :meth:`__getitem__`, tipicamente un "
"termine :`mapping` o :termine:`sequence`.  Quando indicizzato da un ordinale "
"Unicode (un numero intero), l'oggetto tabella può fare una delle seguenti "
"operazioni: restituire un ordinale Unicode o una stringa, per mappare il "
"carattere ad uno o più caratteri; restituire ``Nessuno```, per cancellare il "
"carattere dalla stringa di ritorno; o sollevare un'ecc:`LookupError` "
"exception, per mappare il carattere a se stesso."

#: ../Doc/library/stdtypes.rst:2055
#, fuzzy
msgid ""
"You can use :meth:`str.maketrans` to create a translation map from character-"
"to-character mappings in different formats."
msgstr ""
"È possibile utilizzare :meth:`str.maketrans` per creare una mappa di "
"traduzione da mappature da carattere a carattere in diversi formati."

#: ../Doc/library/stdtypes.rst:2058
#, fuzzy
msgid ""
"See also the :mod:`codecs` module for a more flexible approach to custom "
"character mappings."
msgstr ""
"Vedere anche il modulo :mod:`codecs` per un approccio più flessibile alla "
"mappatura dei caratteri personalizzati."

#: ../Doc/library/stdtypes.rst:2064
#, fuzzy
msgid ""
"Return a copy of the string with all the cased characters [4]_ converted to "
"uppercase.  Note that ``s.upper().isupper()`` might be ``False`` if ``s`` "
"contains uncased characters or if the Unicode category of the resulting "
"character(s) is not \"Lu\" (Letter, uppercase), but e.g. \"Lt\" (Letter, "
"titlecase)."
msgstr ""
"Riportare una copia della stringa con tutti i caratteri cased [4]_ "
"convertiti in maiuscolo.  Si noti che ``s.upper().isupper()``` potrebbe "
"essere ``False``` se ``s's` contiene caratteri non incassati o se la "
"categoria Unicode dei caratteri risultanti non è \"Lu\" (lettera maiuscola), "
"ma ad esempio \"Lt\" (lettera, maiuscola)."

#: ../Doc/library/stdtypes.rst:2070
#, fuzzy
msgid ""
"The uppercasing algorithm used is described in section 3.13 of the Unicode "
"Standard."
msgstr ""
"L'algoritmo uppercasing utilizzato è descritto nella sezione 3.13 dello "
"Standard Unicode."

#: ../Doc/library/stdtypes.rst:2076
#, fuzzy
msgid ""
"Return a copy of the string left filled with ASCII ``'0'`` digits to make a "
"string of length *width*. A leading sign prefix (``'+'``/``'-'``) is handled "
"by inserting the padding *after* the sign character rather than before. The "
"original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"Restituire una copia della stringa sinistra riempita con ASCII ``'0'0'```` "
"cifre per fare una stringa di lunghezza *larghezza*. Un prefisso del segno "
"principale (``'+'+'````/`````'-'-'```) è gestito inserendo l'imbottitura "
"*dopo* il carattere del segno piuttosto che prima. La stringa originale "
"viene restituita se *larghezza* è inferiore o uguale a ``len(s)``."

#: ../Doc/library/stdtypes.rst:2094
#, fuzzy
msgid "``printf``-style String Formatting"
msgstr ""
"Formattazione delle stringhe in stile ``printf``-style String Formatting"

#: ../Doc/library/stdtypes.rst:2107
#, fuzzy
msgid ""
"The formatting operations described here exhibit a variety of quirks that "
"lead to a number of common errors (such as failing to display tuples and "
"dictionaries correctly).  Using the newer :ref:`formatted string literals <f-"
"strings>`, the :meth:`str.format` interface, or :ref:`template strings "
"<template-strings>` may help avoid these errors.  Each of these alternatives "
"provides their own trade-offs and benefits of simplicity, flexibility, and/"
"or extensibility."
msgstr ""
"Le operazioni di formattazione qui descritte mostrano una varietà di "
"stranezze che portano ad una serie di errori comuni (come la mancata "
"visualizzazione corretta di tuple e dizionari).  Usando i più recenti :ref:"
"`formattato stringa letterali <f-strings>`, il :meth:`str.format` "
"interfaccia, o :ref:</f-strings>`template stringhe <f-strings><template-"
"strings>` può aiutare ad evitare questi errori.  Ognuna di queste "
"alternative offre i propri compromessi e vantaggi di semplicità, "
"flessibilità e/o estensibilità.</template-strings></f-strings>"

#: ../Doc/library/stdtypes.rst:2115
#, fuzzy
msgid ""
"String objects have one unique built-in operation: the ``%`` operator "
"(modulo). This is also known as the string *formatting* or *interpolation* "
"operator. Given ``format % values`` (where *format* is a string), ``%`` "
"conversion specifications in *format* are replaced with zero or more "
"elements of *values*. The effect is similar to using the :c:func:`sprintf` "
"in the C language."
msgstr ""
"Gli oggetti di stringa hanno un'unica operazione integrata: l'operatore ``"
"%``` (modulo). Questo è noto anche come operatore di *formattazione* o "
"*interpolazione* della stringa. Dato ```formato %``` (dove *formato* è una "
"stringa), le specifiche di conversione ``%``` in *formato* sono sostituite "
"da zero o più elementi di *valori*. L'effetto è simile all'uso di :c:func:"
"`sprintf` nel linguaggio C."

#: ../Doc/library/stdtypes.rst:2121
#, fuzzy
msgid ""
"If *format* requires a single argument, *values* may be a single non-tuple "
"object. [5]_  Otherwise, *values* must be a tuple with exactly the number of "
"items specified by the format string, or a single mapping object (for "
"example, a dictionary)."
msgstr ""
"Se *formato* richiede un singolo argomento, *valori* può essere un singolo "
"oggetto non triplo. 5]_ Altrimenti, i *valori* devono essere una tupla con "
"esattamente il numero di elementi specificati dalla stringa di formato, o un "
"singolo oggetto di mappatura (per esempio, un dizionario)."

#: ../Doc/library/stdtypes.rst:2131 ../Doc/library/stdtypes.rst:3263
#, fuzzy
msgid ""
"A conversion specifier contains two or more characters and has the following "
"components, which must occur in this order:"
msgstr ""
"Uno specifico di conversione contiene due o più caratteri e presenta i "
"seguenti componenti, che devono essere presenti in questo ordine:"

#: ../Doc/library/stdtypes.rst:2134 ../Doc/library/stdtypes.rst:3266
#, fuzzy
msgid "The ``'%'`` character, which marks the start of the specifier."
msgstr "Il ``'%'%'``` carattere, che segna l'inizio dello specificatore."

#: ../Doc/library/stdtypes.rst:2136 ../Doc/library/stdtypes.rst:3268
#, fuzzy
msgid ""
"Mapping key (optional), consisting of a parenthesised sequence of characters "
"(for example, ``(somename)``)."
msgstr ""
"Chiave di mappatura (opzionale), consistente in una sequenza parentesi di "
"caratteri (per esempio, ``(somename)```)."

#: ../Doc/library/stdtypes.rst:2139 ../Doc/library/stdtypes.rst:3271
#, fuzzy
msgid ""
"Conversion flags (optional), which affect the result of some conversion "
"types."
msgstr ""
"Flag di conversione (opzionale), che influenzano il risultato di alcuni tipi "
"di conversione."

#: ../Doc/library/stdtypes.rst:2142 ../Doc/library/stdtypes.rst:3274
#, fuzzy
msgid ""
"Minimum field width (optional).  If specified as an ``'*'`` (asterisk), the "
"actual width is read from the next element of the tuple in *values*, and the "
"object to convert comes after the minimum field width and optional precision."
msgstr ""
"Larghezza minima del campo (opzionale).  Se specificato come ```'*'*'*'*` "
"(asterisco), la larghezza effettiva viene letta dall'elemento successivo "
"della tupla in *valori*, e l'oggetto da convertire viene dopo la larghezza "
"minima del campo e la precisione opzionale."

#: ../Doc/library/stdtypes.rst:2146 ../Doc/library/stdtypes.rst:3278
#, fuzzy
msgid ""
"Precision (optional), given as a ``'.'`` (dot) followed by the precision.  "
"If specified as ``'*'`` (an asterisk), the actual precision is read from the "
"next element of the tuple in *values*, and the value to convert comes after "
"the precision."
msgstr ""
"Precisione (opzionale), dato come ```'''`` (punto) seguito dalla "
"precisione.  Se specificato come ```'*'*'*'`` (un asterisco), la precisione "
"effettiva viene letta dall'elemento successivo della tupla in *valori*, e il "
"valore da convertire viene dopo la precisione."

#: ../Doc/library/stdtypes.rst:2151 ../Doc/library/stdtypes.rst:3283
msgid "Length modifier (optional)."
msgstr "Modificatore di lunghezza (opzionale)."

#: ../Doc/library/stdtypes.rst:2153 ../Doc/library/stdtypes.rst:3285
msgid "Conversion type."
msgstr "Tipo di conversione."

#: ../Doc/library/stdtypes.rst:2155
#, fuzzy
msgid ""
"When the right argument is a dictionary (or other mapping type), then the "
"formats in the string *must* include a parenthesised mapping key into that "
"dictionary inserted immediately after the ``'%'`` character. The mapping key "
"selects the value to be formatted from the mapping.  For example:"
msgstr ""
"Quando l'argomento giusto è un dizionario (o un altro tipo di mappatura), "
"allora i formati nella stringa *devono* includere una chiave di mappatura "
"parenthesised in quel dizionario inserito immediatamente dopo il ``'%'%'`` "
"carattere. Il tasto di mappatura seleziona il valore da formattare dalla "
"mappatura.  Per esempio:"

#: ../Doc/library/stdtypes.rst:2164 ../Doc/library/stdtypes.rst:3296
#, fuzzy
msgid ""
"In this case no ``*`` specifiers may occur in a format (since they require a "
"sequential parameter list)."
msgstr ""
"In questo caso non possono verificarsi specificatori ``*```` in un formato "
"(poiché richiedono una lista sequenziale dei parametri)."

#: ../Doc/library/stdtypes.rst:2167 ../Doc/library/stdtypes.rst:3299
#, fuzzy
msgid "The conversion flag characters are:"
msgstr "I caratteri della bandiera di conversione sono:"

#: ../Doc/library/stdtypes.rst:2176 ../Doc/library/stdtypes.rst:3308
msgid "Flag"
msgstr "Bandiera"

#: ../Doc/library/stdtypes.rst:2178 ../Doc/library/stdtypes.rst:3310
msgid "``'#'``"
msgstr "``’#’``"

#: ../Doc/library/stdtypes.rst:2178 ../Doc/library/stdtypes.rst:3310
msgid ""
"The value conversion will use the \"alternate form\" (where defined below)."
msgstr ""
"La conversione del valore utilizzerà la “forma alternativa” (definita di "
"seguito)."

#: ../Doc/library/stdtypes.rst:2181 ../Doc/library/stdtypes.rst:3313
msgid "``'0'``"
msgstr "``’0’``"

#: ../Doc/library/stdtypes.rst:2181 ../Doc/library/stdtypes.rst:3313
msgid "The conversion will be zero padded for numeric values."
msgstr "La conversione sarà paddata con zero per i valori numerici."

#: ../Doc/library/stdtypes.rst:2183 ../Doc/library/stdtypes.rst:3315
msgid "``'-'``"
msgstr "``’-‘``"

#: ../Doc/library/stdtypes.rst:2183 ../Doc/library/stdtypes.rst:3315
#, fuzzy
msgid ""
"The converted value is left adjusted (overrides the ``'0'`` conversion if "
"both are given)."
msgstr ""
"Il valore convertito è lasciato regolato (sovrascrive la conversione "
"``'0'0'``` se entrambi sono dati)."

#: ../Doc/library/stdtypes.rst:2186 ../Doc/library/stdtypes.rst:3318
msgid "``' '``"
msgstr "``’ ‘``"

#: ../Doc/library/stdtypes.rst:2186 ../Doc/library/stdtypes.rst:3318
#, fuzzy
msgid ""
"(a space) A blank should be left before a positive number (or empty string) "
"produced by a signed conversion."
msgstr ""
"(a spazio) Uno spazio vuoto deve essere lasciato prima di un numero positivo "
"(o stringa vuota) prodotto da una conversione firmata."

#: ../Doc/library/stdtypes.rst:2189 ../Doc/library/stdtypes.rst:3321
msgid "``'+'``"
msgstr "``’+’``"

#: ../Doc/library/stdtypes.rst:2189 ../Doc/library/stdtypes.rst:3321
#, fuzzy
msgid ""
"A sign character (``'+'`` or ``'-'``) will precede the conversion (overrides "
"a \"space\" flag)."
msgstr ""
"Un carattere del segno (``'+'+'``` o ```'-'-'````) precede la conversione "
"(sostituisce una bandiera \"spazio\")."

#: ../Doc/library/stdtypes.rst:2193 ../Doc/library/stdtypes.rst:3325
#, fuzzy
msgid ""
"A length modifier (``h``, ``l``, or ``L``) may be present, but is ignored as "
"it is not necessary for Python -- so e.g. ``%ld`` is identical to ``%d``."
msgstr ""
"Un modificatore di lunghezza (``h````, ``l```, o ``L`````) può essere "
"presente, ma viene ignorato in quanto non è necessario per Python -- quindi, "
"ad esempio, ``%ld``` è identico a ``%d```."

#: ../Doc/library/stdtypes.rst:2196 ../Doc/library/stdtypes.rst:3328
msgid "The conversion types are:"
msgstr "I tipi di conversione sono:"

#: ../Doc/library/stdtypes.rst:2199 ../Doc/library/stdtypes.rst:3331
msgid "Conversion"
msgstr "Conversione"

#: ../Doc/library/stdtypes.rst:2201 ../Doc/library/stdtypes.rst:3333
msgid "``'d'``"
msgstr "``’d’``"

#: ../Doc/library/stdtypes.rst:2201 ../Doc/library/stdtypes.rst:2203
#: ../Doc/library/stdtypes.rst:3333 ../Doc/library/stdtypes.rst:3335
msgid "Signed integer decimal."
msgstr "Intero decimale con segno."

#: ../Doc/library/stdtypes.rst:2203 ../Doc/library/stdtypes.rst:3335
msgid "``'i'``"
msgstr "``’i’``"

#: ../Doc/library/stdtypes.rst:2205 ../Doc/library/stdtypes.rst:3337
msgid "``'o'``"
msgstr "``’o’``"

#: ../Doc/library/stdtypes.rst:2205 ../Doc/library/stdtypes.rst:3337
msgid "Signed octal value."
msgstr "Valore ottale con segno."

#: ../Doc/library/stdtypes.rst:2207 ../Doc/library/stdtypes.rst:3339
msgid "``'u'``"
msgstr "``’u’``"

#: ../Doc/library/stdtypes.rst:2207 ../Doc/library/stdtypes.rst:3339
msgid "Obsolete type -- it is identical to ``'d'``."
msgstr "Tipo obsoleto -- è identico a ``’d’``."

#: ../Doc/library/stdtypes.rst:2209 ../Doc/library/stdtypes.rst:3341
msgid "``'x'``"
msgstr "``’x’``"

#: ../Doc/library/stdtypes.rst:2209 ../Doc/library/stdtypes.rst:3341
msgid "Signed hexadecimal (lowercase)."
msgstr "Esadecimale con segno (minuscolo)."

#: ../Doc/library/stdtypes.rst:2211 ../Doc/library/stdtypes.rst:3343
msgid "``'X'``"
msgstr "``’x’``"

#: ../Doc/library/stdtypes.rst:2211 ../Doc/library/stdtypes.rst:3343
msgid "Signed hexadecimal (uppercase)."
msgstr "Esadecimale con segno (minuscolo)."

#: ../Doc/library/stdtypes.rst:2213 ../Doc/library/stdtypes.rst:3345
msgid "``'e'``"
msgstr "``’e’``"

#: ../Doc/library/stdtypes.rst:2213 ../Doc/library/stdtypes.rst:3345
msgid "Floating point exponential format (lowercase)."
msgstr "Formato esponenziale a virgola mobile (minuscolo)."

#: ../Doc/library/stdtypes.rst:2215 ../Doc/library/stdtypes.rst:3347
msgid "``'E'``"
msgstr "``’E’``"

#: ../Doc/library/stdtypes.rst:2215 ../Doc/library/stdtypes.rst:3347
msgid "Floating point exponential format (uppercase)."
msgstr "Formato esponenziale in virgola mobile (maiuscolo)."

#: ../Doc/library/stdtypes.rst:2217 ../Doc/library/stdtypes.rst:3349
msgid "``'f'``"
msgstr "``’f’``"

#: ../Doc/library/stdtypes.rst:2217 ../Doc/library/stdtypes.rst:2219
#: ../Doc/library/stdtypes.rst:3349 ../Doc/library/stdtypes.rst:3351
msgid "Floating point decimal format."
msgstr "Formato decimale a virgola mobile."

#: ../Doc/library/stdtypes.rst:2219 ../Doc/library/stdtypes.rst:3351
msgid "``'F'``"
msgstr "``’F’``"

#: ../Doc/library/stdtypes.rst:2221 ../Doc/library/stdtypes.rst:3353
msgid "``'g'``"
msgstr "``’g’``"

#: ../Doc/library/stdtypes.rst:2221 ../Doc/library/stdtypes.rst:3353
msgid ""
"Floating point format. Uses lowercase exponential format if exponent is less "
"than -4 or not less than precision, decimal format otherwise."
msgstr ""
"Formato a virgola mobile. Utilizza il formato esponenziale minuscolo se "
"l'esponente è inferiore a -4 o non inferiore alla precisione, altrimenti il "
"formato decimale."

#: ../Doc/library/stdtypes.rst:2225 ../Doc/library/stdtypes.rst:3357
msgid "``'G'``"
msgstr "``’G’``"

#: ../Doc/library/stdtypes.rst:2225 ../Doc/library/stdtypes.rst:3357
msgid ""
"Floating point format. Uses uppercase exponential format if exponent is less "
"than -4 or not less than precision, decimal format otherwise."
msgstr ""
"Formato a virgola mobile. Utilizza il formato esponenziale maiuscolo se "
"l'esponente è inferiore a -4 o non inferiore alla precisione, altrimenti il "
"formato decimale."

#: ../Doc/library/stdtypes.rst:2229 ../Doc/library/stdtypes.rst:3361
msgid "``'c'``"
msgstr "``’c’``"

#: ../Doc/library/stdtypes.rst:2229
msgid "Single character (accepts integer or single character string)."
msgstr ""
"Singolo carattere (accetta caratteri interi o stringhe di caratteri singoli)."

#: ../Doc/library/stdtypes.rst:2232 ../Doc/library/stdtypes.rst:3374
msgid "``'r'``"
msgstr "``’r’``"

#: ../Doc/library/stdtypes.rst:2232
msgid "String (converts any Python object using :func:`repr`)."
msgstr "String (converte qualsiasi oggetto Python usando :func:`repr`)."

#: ../Doc/library/stdtypes.rst:2235 ../Doc/library/stdtypes.rst:3368
msgid "``'s'``"
msgstr "``’s’``"

#: ../Doc/library/stdtypes.rst:2235
msgid "String (converts any Python object using :func:`str`)."
msgstr "String (converte qualsiasi oggetto Python usando :func:`str`)."

#: ../Doc/library/stdtypes.rst:2238 ../Doc/library/stdtypes.rst:3371
msgid "``'a'``"
msgstr "``’a’``"

#: ../Doc/library/stdtypes.rst:2238
msgid "String (converts any Python object using :func:`ascii`)."
msgstr "String (converte qualsiasi oggetto Python usando :func:`ascii`)."

#: ../Doc/library/stdtypes.rst:2241 ../Doc/library/stdtypes.rst:3377
msgid "``'%'``"
msgstr "``’%’``"

#: ../Doc/library/stdtypes.rst:2241 ../Doc/library/stdtypes.rst:3377
#, fuzzy
msgid "No argument is converted, results in a ``'%'`` character in the result."
msgstr ""
"Nessun argomento è convertito, i risultati in un ``'%'%'``` carattere nel "
"risultato."

#: ../Doc/library/stdtypes.rst:2248 ../Doc/library/stdtypes.rst:3384
#, fuzzy
msgid ""
"The alternate form causes a leading octal specifier (``'0o'``) to be "
"inserted before the first digit."
msgstr ""
"La forma alternativa fa sì che un specificatore ottale principale "
"(``'0o'0o'```) sia inserito prima della prima cifra."

#: ../Doc/library/stdtypes.rst:2252 ../Doc/library/stdtypes.rst:3388
#, fuzzy
msgid ""
"The alternate form causes a leading ``'0x'`` or ``'0X'`` (depending on "
"whether the ``'x'`` or ``'X'`` format was used) to be inserted before the "
"first digit."
msgstr ""
"La forma alternativa fa sì che un ```'0x'```` o ``'0X'``` (a seconda che sia "
"stato usato il ``'x'``` o ``'X'``` formato ```) venga inserito prima della "
"prima cifra."

#: ../Doc/library/stdtypes.rst:2256 ../Doc/library/stdtypes.rst:3392
#, fuzzy
msgid ""
"The alternate form causes the result to always contain a decimal point, even "
"if no digits follow it."
msgstr ""
"La forma alternativa fa sì che il risultato contenga sempre un punto "
"decimale, anche se non seguono cifre."

#: ../Doc/library/stdtypes.rst:2259 ../Doc/library/stdtypes.rst:3395
#, fuzzy
msgid ""
"The precision determines the number of digits after the decimal point and "
"defaults to 6."
msgstr ""
"La precisione determina il numero di cifre dopo il punto decimale e per "
"impostazione predefinita è 6."

#: ../Doc/library/stdtypes.rst:2263 ../Doc/library/stdtypes.rst:3399
#, fuzzy
msgid ""
"The alternate form causes the result to always contain a decimal point, and "
"trailing zeroes are not removed as they would otherwise be."
msgstr ""
"La forma alternativa fa sì che il risultato contenga sempre un punto "
"decimale, e gli zeri finali non vengono rimossi come sarebbero altrimenti."

#: ../Doc/library/stdtypes.rst:2266 ../Doc/library/stdtypes.rst:3402
#, fuzzy
msgid ""
"The precision determines the number of significant digits before and after "
"the decimal point and defaults to 6."
msgstr ""
"La precisione determina il numero di cifre significative prima e dopo il "
"punto decimale e per impostazione predefinita è 6."

#: ../Doc/library/stdtypes.rst:2270 ../Doc/library/stdtypes.rst:3406
#, fuzzy
msgid "If precision is ``N``, the output is truncated to ``N`` characters."
msgstr ""
"Se la precisione è ``N````, l'uscita viene troncata in caratteri ```N```."

#: ../Doc/library/stdtypes.rst:2273 ../Doc/library/stdtypes.rst:3415
#, fuzzy
msgid "See :pep:`237`."
msgstr "Vedere :pep:`237`."

#: ../Doc/library/stdtypes.rst:2275
#, fuzzy
msgid ""
"Since Python strings have an explicit length, ``%s`` conversions do not "
"assume that ``'\\0'`` is the end of the string."
msgstr ""
"Poiché le stringhe di Python hanno una lunghezza esplicita, le conversioni "
"del ``%``` non presuppongono che ```'\\0``` sia la fine della stringa."

#: ../Doc/library/stdtypes.rst:2280
#, fuzzy
msgid ""
"``%f`` conversions for numbers whose absolute value is over 1e50 are no "
"longer replaced by ``%g`` conversions."
msgstr ""
"Le conversioni ``%f``` per i numeri il cui valore assoluto è superiore a "
"1e50 non sono più sostituite da conversioni ``%g```."

#: ../Doc/library/stdtypes.rst:2291
#, fuzzy
msgid ""
"Binary Sequence Types --- :class:`bytes`, :class:`bytearray`, :class:"
"`memoryview`"
msgstr ""
"Tipi di sequenza binaria ----- :class:`bytes`, :class:`bytearray`, :class:"
"`memoryview`"

#: ../Doc/library/stdtypes.rst:2299
#, fuzzy
msgid ""
"The core built-in types for manipulating binary data are :class:`bytes` and :"
"class:`bytearray`. They are supported by :class:`memoryview` which uses the :"
"ref:`buffer protocol <bufferobjects>` to access the memory of other binary "
"objects without needing to make a copy."
msgstr ""
"I tipi di base incorporati per la manipolazione dei dati binari sono: class:"
"`bytes` e :class:`bytearray`. Sono supportati da :class:`memoryview` che "
"utilizza il :ref:`buffer protocol <bufferobjects>`per accedere alla memoria "
"di altri oggetti binari senza doverne fare una copia.</bufferobjects>"

#: ../Doc/library/stdtypes.rst:2304
#, fuzzy
msgid ""
"The :mod:`array` module supports efficient storage of basic data types like "
"32-bit integers and IEEE754 double-precision floating values."
msgstr ""
"Il modulo :mod:`array` supporta l'efficiente archiviazione dei tipi di dati "
"di base come i numeri interi a 32 bit e i valori flottanti a doppia "
"precisione IEEE754."

#: ../Doc/library/stdtypes.rst:2310
#, fuzzy
msgid "Bytes Objects"
msgstr "Bytes Oggetti"

#: ../Doc/library/stdtypes.rst:2314
#, fuzzy
msgid ""
"Bytes objects are immutable sequences of single bytes. Since many major "
"binary protocols are based on the ASCII text encoding, bytes objects offer "
"several methods that are only valid when working with ASCII compatible data "
"and are closely related to string objects in a variety of other ways."
msgstr ""
"Gli oggetti byte sono sequenze immutabili di singoli byte. Poiché molti dei "
"principali protocolli binari si basano sulla codifica del testo ASCII, gli "
"oggetti byte offrono diversi metodi che sono validi solo quando si lavora "
"con dati compatibili con ASCII e sono strettamente correlati agli oggetti "
"stringa in una varietà di altri modi."

#: ../Doc/library/stdtypes.rst:2321
#, fuzzy
msgid ""
"Firstly, the syntax for bytes literals is largely the same as that for "
"string literals, except that a ``b`` prefix is added:"
msgstr ""
"In primo luogo, la sintassi dei byte letterali è in gran parte la stessa di "
"quella delle stringhe letterali, tranne per il fatto che viene aggiunto un "
"prefisso ``b````:"

#: ../Doc/library/stdtypes.rst:2324
#, fuzzy
msgid "Single quotes: ``b'still allows embedded \"double\" quotes'``"
msgstr "Citazioni singole: ```b'still allows embedded \"double\" quotes'````"

#: ../Doc/library/stdtypes.rst:2325
#, fuzzy
msgid "Double quotes: ``b\"still allows embedded 'single' quotes\"``."
msgstr ""
"Citazioni doppie: ```b \"permette ancora di inserire 'singole' virgolette"
"\"```."

#: ../Doc/library/stdtypes.rst:2326
#, fuzzy
msgid ""
"Triple quoted: ``b'''3 single quotes'''``, ``b\"\"\"3 double quotes\"\"\"``"
msgstr ""
"Triplo citato: ```b''''3 citazioni singole''''``, ``b\"\"\"3 citazioni doppie"
"\"\"\"\"```"

#: ../Doc/library/stdtypes.rst:2328
#, fuzzy
msgid ""
"Only ASCII characters are permitted in bytes literals (regardless of the "
"declared source code encoding). Any binary values over 127 must be entered "
"into bytes literals using the appropriate escape sequence."
msgstr ""
"Solo i caratteri ASCII sono consentiti in byte letterali (indipendentemente "
"dalla codifica del codice sorgente dichiarato). Qualsiasi valore binario "
"superiore a 127 deve essere inserito in byte letterali utilizzando "
"l'appropriata sequenza di escape."

#: ../Doc/library/stdtypes.rst:2332
#, fuzzy
msgid ""
"As with string literals, bytes literals may also use a ``r`` prefix to "
"disable processing of escape sequences. See :ref:`strings` for more about "
"the various forms of bytes literal, including supported escape sequences."
msgstr ""
"Come per le stringhe letterali, i byte letterali possono anche usare un "
"prefisso ``r```` per disabilitare l'elaborazione delle sequenze di escape. "
"Vedere :ref:`stringhe` per maggiori informazioni sulle varie forme di byte "
"letterali, incluse le sequenze di escape supportate."

#: ../Doc/library/stdtypes.rst:2336
#, fuzzy
msgid ""
"While bytes literals and representations are based on ASCII text, bytes "
"objects actually behave like immutable sequences of integers, with each "
"value in the sequence restricted such that ``0 <= x < 256`` (attempts to "
"violate this restriction will trigger :exc:`ValueError`). This is done "
"deliberately to emphasise that while many binary formats include ASCII based "
"elements and can be usefully manipulated with some text-oriented algorithms, "
"this is not generally the case for arbitrary binary data (blindly applying "
"text processing algorithms to binary data formats that are not ASCII "
"compatible will usually lead to data corruption)."
msgstr ""
"Mentre i byte letterali e le rappresentazioni si basano su testo ASCII, gli "
"oggetti byte si comportano effettivamente come sequenze immutabili di "
"interi, con ogni valore della sequenza limitata in modo tale che ``0 <= x < "
"256``` (i tentativi di violare questa restrizione si innescheranno: exc:"
"`ValueError`). Questo viene fatto deliberatamente per sottolineare che, "
"mentre molti formati binari includono elementi basati su ASCII e possono "
"essere utilmente manipolati con alcuni algoritmi orientati al testo, questo "
"non è generalmente il caso di dati binari arbitrari (l'applicazione cieca di "
"algoritmi di elaborazione del testo a formati di dati binari che non sono "
"compatibili con ASCII di solito porta alla corruzione dei dati)."

#: ../Doc/library/stdtypes.rst:2346
#, fuzzy
msgid ""
"In addition to the literal forms, bytes objects can be created in a number "
"of other ways:"
msgstr ""
"Oltre alle forme letterali, gli oggetti byte possono essere creati in "
"diversi altri modi:"

#: ../Doc/library/stdtypes.rst:2349
msgid "A zero-filled bytes object of a specified length: ``bytes(10)``"
msgstr ""
"Un oggetto a byte paddato con zero di lunghezza specificata: ``bytes(10)``"

#: ../Doc/library/stdtypes.rst:2350
msgid "From an iterable of integers: ``bytes(range(20))``"
msgstr "Da un iterable di numeri interi: ``bytes(range(20))``"

#: ../Doc/library/stdtypes.rst:2351
#, fuzzy
msgid "Copying existing binary data via the buffer protocol:  ``bytes(obj)``"
msgstr ""
"Copia di dati binari esistenti tramite il protocollo buffer:  "
"```bytes(obj)```"

#: ../Doc/library/stdtypes.rst:2353
#, fuzzy
msgid "Also see the :ref:`bytes <func-bytes>` built-in."
msgstr "Vedere anche il file :ref:`bytes <func-bytes>` built-in.</func-bytes>"

#: ../Doc/library/stdtypes.rst:2355
#, fuzzy
msgid ""
"Since 2 hexadecimal digits correspond precisely to a single byte, "
"hexadecimal numbers are a commonly used format for describing binary data. "
"Accordingly, the bytes type has an additional class method to read data in "
"that format:"
msgstr ""
"Poiché 2 cifre esadecimali corrispondono esattamente ad un singolo byte, i "
"numeri esadecimali sono un formato comunemente usato per descrivere i dati "
"binari. Di conseguenza, il tipo di byte ha un metodo di classe aggiuntivo "
"per leggere i dati in quel formato:"

#: ../Doc/library/stdtypes.rst:2361
#, fuzzy
msgid ""
"This :class:`bytes` class method returns a bytes object, decoding the given "
"string object.  The string must contain two hexadecimal digits per byte, "
"with ASCII whitespace being ignored."
msgstr ""
"Questo metodo class:`bytes` class restituisce un oggetto bytes, "
"decodificando l'oggetto stringa dato.  La stringa deve contenere due cifre "
"esadecimali per byte, ignorando gli spazi bianchi ASCII."

#: ../Doc/library/stdtypes.rst:2368
#, fuzzy
msgid ""
":meth:`bytes.fromhex` now skips all ASCII whitespace in the string, not just "
"spaces."
msgstr ""
":meth:`bytes.fromhex` ora salta tutti gli spazi bianchi ASCII nella stringa, "
"non solo gli spazi."

#: ../Doc/library/stdtypes.rst:2372
#, fuzzy
msgid ""
"A reverse conversion function exists to transform a bytes object into its "
"hexadecimal representation."
msgstr ""
"Esiste una funzione di conversione inversa per trasformare un oggetto byte "
"nella sua rappresentazione esadecimale."

#: ../Doc/library/stdtypes.rst:2377 ../Doc/library/stdtypes.rst:2453
#, fuzzy
msgid ""
"Return a string object containing two hexadecimal digits for each byte in "
"the instance."
msgstr ""
"Restituisce un oggetto stringa contenente due cifre esadecimali per ogni "
"byte nell'istanza."

#: ../Doc/library/stdtypes.rst:2385
#, fuzzy
msgid ""
"Since bytes objects are sequences of integers (akin to a tuple), for a bytes "
"object *b*, ``b[0]`` will be an integer, while ``b[0:1]`` will be a bytes "
"object of length 1.  (This contrasts with text strings, where both indexing "
"and slicing will produce a string of length 1)"
msgstr ""
"Poiché gli oggetti byte sono sequenze di interi (simili a una tupla), per un "
"oggetto byte *b*, ``b[0]``` sarà un intero, mentre ``b[0:1]``` sarà un "
"oggetto byte di lunghezza 1. (Questo contrasta con le stringhe di testo, "
"dove sia l'indicizzazione che il taglio produrrà una stringa di lunghezza 1)"

#: ../Doc/library/stdtypes.rst:2390
#, fuzzy
msgid ""
"The representation of bytes objects uses the literal format (``b'...'``) "
"since it is often more useful than e.g. ``bytes([46, 46, 46])``.  You can "
"always convert a bytes object into a list of integers using ``list(b)``."
msgstr ""
"La rappresentazione degli oggetti byte utilizza il formato letterale "
"(``b'.....'```) poiché è spesso più utile di quanto non lo sia, ad esempio, "
"``bytes([46, 46, 46, 46])``.  È sempre possibile convertire un oggetto byte "
"in una lista di numeri interi usando ``list(b)``."

#: ../Doc/library/stdtypes.rst:2395
#, fuzzy
msgid ""
"For Python 2.x users: In the Python 2.x series, a variety of implicit "
"conversions between 8-bit strings (the closest thing 2.x offers to a built-"
"in binary data type) and Unicode strings were permitted. This was a "
"backwards compatibility workaround to account for the fact that Python "
"originally only supported 8-bit text, and Unicode text was a later addition. "
"In Python 3.x, those implicit conversions are gone - conversions between 8-"
"bit binary data and Unicode text must be explicit, and bytes and string "
"objects will always compare unequal."
msgstr ""
"Per gli utenti di Python 2.x: Nella serie Python 2.x, erano consentite una "
"varietà di conversioni implicite tra stringhe a 8 bit (la cosa più simile "
"che 2.x offre a un tipo di dati binari integrati) e stringhe Unicode. Si "
"trattava di una soluzione di compatibilità a ritroso per tenere conto del "
"fatto che Python originariamente supportava solo testo a 8 bit, mentre il "
"testo Unicode era un'aggiunta successiva. In Python 3.x, le conversioni "
"implicite sono andate - le conversioni tra dati binari a 8 bit e testo "
"Unicode devono essere esplicite, e i byte e gli oggetti stringa "
"confronteranno sempre ineguali."

#: ../Doc/library/stdtypes.rst:2408
msgid "Bytearray Objects"
msgstr "Oggetti Bytearray"

#: ../Doc/library/stdtypes.rst:2412
msgid ""
":class:`bytearray` objects are a mutable counterpart to :class:`bytes` "
"objects."
msgstr ""
"Gli oggetti class:class:`bytearray` sono una controparte mutevole degli "
"oggetti :class:`bytes`."

#: ../Doc/library/stdtypes.rst:2417
#, fuzzy
msgid ""
"There is no dedicated literal syntax for bytearray objects, instead they are "
"always created by calling the constructor:"
msgstr ""
"Non esiste una sintassi letterale dedicata agli oggetti bytearray, ma "
"vengono sempre creati chiamando il costruttore:"

#: ../Doc/library/stdtypes.rst:2420
#, fuzzy
msgid "Creating an empty instance: ``bytearray()``"
msgstr "Creazione di un'istanza vuota: ``bytearray()````"

#: ../Doc/library/stdtypes.rst:2421
#, fuzzy
msgid "Creating a zero-filled instance with a given length: ``bytearray(10)``"
msgstr ""
"Creazione di un'istanza riempita a zero con una data lunghezza: "
"``bytearray(10)```"

#: ../Doc/library/stdtypes.rst:2422
#, fuzzy
msgid "From an iterable of integers: ``bytearray(range(20))``"
msgstr "Da un'iterabile di numeri interi: ``bytearray(range(20))````"

#: ../Doc/library/stdtypes.rst:2423
#, fuzzy
msgid ""
"Copying existing binary data via the buffer protocol:  ``bytearray(b'Hi!')``"
msgstr ""
"Copia di dati binari esistenti tramite il protocollo buffer:  "
"``bytearray(b'Hi!')```"

#: ../Doc/library/stdtypes.rst:2425
#, fuzzy
msgid ""
"As bytearray objects are mutable, they support the :ref:`mutable <typesseq-"
"mutable>` sequence operations in addition to the common bytes and bytearray "
"operations described in :ref:`bytes-methods`."
msgstr ""
"Poiché gli oggetti bytearray sono mutevoli, essi supportano le operazioni di "
"<typesseq-mutable>sequenza</typesseq-mutable> :ref:`mutable `mutable "
"<typesseq-mutable>`oltre alle comuni operazioni di byte e bytearray "
"descritte in :ref:`bytes-methods`.</typesseq-mutable>"

#: ../Doc/library/stdtypes.rst:2429
#, fuzzy
msgid "Also see the :ref:`bytearray <func-bytearray>` built-in."
msgstr ""
"Vedere anche il :ref:`bytearray <func-bytearray>` built-in.</func-bytearray>"

#: ../Doc/library/stdtypes.rst:2431
#, fuzzy
msgid ""
"Since 2 hexadecimal digits correspond precisely to a single byte, "
"hexadecimal numbers are a commonly used format for describing binary data. "
"Accordingly, the bytearray type has an additional class method to read data "
"in that format:"
msgstr ""
"Poiché 2 cifre esadecimali corrispondono esattamente ad un singolo byte, i "
"numeri esadecimali sono un formato comunemente usato per descrivere i dati "
"binari. Di conseguenza, il tipo bytearray ha un metodo di classe aggiuntivo "
"per leggere i dati in quel formato:"

#: ../Doc/library/stdtypes.rst:2437
#, fuzzy
msgid ""
"This :class:`bytearray` class method returns bytearray object, decoding the "
"given string object.  The string must contain two hexadecimal digits per "
"byte, with ASCII whitespace being ignored."
msgstr ""
"Questo metodo class:class:`bytearray` class restituisce l'oggetto bytearray, "
"decodificando l'oggetto stringa dato.  La stringa deve contenere due cifre "
"esadecimali per byte, ignorando gli spazi bianchi ASCII."

#: ../Doc/library/stdtypes.rst:2444
#, fuzzy
msgid ""
":meth:`bytearray.fromhex` now skips all ASCII whitespace in the string, not "
"just spaces."
msgstr ""
":meth:`bytearray.fromhex` ora salta tutti gli spazi bianchi ASCII nella "
"stringa, non solo gli spazi."

#: ../Doc/library/stdtypes.rst:2448
#, fuzzy
msgid ""
"A reverse conversion function exists to transform a bytearray object into "
"its hexadecimal representation."
msgstr ""
"Esiste una funzione di conversione inversa per trasformare un oggetto "
"bytearray nella sua rappresentazione esadecimale."

#: ../Doc/library/stdtypes.rst:2461
#, fuzzy
msgid ""
"Since bytearray objects are sequences of integers (akin to a list), for a "
"bytearray object *b*, ``b[0]`` will be an integer, while ``b[0:1]`` will be "
"a bytearray object of length 1.  (This contrasts with text strings, where "
"both indexing and slicing will produce a string of length 1)"
msgstr ""
"Poiché gli oggetti bytearray sono sequenze di interi (simili ad una lista), "
"per un oggetto bytearray *b*, ``b[0]```` sarà un intero, mentre ``b[0:1]``` "
"sarà un oggetto bytearray di lunghezza 1. (Questo contrasta con le stringhe "
"di testo, dove sia l'indicizzazione che il taglio produrrà una stringa di "
"lunghezza 1)"

#: ../Doc/library/stdtypes.rst:2466
#, fuzzy
msgid ""
"The representation of bytearray objects uses the bytes literal format "
"(``bytearray(b'...')``) since it is often more useful than e.g. "
"``bytearray([46, 46, 46])``.  You can always convert a bytearray object into "
"a list of integers using ``list(b)``."
msgstr ""
"La rappresentazione degli oggetti bytearray utilizza il formato letterale "
"dei byte (``bytearray(b'....'')``) poiché è spesso più utile di quanto non "
"lo sia, ad esempio, ``bytearray([46, 46, 46, 46])```.  È sempre possibile "
"convertire un oggetto bytearray in una lista di numeri interi usando "
"``list(b)``."

#: ../Doc/library/stdtypes.rst:2475
msgid "Bytes and Bytearray Operations"
msgstr "Operazioni Bytes e Bytearray"

#: ../Doc/library/stdtypes.rst:2480
#, fuzzy
msgid ""
"Both bytes and bytearray objects support the :ref:`common <typesseq-common>` "
"sequence operations. They interoperate not just with operands of the same "
"type, but with any :term:`bytes-like object`. Due to this flexibility, they "
"can be freely mixed in operations without causing errors. However, the "
"return type of the result may depend on the order of operands."
msgstr ""
"Sia i byte che gli oggetti bytearray supportano le <typesseq-"
"common>operazioni di sequenza</typesseq-common> :ref:`common `common "
"<typesseq-common>`. Essi interagiscono non solo con operandi dello stesso "
"tipo, ma con qualsiasi:termine:`bytes-like object`. Grazie a questa "
"flessibilità, possono essere mescolati liberamente nelle operazioni senza "
"causare errori. Tuttavia, il tipo di ritorno del risultato può dipendere "
"dall'ordine degli operandi.</typesseq-common>"

#: ../Doc/library/stdtypes.rst:2488
#, fuzzy
msgid ""
"The methods on bytes and bytearray objects don't accept strings as their "
"arguments, just as the methods on strings don't accept bytes as their "
"arguments.  For example, you have to write::"
msgstr ""
"I metodi sugli oggetti byte e bytearray non accettano le stringhe come "
"argomenti, così come i metodi sulle stringhe non accettano i byte come "
"argomenti.  Per esempio, devi scrivere:.:"

#: ../Doc/library/stdtypes.rst:2495
msgid "and::"
msgstr "e::"

#: ../Doc/library/stdtypes.rst:2500
#, fuzzy
msgid ""
"Some bytes and bytearray operations assume the use of ASCII compatible "
"binary formats, and hence should be avoided when working with arbitrary "
"binary data. These restrictions are covered below."
msgstr ""
"Alcune operazioni di byte e bytearray presuppongono l'uso di formati binari "
"compatibili con ASCII, e quindi dovrebbero essere evitate quando si lavora "
"con dati binari arbitrari. Queste restrizioni sono trattate di seguito."

#: ../Doc/library/stdtypes.rst:2505
#, fuzzy
msgid ""
"Using these ASCII based operations to manipulate binary data that is not "
"stored in an ASCII based format may lead to data corruption."
msgstr ""
"L'utilizzo di queste operazioni basate su ASCII per manipolare dati binari "
"che non sono memorizzati in un formato basato su ASCII può portare alla "
"corruzione dei dati."

#: ../Doc/library/stdtypes.rst:2508
#, fuzzy
msgid ""
"The following methods on bytes and bytearray objects can be used with "
"arbitrary binary data."
msgstr ""
"I seguenti metodi sugli oggetti byte e bytearray possono essere utilizzati "
"con dati binari arbitrari."

#: ../Doc/library/stdtypes.rst:2514
#, fuzzy
msgid ""
"Return the number of non-overlapping occurrences of subsequence *sub* in the "
"range [*start*, *end*].  Optional arguments *start* and *end* are "
"interpreted as in slice notation."
msgstr ""
"Restituisce il numero di occorrenze non sovrapposte di sequenze *sub* "
"nell'intervallo [*inizio*, *fine*].  Gli argomenti facoltativi *start* e "
"*end* sono interpretati come una notazione di fetta."

#: ../Doc/library/stdtypes.rst:2518 ../Doc/library/stdtypes.rst:2565
#: ../Doc/library/stdtypes.rst:2587 ../Doc/library/stdtypes.rst:2653
#: ../Doc/library/stdtypes.rst:2666
#, fuzzy
msgid ""
"The subsequence to search for may be any :term:`bytes-like object` or an "
"integer in the range 0 to 255."
msgstr ""
"La sequenza da cercare può essere qualsiasi :termine:`bytes-like object` o "
"un intero nell'intervallo da 0 a 255."

#: ../Doc/library/stdtypes.rst:2521 ../Doc/library/stdtypes.rst:2577
#: ../Doc/library/stdtypes.rst:2590 ../Doc/library/stdtypes.rst:2656
#: ../Doc/library/stdtypes.rst:2669
#, fuzzy
msgid "Also accept an integer in the range 0 to 255 as the subsequence."
msgstr ""
"Accettare anche un numero intero compreso tra 0 e 255 come conseguenza."

#: ../Doc/library/stdtypes.rst:2528
#, fuzzy
msgid ""
"Return a string decoded from the given bytes.  Default encoding is "
"``'utf-8'``. *errors* may be given to set a different error handling "
"scheme.  The default for *errors* is ``'strict'``, meaning that encoding "
"errors raise a :exc:`UnicodeError`.  Other possible values are ``'ignore'``, "
"``'replace'`` and any other name registered via :func:`codecs."
"register_error`, see section :ref:`error-handlers`. For a list of possible "
"encodings, see section :ref:`standard-encodings`."
msgstr ""
"Restituisce una stringa decodificata dai byte dati.  La codifica predefinita "
"è ``'utf-8'````. *errori* possono essere forniti per impostare un diverso "
"schema di gestione degli errori.  Il valore predefinito per *errori* è "
"``'strict'````, il che significa che gli errori di codifica generano un :exc:"
"`UnicodeError`.  Altri valori possibili sono ``'ignore'```, ``'replace'``` e "
"qualsiasi altro nome registrato tramite :func:`codecs.register_error`, "
"vedere la sezione :ref:`error-handlers`. Per un elenco delle codifiche "
"possibili, vedere la sezione :ref:`codifiche standard`."

#: ../Doc/library/stdtypes.rst:2538
#, fuzzy
msgid ""
"Passing the *encoding* argument to :class:`str` allows decoding any :term:"
"`bytes-like object` directly, without needing to make a temporary bytes or "
"bytearray object."
msgstr ""
"Passare l'argomento *codifica* a :class:`str` permette di decodificare "
"qualsiasi :termine:`bytes-like object` direttamente, senza bisogno di fare "
"un byte temporaneo o un oggetto bytearray."

#: ../Doc/library/stdtypes.rst:2542
msgid "Added support for keyword arguments."
msgstr "Aggiunto il supporto per i keyword argument."

#: ../Doc/library/stdtypes.rst:2549
#, fuzzy
msgid ""
"Return ``True`` if the binary data ends with the specified *suffix*, "
"otherwise return ``False``.  *suffix* can also be a tuple of suffixes to "
"look for.  With optional *start*, test beginning at that position.  With "
"optional *end*, stop comparing at that position."
msgstr ""
"Restituire ``True``` se i dati binari terminano con il *suffisso* "
"specificato, altrimenti restituire ``False```.  ** può anche essere una "
"tupla di suffissi da cercare.  Con *start* opzionale, il test inizia in "
"quella posizione.  Con *fine* opzionale, interrompere il confronto in quella "
"posizione."

#: ../Doc/library/stdtypes.rst:2554
#, fuzzy
msgid "The suffix(es) to search for may be any :term:`bytes-like object`."
msgstr ""
"Il suffisso da cercare può essere qualsiasi: termine:`bytes-like object`."

#: ../Doc/library/stdtypes.rst:2560
#, fuzzy
msgid ""
"Return the lowest index in the data where the subsequence *sub* is found, "
"such that *sub* is contained in the slice ``s[start:end]``.  Optional "
"arguments *start* and *end* are interpreted as in slice notation.  Return "
"``-1`` if *sub* is not found."
msgstr ""
"Restituisce l'indice più basso nei dati in cui si trova la sequenza *sub*, "
"in modo tale che *sub* è contenuto nella fetta ``s[start:end]``.  Gli "
"argomenti facoltativi *start* e *end* sono interpretati come una notazione "
"di fetta.  Restituire ``-1```` se *sub* non viene trovato."

#: ../Doc/library/stdtypes.rst:2570
#, fuzzy
msgid ""
"The :meth:`~bytes.find` method should be used only if you need to know the "
"position of *sub*.  To check if *sub* is a substring or not, use the :"
"keyword:`in` operator::"
msgstr ""
"Il metodo :meth:`~bytes.find` dovrebbe essere usato solo se avete bisogno di "
"conoscere la posizione di *sub*.  Per verificare se *sub* è un substrato o "
"meno, usare la parola chiave :keyword:`in` operator::"

#: ../Doc/library/stdtypes.rst:2584
#, fuzzy
msgid ""
"Like :meth:`~bytes.find`, but raise :exc:`ValueError` when the subsequence "
"is not found."
msgstr ""
"Come :meth:`~bytes.find`, ma alza :exc:`ValueError` quando la sequenza non "
"viene trovata."

#: ../Doc/library/stdtypes.rst:2597
#, fuzzy
msgid ""
"Return a bytes or bytearray object which is the concatenation of the binary "
"data sequences in *iterable*.  A :exc:`TypeError` will be raised if there "
"are any values in *iterable* that are not :term:`bytes-like objects <bytes-"
"like object>`, including :class:`str` objects.  The separator between "
"elements is the contents of the bytes or bytearray object providing this "
"method."
msgstr ""
"Restituisce un oggetto byte o bytearray che è la concatenazione delle "
"sequenze di dati binari in *iterable*.  R:exc:`TypeError` sarà sollevato se "
"ci sono valori in *iterable* che non sono :termine:`bytes-like objects "
"<bytes-like object>`, incluso :class:`str` objects.  Il separatore tra gli "
"elementi è il contenuto dell'oggetto byte o bytearray che fornisce questo "
"metodo.</bytes-like>"

#: ../Doc/library/stdtypes.rst:2608
#, fuzzy
msgid ""
"This static method returns a translation table usable for :meth:`bytes."
"translate` that will map each character in *from* into the character at the "
"same position in *to*; *from* and *to* must both be :term:`bytes-like "
"objects <bytes-like object>` and have the same length."
msgstr ""
"Questo metodo statico restituisce una tabella di traduzione utilizzabile "
"per :meth:`bytes.translate` che mapperà ogni carattere in *from* nel "
"carattere nella stessa posizione in *to*; *from* e *to* devono essere "
"entrambi :term:`bytes-like objects <bytes-like object>` e avere la stessa "
"lunghezza.</bytes-like>"

#: ../Doc/library/stdtypes.rst:2619
#, fuzzy
msgid ""
"Split the sequence at the first occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself or its "
"bytearray copy, and the part after the separator. If the separator is not "
"found, return a 3-tuple containing a copy of the original sequence, followed "
"by two empty bytes or bytearray objects."
msgstr ""
"Dividere la sequenza alla prima occorrenza di *sep*, e restituire una 3-"
"tuplice contenente la parte prima del separatore, il separatore stesso o la "
"sua copia bytearray, e la parte dopo il separatore. Se il separatore non "
"viene trovato, restituire una 3-tuple contenente una copia della sequenza "
"originale, seguita da due byte o oggetti bytearray vuoti."

#: ../Doc/library/stdtypes.rst:2626 ../Doc/library/stdtypes.rst:2683
#, fuzzy
msgid "The separator to search for may be any :term:`bytes-like object`."
msgstr ""
"Il separatore da cercare può essere qualsiasi :termine:`bytes-like object`."

#: ../Doc/library/stdtypes.rst:2632
#, fuzzy
msgid ""
"Return a copy of the sequence with all occurrences of subsequence *old* "
"replaced by *new*.  If the optional argument *count* is given, only the "
"first *count* occurrences are replaced."
msgstr ""
"Restituire una copia della sequenza con tutte le occorrenze della sequenza "
"*vecchio* sostituito da *nuovo*.  Se viene fornito l'argomento opzionale "
"*contare*, vengono sostituite solo le prime occorrenze *contare*."

#: ../Doc/library/stdtypes.rst:2636
#, fuzzy
msgid ""
"The subsequence to search for and its replacement may be any :term:`bytes-"
"like object`."
msgstr ""
"La sequenza da cercare e la sua sostituzione può essere qualsiasi: termine:"
"`bytes-like object`."

#: ../Doc/library/stdtypes.rst:2641 ../Doc/library/stdtypes.rst:2734
#: ../Doc/library/stdtypes.rst:2748 ../Doc/library/stdtypes.rst:2772
#: ../Doc/library/stdtypes.rst:2786 ../Doc/library/stdtypes.rst:2821
#: ../Doc/library/stdtypes.rst:2891 ../Doc/library/stdtypes.rst:2909
#: ../Doc/library/stdtypes.rst:2937 ../Doc/library/stdtypes.rst:3076
#: ../Doc/library/stdtypes.rst:3131 ../Doc/library/stdtypes.rst:3174
#: ../Doc/library/stdtypes.rst:3195 ../Doc/library/stdtypes.rst:3217
#: ../Doc/library/stdtypes.rst:3419
#, fuzzy
msgid ""
"The bytearray version of this method does *not* operate in place - it always "
"produces a new object, even if no changes were made."
msgstr ""
"La versione bytearray di questo metodo *non* funziona sul posto - produce "
"sempre un nuovo oggetto, anche se non sono state apportate modifiche."

#: ../Doc/library/stdtypes.rst:2648
#, fuzzy
msgid ""
"Return the highest index in the sequence where the subsequence *sub* is "
"found, such that *sub* is contained within ``s[start:end]``.  Optional "
"arguments *start* and *end* are interpreted as in slice notation. Return "
"``-1`` on failure."
msgstr ""
"Restituisce l'indice più alto nella sequenza in cui si trova la sequenza "
"*sub*, in modo che *sub* sia contenuto all'interno di ``s[start:end]``.  Gli "
"argomenti facoltativi *start* e *end* sono interpretati come una notazione "
"di fetta. Ritorno ``-1```` in caso di guasto."

#: ../Doc/library/stdtypes.rst:2663
#, fuzzy
msgid ""
"Like :meth:`~bytes.rfind` but raises :exc:`ValueError` when the subsequence "
"*sub* is not found."
msgstr ""
"Come :meth:`~bytes.rfind` ma solleva :exc:`ValueError` quando la sequenza "
"*sub* non viene trovata."

#: ../Doc/library/stdtypes.rst:2676
#, fuzzy
msgid ""
"Split the sequence at the last occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself or its "
"bytearray copy, and the part after the separator. If the separator is not "
"found, return a 3-tuple containing two empty bytes or bytearray objects, "
"followed by a copy of the original sequence."
msgstr ""
"Dividere la sequenza all'ultima occorrenza di *sep*, e restituire una 3-"
"tuplice contenente la parte prima del separatore, il separatore stesso o la "
"sua copia bytearray, e la parte dopo il separatore. Se il separatore non "
"viene trovato, restituire una 3-tuple contenente due byte o oggetti "
"bytearray vuoti, seguita da una copia della sequenza originale."

#: ../Doc/library/stdtypes.rst:2689
#, fuzzy
msgid ""
"Return ``True`` if the binary data starts with the specified *prefix*, "
"otherwise return ``False``.  *prefix* can also be a tuple of prefixes to "
"look for.  With optional *start*, test beginning at that position.  With "
"optional *end*, stop comparing at that position."
msgstr ""
"Restituire ``True``` se i dati binari iniziano con il *prefisso* "
"specificato, altrimenti restituire ``False```.  *prefisso* può anche essere "
"una tupla di prefissi da cercare.  Con *start* opzionale, il test inizia in "
"quella posizione.  Con *fine* opzionale, interrompere il confronto in quella "
"posizione."

#: ../Doc/library/stdtypes.rst:2694
#, fuzzy
msgid "The prefix(es) to search for may be any :term:`bytes-like object`."
msgstr "I prefissi da cercare possono essere: termine:`bytes-like object`."

#: ../Doc/library/stdtypes.rst:2700
#, fuzzy
msgid ""
"Return a copy of the bytes or bytearray object where all bytes occurring in "
"the optional argument *delete* are removed, and the remaining bytes have "
"been mapped through the given translation table, which must be a bytes "
"object of length 256."
msgstr ""
"Restituisce una copia dell'oggetto byte o bytearray dove tutti i byte che si "
"verificano nell'argomento opzionale *cancella* sono stati rimossi, e i byte "
"rimanenti sono stati mappati attraverso la tabella di traduzione data, che "
"deve essere un oggetto byte di lunghezza 256."

#: ../Doc/library/stdtypes.rst:2705
#, fuzzy
msgid ""
"You can use the :func:`bytes.maketrans` method to create a translation table."
msgstr ""
"È possibile utilizzare il metodo :func:`bytes.maketrans` per creare una "
"tabella di traduzione."

#: ../Doc/library/stdtypes.rst:2708
#, fuzzy
msgid ""
"Set the *table* argument to ``None`` for translations that only delete "
"characters::"
msgstr ""
"Impostare l'argomento *tabella* su ```Nessuno``` per traduzioni che "
"cancellano solo i caratteri::"

#: ../Doc/library/stdtypes.rst:2714
#, fuzzy
msgid "*delete* is now supported as a keyword argument."
msgstr "*delete* è ora supportato come argomento per parole chiave."

#: ../Doc/library/stdtypes.rst:2718
#, fuzzy
msgid ""
"The following methods on bytes and bytearray objects have default behaviours "
"that assume the use of ASCII compatible binary formats, but can still be "
"used with arbitrary binary data by passing appropriate arguments. Note that "
"all of the bytearray methods in this section do *not* operate in place, and "
"instead produce new objects."
msgstr ""
"I seguenti metodi sugli oggetti byte e bytearray hanno comportamenti "
"predefiniti che presuppongono l'uso di formati binari compatibili con ASCII, "
"ma possono comunque essere utilizzati con dati binari arbitrari passando "
"argomenti appropriati. Si noti che tutti i metodi bytearray di questa "
"sezione *non* operano sul posto e producono invece nuovi oggetti."

#: ../Doc/library/stdtypes.rst:2727
#, fuzzy
msgid ""
"Return a copy of the object centered in a sequence of length *width*. "
"Padding is done using the specified *fillbyte* (default is an ASCII space). "
"For :class:`bytes` objects, the original sequence is returned if *width* is "
"less than or equal to ``len(s)``."
msgstr ""
"Restituisce una copia dell'oggetto centrato in una sequenza di lunghezza "
"*larghezza*. Il riempimento viene eseguito utilizzando il *fillbyte* "
"specificato (il valore predefinito è uno spazio ASCII). Per gli oggetti :"
"class:`bytes`, la sequenza originale viene restituita se *larghezza* è "
"inferiore o uguale a ``len(s)``."

#: ../Doc/library/stdtypes.rst:2741
#, fuzzy
msgid ""
"Return a copy of the object left justified in a sequence of length *width*. "
"Padding is done using the specified *fillbyte* (default is an ASCII space). "
"For :class:`bytes` objects, the original sequence is returned if *width* is "
"less than or equal to ``len(s)``."
msgstr ""
"Restituisce una copia dell'oggetto lasciato giustificato in una sequenza di "
"lunghezza *larghezza*. Il riempimento viene eseguito utilizzando il "
"*fillbyte* specificato (il valore predefinito è uno spazio ASCII). Per gli "
"oggetti :class:`bytes`, la sequenza originale viene restituita se "
"*larghezza* è inferiore o uguale a ``len(s)``."

#: ../Doc/library/stdtypes.rst:2755
#, fuzzy
msgid ""
"Return a copy of the sequence with specified leading bytes removed.  The "
"*chars* argument is a binary sequence specifying the set of byte values to "
"be removed - the name refers to the fact this method is usually used with "
"ASCII characters.  If omitted or ``None``, the *chars* argument defaults to "
"removing ASCII whitespace.  The *chars* argument is not a prefix; rather, "
"all combinations of its values are stripped::"
msgstr ""
"Restituisce una copia della sequenza con i byte iniziali specificati "
"rimossi.  L'argomento *chars* è una sequenza binaria che specifica l'insieme "
"di valori di byte da rimuovere - il nome si riferisce al fatto che questo "
"metodo è solitamente usato con caratteri ASCII.  Se omesso o ````Nessuno```, "
"l'argomento *carri* è predefinito alla rimozione dello spazio bianco ASCII.  "
"L'argomento *chars* non è un prefisso; piuttosto, tutte le combinazioni dei "
"suoi valori sono eliminate::"

#: ../Doc/library/stdtypes.rst:2767 ../Doc/library/stdtypes.rst:2816
#: ../Doc/library/stdtypes.rst:2886
#, fuzzy
msgid ""
"The binary sequence of byte values to remove may be any :term:`bytes-like "
"object`."
msgstr ""
"La sequenza binaria dei valori dei byte da rimuovere può essere qualsiasi: "
"termine:`bytes-like object`."

#: ../Doc/library/stdtypes.rst:2779
#, fuzzy
msgid ""
"Return a copy of the object right justified in a sequence of length *width*. "
"Padding is done using the specified *fillbyte* (default is an ASCII space). "
"For :class:`bytes` objects, the original sequence is returned if *width* is "
"less than or equal to ``len(s)``."
msgstr ""
"Restituire una copia del diritto oggetto giustificato in una sequenza di "
"lunghezza *larghezza*. Il riempimento viene eseguito utilizzando il "
"*fillbyte* specificato (il valore predefinito è uno spazio ASCII). Per gli "
"oggetti :class:`bytes`, la sequenza originale viene restituita se "
"*larghezza* è inferiore o uguale a ``len(s)``."

#: ../Doc/library/stdtypes.rst:2793
#, fuzzy
msgid ""
"Split the binary sequence into subsequences of the same type, using *sep* as "
"the delimiter string. If *maxsplit* is given, at most *maxsplit* splits are "
"done, the *rightmost* ones.  If *sep* is not specified or ``None``, any "
"subsequence consisting solely of ASCII whitespace is a separator. Except for "
"splitting from the right, :meth:`rsplit` behaves like :meth:`split` which is "
"described in detail below."
msgstr ""
"Dividere la sequenza binaria in sequenze dello stesso tipo, usando *sep* "
"come stringa delimitatrice. Se *maxsplit* è dato, al massimo *maxsplit* "
"spaccate, le spaccate più giuste.  Se *sep* non è specificato o "
"```Nessuno```, qualsiasi sequenza che consiste unicamente di spazi bianchi "
"ASCII è un separatore. Ad eccezione della separazione da destra, :meth:"
"`rsplit` si comporta come :meth:`split` che è descritto in dettaglio qui "
"sotto."

#: ../Doc/library/stdtypes.rst:2804
#, fuzzy
msgid ""
"Return a copy of the sequence with specified trailing bytes removed.  The "
"*chars* argument is a binary sequence specifying the set of byte values to "
"be removed - the name refers to the fact this method is usually used with "
"ASCII characters.  If omitted or ``None``, the *chars* argument defaults to "
"removing ASCII whitespace.  The *chars* argument is not a suffix; rather, "
"all combinations of its values are stripped::"
msgstr ""
"Restituisce una copia della sequenza con i byte di trascinamento specificati "
"rimossi.  L'argomento *chars* è una sequenza binaria che specifica l'insieme "
"di valori di byte da rimuovere - il nome si riferisce al fatto che questo "
"metodo è solitamente usato con caratteri ASCII.  Se omesso o ````Nessuno```, "
"l'argomento *carri* è predefinito alla rimozione dello spazio bianco ASCII.  "
"L'argomento *chars* non è un suffisso; piuttosto, tutte le combinazioni dei "
"suoi valori sono eliminate::"

#: ../Doc/library/stdtypes.rst:2828
#, fuzzy
msgid ""
"Split the binary sequence into subsequences of the same type, using *sep* as "
"the delimiter string. If *maxsplit* is given and non-negative, at most "
"*maxsplit* splits are done (thus, the list will have at most ``maxsplit+1`` "
"elements).  If *maxsplit* is not specified or is ``-1``, then there is no "
"limit on the number of splits (all possible splits are made)."
msgstr ""
"Dividere la sequenza binaria in sequenze dello stesso tipo, usando *sep* "
"come stringa delimitatrice. Se *maxsplit* è dato e non-negativo, al massimo "
"*maxsplit* sono fatte spaccature (quindi, la lista avrà al massimo ``maxsplit"
"+1``` elementi).  Se *maxsplit* non è specificato o è ``-1````, allora non "
"c'è limite al numero di spaccature (tutte le spaccature possibili sono "
"fatte)."

#: ../Doc/library/stdtypes.rst:2834
#, fuzzy
msgid ""
"If *sep* is given, consecutive delimiters are not grouped together and are "
"deemed to delimit empty subsequences (for example, ``b'1,,2'.split(b',')`` "
"returns ``[b'1', b'', b'2']``).  The *sep* argument may consist of a "
"multibyte sequence (for example, ``b'1<>2<>3'.split(b'<>')`` returns "
"``[b'1', b'2', b'3']``). Splitting an empty sequence with a specified "
"separator returns ``[b'']`` or ``[bytearray(b'')]`` depending on the type of "
"object being split.  The *sep* argument may be any :term:`bytes-like object`."
msgstr ""
"Se *sep* è dato, i delimitatori consecutivi non sono raggruppati insieme e "
"si ritiene che delimitino le sequenze vuote (per esempio, ``b'1,,2'."
"split(b',',')```` restituisce ``[b'1', b'''', b'2']``).  L'argomento *sep* "
"può consistere in una sequenza multibyte (per esempio, ``b'1<>2<>2<>3'."
"split(b'<>')``` restituisce ``[b'1', b'2', b'3']``). La divisione di una "
"sequenza vuota con un separatore specificato restituisce ```[b'''']`` o "
"``[bytearray(b''')]`` a seconda del tipo di oggetto da dividere.  "
"L'argomento *sep* può essere qualsiasi :termine:`bytes-like object`."

#: ../Doc/library/stdtypes.rst:2852
#, fuzzy
msgid ""
"If *sep* is not specified or is ``None``, a different splitting algorithm is "
"applied: runs of consecutive ASCII whitespace are regarded as a single "
"separator, and the result will contain no empty strings at the start or end "
"if the sequence has leading or trailing whitespace.  Consequently, splitting "
"an empty sequence or a sequence consisting solely of ASCII whitespace "
"without a specified separator returns ``[]``."
msgstr ""
"Se *sep* non è specificato o non è ``Nessuno```, viene applicato un diverso "
"algoritmo di divisione: le esecuzioni di spazi bianchi ASCII consecutivi "
"sono considerate come un singolo separatore, e il risultato non conterrà "
"stringhe vuote all'inizio o alla fine se la sequenza ha spazi bianchi "
"iniziali o finali.  Di conseguenza, dividendo una sequenza vuota o una "
"sequenza che consiste esclusivamente di spazi bianchi ASCII senza un "
"separatore specificato, si ottiene ```[]````."

#: ../Doc/library/stdtypes.rst:2873
#, fuzzy
msgid ""
"Return a copy of the sequence with specified leading and trailing bytes "
"removed. The *chars* argument is a binary sequence specifying the set of "
"byte values to be removed - the name refers to the fact this method is "
"usually used with ASCII characters.  If omitted or ``None``, the *chars* "
"argument defaults to removing ASCII whitespace. The *chars* argument is not "
"a prefix or suffix; rather, all combinations of its values are stripped::"
msgstr ""
"Restituire una copia della sequenza con i byte iniziali e finali specificati "
"rimossi. L'argomento *chars* è una sequenza binaria che specifica l'insieme "
"di valori di byte da rimuovere - il nome si riferisce al fatto che questo "
"metodo è solitamente usato con caratteri ASCII.  Se omesso o ````Nessuno```, "
"l'argomento *carri* è predefinito alla rimozione dello spazio bianco ASCII. "
"L'argomento *chars* non è un prefisso o un suffisso; piuttosto, tutte le "
"combinazioni dei suoi valori sono eliminate::"

#: ../Doc/library/stdtypes.rst:2895
#, fuzzy
msgid ""
"The following methods on bytes and bytearray objects assume the use of ASCII "
"compatible binary formats and should not be applied to arbitrary binary "
"data. Note that all of the bytearray methods in this section do *not* "
"operate in place, and instead produce new objects."
msgstr ""
"I seguenti metodi sugli oggetti byte e bytearray presuppongono l'uso di "
"formati binari compatibili ASCII e non dovrebbero essere applicati a dati "
"binari arbitrari. Si noti che tutti i metodi bytearray di questa sezione "
"*non* operano sul posto e producono invece nuovi oggetti."

#: ../Doc/library/stdtypes.rst:2903
#, fuzzy
msgid ""
"Return a copy of the sequence with each byte interpreted as an ASCII "
"character, and the first byte capitalized and the rest lowercased. Non-ASCII "
"byte values are passed through unchanged."
msgstr ""
"Restituire una copia della sequenza con ogni byte interpretato come un "
"carattere ASCII, e il primo byte in maiuscolo e il resto in minuscolo. I "
"valori dei byte non ASCII vengono fatti passare invariati."

#: ../Doc/library/stdtypes.rst:2916
#, fuzzy
msgid ""
"Return a copy of the sequence where all ASCII tab characters are replaced by "
"one or more ASCII spaces, depending on the current column and the given tab "
"size.  Tab positions occur every *tabsize* bytes (default is 8, giving tab "
"positions at columns 0, 8, 16 and so on).  To expand the sequence, the "
"current column is set to zero and the sequence is examined byte by byte.  If "
"the byte is an ASCII tab character (``b'\\t'``), one or more space "
"characters are inserted in the result until the current column is equal to "
"the next tab position. (The tab character itself is not copied.)  If the "
"current byte is an ASCII newline (``b'\\n'``) or carriage return "
"(``b'\\r'``), it is copied and the current column is reset to zero.  Any "
"other byte value is copied unchanged and the current column is incremented "
"by one regardless of how the byte value is represented when printed::"
msgstr ""
"Restituisce una copia della sequenza in cui tutti i caratteri della scheda "
"ASCII sono sostituiti da uno o più spazi ASCII, a seconda della colonna "
"corrente e della dimensione della scheda data.  Le posizioni delle schede si "
"verificano ogni byte *tabsize* (il valore predefinito è 8, dando posizioni "
"delle schede alle colonne 0, 8, 16 e così via).  Per espandere la sequenza, "
"la colonna corrente viene impostata a zero e la sequenza viene esaminata "
"byte per byte.  Se il byte è un carattere di tabulazione ASCII "
"(``b'\\t'```), uno o più caratteri di spazio sono inseriti nel risultato "
"fino a quando la colonna corrente è uguale alla posizione della scheda "
"successiva. Se il byte corrente è una newline ASCII (``b'\\n'\\n'``) o un "
"ritorno a capo (``b'\\r'``), viene copiato e la colonna corrente viene "
"azzerata.  Qualsiasi altro valore di byte viene copiato invariato e la "
"colonna corrente viene incrementata di uno, indipendentemente da come viene "
"rappresentato il valore di byte quando viene stampato::"

#: ../Doc/library/stdtypes.rst:2944
#, fuzzy
msgid ""
"Return true if all bytes in the sequence are alphabetical ASCII characters "
"or ASCII decimal digits and the sequence is not empty, false otherwise. "
"Alphabetic ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'``. ASCII decimal "
"digits are those byte values in the sequence ``b'0123456789'``."
msgstr ""
"Restituisce vero se tutti i byte della sequenza sono caratteri alfabetici "
"ASCII o cifre decimali ASCII e la sequenza non è vuota, altrimenti false. I "
"caratteri alfabetici ASCII sono i valori dei byte nella sequenza "
"```b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'``. Le cifre "
"decimali ASCII sono i valori di byte nella sequenza ````b'0123456789```."

#: ../Doc/library/stdtypes.rst:2961
#, fuzzy
msgid ""
"Return true if all bytes in the sequence are alphabetic ASCII characters and "
"the sequence is not empty, false otherwise.  Alphabetic ASCII characters are "
"those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'``."
msgstr ""
"Restituisce vero se tutti i byte della sequenza sono caratteri alfabetici "
"ASCII e la sequenza non è vuota, altrimenti false.  I caratteri alfabetici "
"ASCII sono i valori dei byte nella sequenza "
"```b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'``."

#: ../Doc/library/stdtypes.rst:2977
#, fuzzy
msgid ""
"Return true if the sequence is empty or all bytes in the sequence are ASCII, "
"false otherwise. ASCII bytes are in the range 0-0x7F."
msgstr ""
"Restituisce vero se la sequenza è vuota o tutti i byte della sequenza sono "
"ASCII, altrimenti false. I byte ASCII sono nell'intervallo 0-0x7F."

#: ../Doc/library/stdtypes.rst:2987
#, fuzzy
msgid ""
"Return true if all bytes in the sequence are ASCII decimal digits and the "
"sequence is not empty, false otherwise. ASCII decimal digits are those byte "
"values in the sequence ``b'0123456789'``."
msgstr ""
"Restituisce vero se tutti i byte della sequenza sono cifre decimali ASCII e "
"la sequenza non è vuota, altrimenti falso. Le cifre decimali ASCII sono i "
"valori di byte nella sequenza ````b'0123456789```."

#: ../Doc/library/stdtypes.rst:3002
#, fuzzy
msgid ""
"Return true if there is at least one lowercase ASCII character in the "
"sequence and no uppercase ASCII characters, false otherwise."
msgstr ""
"Restituisce vero se nella sequenza è presente almeno un carattere ASCII "
"minuscolo e nessun carattere ASCII maiuscolo, altrimenti falso."

#: ../Doc/library/stdtypes.rst:3012 ../Doc/library/stdtypes.rst:3054
#: ../Doc/library/stdtypes.rst:3070 ../Doc/library/stdtypes.rst:3120
#: ../Doc/library/stdtypes.rst:3189
#, fuzzy
msgid ""
"Lowercase ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyz'``. Uppercase ASCII characters are those byte "
"values in the sequence ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``."
msgstr ""
"I caratteri ASCII minuscoli sono i valori di byte nella sequenza "
"````b'abcdefghijklmnopqrstuvwxyz'```. I caratteri ASCII maiuscoli sono i "
"valori di byte nella sequenza ```b'ABCDEFGHIJKLMNOPQQRSTUVWWXYZ'``."

#: ../Doc/library/stdtypes.rst:3020
#, fuzzy
msgid ""
"Return true if all bytes in the sequence are ASCII whitespace and the "
"sequence is not empty, false otherwise.  ASCII whitespace characters are "
"those byte values in the sequence ``b' \\t\\n\\r\\x0b\\f'`` (space, tab, "
"newline, carriage return, vertical tab, form feed)."
msgstr ""
"Restituisce vero se tutti i byte della sequenza sono spazi bianchi ASCII e "
"la sequenza non è vuota, altrimenti falso.  I caratteri degli spazi bianchi "
"ASCII sono quei valori di byte nella sequenza ``b' \\n\\n\\n\\r\\x0b\\x0b"
"\\f'``` (spazio, tab, newline, ritorno a capo, tab verticale, form feed)."

#: ../Doc/library/stdtypes.rst:3029
#, fuzzy
msgid ""
"Return true if the sequence is ASCII titlecase and the sequence is not "
"empty, false otherwise. See :meth:`bytes.title` for more details on the "
"definition of \"titlecase\"."
msgstr ""
"Restituisce vero se la sequenza è una titlecase ASCII e la sequenza non è "
"vuota, altrimenti falso. Vedere :meth:`bytes.title` per maggiori dettagli "
"sulla definizione di \"titlecase\"."

#: ../Doc/library/stdtypes.rst:3044
#, fuzzy
msgid ""
"Return true if there is at least one uppercase alphabetic ASCII character in "
"the sequence and no lowercase ASCII characters, false otherwise."
msgstr ""
"Ritorna vero se c'è almeno un carattere ASCII alfabetico maiuscolo nella "
"sequenza e nessun carattere ASCII minuscolo, altrimenti falso."

#: ../Doc/library/stdtypes.rst:3062
#, fuzzy
msgid ""
"Return a copy of the sequence with all the uppercase ASCII characters "
"converted to their corresponding lowercase counterpart."
msgstr ""
"Restituisce una copia della sequenza con tutti i caratteri ASCII maiuscoli "
"convertiti nella corrispondente controparte minuscola."

#: ../Doc/library/stdtypes.rst:3087
#, fuzzy
msgid ""
"Return a list of the lines in the binary sequence, breaking at ASCII line "
"boundaries. This method uses the :term:`universal newlines` approach to "
"splitting lines. Line breaks are not included in the resulting list unless "
"*keepends* is given and true."
msgstr ""
"Restituisce un elenco delle linee nella sequenza binaria, che si interrompe "
"ai confini della linea ASCII. Questo metodo usa il termine: ::`universal "
"newlines` approccio alle linee di divisione. Le interruzioni di riga non "
"sono incluse nell'elenco risultante a meno che non sia indicato e vero."

#: ../Doc/library/stdtypes.rst:3099
#, fuzzy
msgid ""
"Unlike :meth:`~bytes.split` when a delimiter string *sep* is given, this "
"method returns an empty list for the empty string, and a terminal line break "
"does not result in an extra line::"
msgstr ""
"A differenza di :meth:`~bytes.split` quando viene data una stringa "
"delimitatrice *sep*, questo metodo restituisce una lista vuota per la "
"stringa vuota, e un'interruzione di linea terminale non si traduce in una "
"riga extra::"

#: ../Doc/library/stdtypes.rst:3112
#, fuzzy
msgid ""
"Return a copy of the sequence with all the lowercase ASCII characters "
"converted to their corresponding uppercase counterpart and vice-versa."
msgstr ""
"Restituisce una copia della sequenza con tutti i caratteri ASCII minuscoli "
"convertiti nella corrispondente controparte maiuscola e viceversa."

#: ../Doc/library/stdtypes.rst:3124
#, fuzzy
msgid ""
"Unlike :func:`str.swapcase()`, it is always the case that ``bin.swapcase()."
"swapcase() == bin`` for the binary versions. Case conversions are "
"symmetrical in ASCII, even though that is not generally true for arbitrary "
"Unicode code points."
msgstr ""
"A differenza di :func:`str.swapcase()`, è sempre il caso che ``bin."
"swapcase().swapcase() == bin``` per le versioni binarie. Le conversioni dei "
"casi sono simmetriche in ASCII, anche se questo non è generalmente vero per "
"punti di codice Unicode arbitrari."

#: ../Doc/library/stdtypes.rst:3138
#, fuzzy
msgid ""
"Return a titlecased version of the binary sequence where words start with an "
"uppercase ASCII character and the remaining characters are lowercase. "
"Uncased byte values are left unmodified."
msgstr ""
"Restituisce una versione basata sul titolo della sequenza binaria in cui le "
"parole iniziano con un carattere ASCII maiuscolo e i caratteri rimanenti "
"sono in minuscolo. I valori di byte non incassati non vengono lasciati "
"invariati."

#: ../Doc/library/stdtypes.rst:3147
#, fuzzy
msgid ""
"Lowercase ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyz'``. Uppercase ASCII characters are those byte "
"values in the sequence ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``. All other byte "
"values are uncased."
msgstr ""
"I caratteri ASCII minuscoli sono i valori di byte nella sequenza "
"````b'abcdefghijklmnopqrstuvwxyz'```. I caratteri ASCII maiuscoli sono i "
"valori di byte nella sequenza ```b'ABCDEFGHIJKLMNOPQQRSTUVWWXYZ'``. Tutti "
"gli altri valori di byte non sono basati."

#: ../Doc/library/stdtypes.rst:3181
#, fuzzy
msgid ""
"Return a copy of the sequence with all the lowercase ASCII characters "
"converted to their corresponding uppercase counterpart."
msgstr ""
"Restituisce una copia della sequenza con tutti i caratteri ASCII minuscoli "
"convertiti nella corrispondente controparte maiuscola."

#: ../Doc/library/stdtypes.rst:3202
#, fuzzy
msgid ""
"Return a copy of the sequence left filled with ASCII ``b'0'`` digits to make "
"a sequence of length *width*. A leading sign prefix (``b'+'``/ ``b'-'``) is "
"handled by inserting the padding *after* the sign character rather than "
"before. For :class:`bytes` objects, the original sequence is returned if "
"*width* is less than or equal to ``len(seq)``."
msgstr ""
"Restituire una copia della sequenza rimasta riempita con le cifre ASCII "
"```b'0'0```` per fare una sequenza di lunghezza *larghezza*. Un prefisso del "
"segno principale (```b'+'+'```/ ```b'-'-'```) è gestito inserendo "
"l'imbottitura *dopo* il carattere del segno piuttosto che prima. Per gli "
"oggetti :class:`bytes`, la sequenza originale viene restituita se "
"*larghezza* è inferiore o uguale a ``len(seq)``."

#: ../Doc/library/stdtypes.rst:3224
#, fuzzy
msgid "``printf``-style Bytes Formatting"
msgstr "Formattazione dei byte in stile ``printf``-style Bytes Formattazione"

#: ../Doc/library/stdtypes.rst:3241
#, fuzzy
msgid ""
"The formatting operations described here exhibit a variety of quirks that "
"lead to a number of common errors (such as failing to display tuples and "
"dictionaries correctly).  If the value being printed may be a tuple or "
"dictionary, wrap it in a tuple."
msgstr ""
"Le operazioni di formattazione qui descritte mostrano una varietà di "
"stranezze che portano ad una serie di errori comuni (come la mancata "
"visualizzazione corretta di tuple e dizionari).  Se il valore da stampare "
"può essere una tupla o un dizionario, avvolgerlo in una tupla."

#: ../Doc/library/stdtypes.rst:3246
#, fuzzy
msgid ""
"Bytes objects (``bytes``/``bytearray``) have one unique built-in operation: "
"the ``%`` operator (modulo). This is also known as the bytes *formatting* or "
"*interpolation* operator. Given ``format % values`` (where *format* is a "
"bytes object), ``%`` conversion specifications in *format* are replaced with "
"zero or more elements of *values*. The effect is similar to using the :c:"
"func:`sprintf` in the C language."
msgstr ""
"Gli oggetti Bytes (``bytes``/`````bytearray```) hanno un'unica operazione "
"integrata: il ``%``` operatore (modulo). Questo è noto anche come operatore "
"di *formattazione* o *interpolazione* dei byte. Dato ``formato %``` (dove "
"*formato* è un oggetto byte), le specifiche di conversione ``%``` in "
"*formato* sono sostituite da zero o più elementi di *valori*. L'effetto è "
"simile all'uso di :c:func:`sprintf` nel linguaggio C."

#: ../Doc/library/stdtypes.rst:3253
#, fuzzy
msgid ""
"If *format* requires a single argument, *values* may be a single non-tuple "
"object. [5]_  Otherwise, *values* must be a tuple with exactly the number of "
"items specified by the format bytes object, or a single mapping object (for "
"example, a dictionary)."
msgstr ""
"Se *formato* richiede un singolo argomento, *valori* può essere un singolo "
"oggetto non triplo. 5]_ Altrimenti, i *valori* devono essere una tupla con "
"esattamente il numero di elementi specificati dall'oggetto byte di formato, "
"o un singolo oggetto di mappatura (per esempio, un dizionario)."

#: ../Doc/library/stdtypes.rst:3287
#, fuzzy
msgid ""
"When the right argument is a dictionary (or other mapping type), then the "
"formats in the bytes object *must* include a parenthesised mapping key into "
"that dictionary inserted immediately after the ``'%'`` character. The "
"mapping key selects the value to be formatted from the mapping.  For example:"
msgstr ""
"Quando l'argomento giusto è un dizionario (o altro tipo di mappatura), "
"allora i formati nell'oggetto byte *devono includere una chiave di mappatura "
"parentesizzata in quel dizionario inserito immediatamente dopo il "
"``'%'%'%'`` carattere. Il tasto di mappatura seleziona il valore da "
"formattare dalla mappatura.  Per esempio:"

#: ../Doc/library/stdtypes.rst:3361
#, fuzzy
msgid "Single byte (accepts integer or single byte objects)."
msgstr "Byte singolo (accetta oggetti interi o byte singolo)."

#: ../Doc/library/stdtypes.rst:3364
msgid "``'b'``"
msgstr "``’b’``"

#: ../Doc/library/stdtypes.rst:3364
#, fuzzy
msgid ""
"Bytes (any object that follows the :ref:`buffer protocol <bufferobjects>` or "
"has :meth:`__bytes__`)."
msgstr ""
"Bytes (qualsiasi oggetto che segue il protocollo :ref:`buffer "
"<bufferobjects>`o ha :meth:`__bytes__`).</bufferobjects>"

#: ../Doc/library/stdtypes.rst:3368
msgid ""
"``'s'`` is an alias for ``'b'`` and should only be used for Python2/3 code "
"bases."
msgstr ""
"``’s’`` è un alias per ``’b’`` e dovrebbe essere usato solo per code base "
"Python2/3."

#: ../Doc/library/stdtypes.rst:3371
#, fuzzy
msgid ""
"Bytes (converts any Python object using ``repr(obj)."
"encode('ascii','backslashreplace)``)."
msgstr ""
"Bytes (converte qualsiasi oggetto Python usando ``repr(obj)."
"encode('ascii','backslashreplace)```)."

#: ../Doc/library/stdtypes.rst:3374
#, fuzzy
msgid ""
"``'r'`` is an alias for ``'a'`` and should only be used for Python2/3 code "
"bases."
msgstr ""
"``'r'````` è un alias per ``'a'```` e dovrebbe essere usato solo per basi di "
"codice Python2/3."

#: ../Doc/library/stdtypes.rst:3374
msgid "\\(7)"
msgstr "\\(7)"

#: ../Doc/library/stdtypes.rst:3409
#, fuzzy
msgid "``b'%s'`` is deprecated, but will not be removed during the 3.x series."
msgstr "```b'%s's``` è deprecato, ma non sarà rimosso durante la serie 3.x."

#: ../Doc/library/stdtypes.rst:3412
#, fuzzy
msgid "``b'%r'`` is deprecated, but will not be removed during the 3.x series."
msgstr "```b'%r'``` è deprecato, ma non sarà rimosso durante la serie 3.x."

#: ../Doc/library/stdtypes.rst:3424
#, fuzzy
msgid ":pep:`461` - Adding % formatting to bytes and bytearray"
msgstr ":pep:`461` - Aggiunta di formattazione % ai byte e bytearray"

#: ../Doc/library/stdtypes.rst:3431
#, fuzzy
msgid "Memory Views"
msgstr "Visualizzazioni di memoria"

#: ../Doc/library/stdtypes.rst:3433
#, fuzzy
msgid ""
":class:`memoryview` objects allow Python code to access the internal data of "
"an object that supports the :ref:`buffer protocol <bufferobjects>` without "
"copying."
msgstr ""
"class:`memoryview` gli oggetti permettono al codice Python di accedere ai "
"dati interni di un oggetto che supporta il protocollo :ref:`buffer "
"<bufferobjects>` senza copiare.</bufferobjects>"

#: ../Doc/library/stdtypes.rst:3439
#, fuzzy
msgid ""
"Create a :class:`memoryview` that references *obj*.  *obj* must support the "
"buffer protocol.  Built-in objects that support the buffer protocol include :"
"class:`bytes` and :class:`bytearray`."
msgstr ""
"Creare una :class:`memoryview` che fa riferimento a *obj*.  *obj* deve "
"supportare il protocollo buffer.  Gli oggetti incorporati che supportano il "
"protocollo buffer includono :class:`bytes` e :class:`bytearray`."

#: ../Doc/library/stdtypes.rst:3443
#, fuzzy
msgid ""
"A :class:`memoryview` has the notion of an *element*, which is the atomic "
"memory unit handled by the originating object *obj*.  For many simple types "
"such as :class:`bytes` and :class:`bytearray`, an element is a single byte, "
"but other types such as :class:`array.array` may have bigger elements."
msgstr ""
"A :class:`memoryview` ha la nozione di *elemento*, che è l'unità di memoria "
"atomica gestita dall'oggetto originario *obj*.  Per molti tipi semplici "
"come :class:`bytes` e :class:`bytearray`, un elemento è un singolo byte, ma "
"altri tipi come :class:`array.array` possono avere elementi più grandi."

#: ../Doc/library/stdtypes.rst:3449
#, fuzzy
msgid ""
"``len(view)`` is equal to the length of :class:`~memoryview.tolist`. If "
"``view.ndim = 0``, the length is 1. If ``view.ndim = 1``, the length is "
"equal to the number of elements in the view. For higher dimensions, the "
"length is equal to the length of the nested list representation of the view. "
"The :class:`~memoryview.itemsize` attribute will give you the number of "
"bytes in a single element."
msgstr ""
"``len(view)```` è uguale alla lunghezza di :class:`~memoryview.tolist`. Se "
"``view.ndim = 0```, la lunghezza è 1. Se ``view.ndim = 1```, la lunghezza è "
"uguale al numero di elementi nella vista. Per dimensioni superiori, la "
"lunghezza è uguale alla lunghezza della rappresentazione della vista nella "
"lista annidata. L'attributo :class:`~memoryview.itemsize` vi darà il numero "
"di byte in un singolo elemento."

#: ../Doc/library/stdtypes.rst:3456
#, fuzzy
msgid ""
"A :class:`memoryview` supports slicing and indexing to expose its data. One-"
"dimensional slicing will result in a subview::"
msgstr ""
"A :class:`memoryview` supporta il taglio e l'indicizzazione per esporre i "
"suoi dati. L'affettatura monodimensionale si tradurrà in una sotto-vista::"

#: ../Doc/library/stdtypes.rst:3469
#, fuzzy
msgid ""
"If :class:`~memoryview.format` is one of the native format specifiers from "
"the :mod:`struct` module, indexing with an integer or a tuple of integers is "
"also supported and returns a single *element* with the correct type.  One-"
"dimensional memoryviews can be indexed with an integer or a one-integer "
"tuple.  Multi-dimensional memoryviews can be indexed with tuples of exactly "
"*ndim* integers where *ndim* is the number of dimensions.  Zero-dimensional "
"memoryviews can be indexed with the empty tuple."
msgstr ""
"Se :class:`~memoryview.format` è uno dei prescrittori di formato nativi del "
"modulo :mod:`~memoryview.format`, viene supportata anche l'indicizzazione "
"con un intero o una tupla di interi e restituisce un singolo *elemento* con "
"il tipo corretto.  Le memorie monodimensionali possono essere indicizzate "
"con una tupla intera o una tupla intera.  Le memorie multidimensionali "
"possono essere indicizzate con tuple di *ndim* interi, dove *ndim* è il "
"numero di dimensioni.  Le viste di memoria a dimensione zero possono essere "
"indicizzate con la tupla vuota."

#: ../Doc/library/stdtypes.rst:3478
msgid "Here is an example with a non-byte format::"
msgstr "Ecco un esempio con un formato non byte::"

#: ../Doc/library/stdtypes.rst:3490
#, fuzzy
msgid ""
"If the underlying object is writable, the memoryview supports one-"
"dimensional slice assignment. Resizing is not allowed::"
msgstr ""
"Se l'oggetto sottostante è scrivibile, la vista di memoria supporta "
"l'assegnazione di sezioni monodimensionali. Il ridimensionamento non è "
"consentito::"

#: ../Doc/library/stdtypes.rst:3511
#, fuzzy
msgid ""
"One-dimensional memoryviews of hashable (read-only) types with formats 'B', "
"'b' or 'c' are also hashable. The hash is defined as ``hash(m) == hash(m."
"tobytes())``::"
msgstr ""
"Le memorie unidimensionali di tipi hashable (di sola lettura) con formati "
"'B', 'b' o 'c' sono anch'esse hashable. L'hash è definito come ``hash(m) == "
"hash(m.tobytes())``::"

#: ../Doc/library/stdtypes.rst:3523
#, fuzzy
msgid ""
"One-dimensional memoryviews can now be sliced. One-dimensional memoryviews "
"with formats 'B', 'b' or 'c' are now hashable."
msgstr ""
"Le viste di memoria monodimensionali possono ora essere tagliate. Le memorie "
"monodimensionali con i formati 'B', 'b' o 'c' sono ora hashable."

#: ../Doc/library/stdtypes.rst:3527
#, fuzzy
msgid ""
"memoryview is now registered automatically with :class:`collections.abc."
"Sequence`"
msgstr ""
"memoryview è ora registrato automaticamente con :class:`collections.abc."
"Sequence`"

#: ../Doc/library/stdtypes.rst:3531
#, fuzzy
msgid "memoryviews can now be indexed with tuple of integers."
msgstr ""
"le viste di memoria possono ora essere indicizzate con una tupla di numeri "
"interi."

#: ../Doc/library/stdtypes.rst:3534
msgid ":class:`memoryview` has several methods:"
msgstr "class:class:`memoryview` ha diversi metodi:"

#: ../Doc/library/stdtypes.rst:3538
#, fuzzy
msgid ""
"A memoryview and a :pep:`3118` exporter are equal if their shapes are "
"equivalent and if all corresponding values are equal when the operands' "
"respective format codes are interpreted using :mod:`struct` syntax."
msgstr ""
"Un memoryview e un esportatore :pep:`3118` sono uguali se le loro forme sono "
"equivalenti e se tutti i valori corrispondenti sono uguali quando i "
"rispettivi codici di formato degli operandi sono interpretati usando la "
"sintassi :mod:`struct`."

#: ../Doc/library/stdtypes.rst:3542
#, fuzzy
msgid ""
"For the subset of :mod:`struct` format strings currently supported by :meth:"
"`tolist`, ``v`` and ``w`` are equal if ``v.tolist() == w.tolist()``::"
msgstr ""
"Per il sottoinsieme di :mod:`struct` formato stringhe attualmente supportate "
"da :meth:`tolist`, ``v``` e ``w```` sono uguali se ``v.tolist() == w."
"tolist()``::"

#: ../Doc/library/stdtypes.rst:3561
#, fuzzy
msgid ""
"If either format string is not supported by the :mod:`struct` module, then "
"the objects will always compare as unequal (even if the format strings and "
"buffer contents are identical)::"
msgstr ""
"Se una delle due stringhe di formato non è supportata dal modulo :mod:"
"`struct`, allora gli oggetti verranno sempre confrontati come disuguali "
"(anche se le stringhe di formato e il contenuto del buffer sono identici)::"

#: ../Doc/library/stdtypes.rst:3577
#, fuzzy
msgid ""
"Note that, as with floating point numbers, ``v is w`` does *not* imply ``v "
"== w`` for memoryview objects."
msgstr ""
"Si noti che, come per i numeri in virgola mobile, ``v è w```` non implica "
"``v ==== w``` per gli oggetti memoryview."

#: ../Doc/library/stdtypes.rst:3580
#, fuzzy
msgid ""
"Previous versions compared the raw memory disregarding the item format and "
"the logical array structure."
msgstr ""
"Le versioni precedenti hanno confrontato la memoria grezza senza considerare "
"il formato dell'elemento e la struttura logica dell'array."

#: ../Doc/library/stdtypes.rst:3586
#, fuzzy
msgid ""
"Return the data in the buffer as a bytestring.  This is equivalent to "
"calling the :class:`bytes` constructor on the memoryview. ::"
msgstr ""
"Restituire i dati nel buffer come bytestring.  Questo equivale a chiamare il "
"costruttore :class:`bytes` sul memoryview. :. ::"

#: ../Doc/library/stdtypes.rst:3595
#, fuzzy
msgid ""
"For non-contiguous arrays the result is equal to the flattened list "
"representation with all elements converted to bytes. :meth:`tobytes` "
"supports all format strings, including those that are not in :mod:`struct` "
"module syntax."
msgstr ""
"Per gli array non contigui il risultato è uguale alla rappresentazione della "
"lista appiattita con tutti gli elementi convertiti in byte. :meth:`tobytes` "
"supporta tutte le stringhe di formato, incluse quelle che non sono in :mod:"
"`struct` module syntax."

#: ../Doc/library/stdtypes.rst:3602
#, fuzzy
msgid ""
"Return a string object containing two hexadecimal digits for each byte in "
"the buffer. ::"
msgstr ""
"Restituisce un oggetto stringa contenente due cifre esadecimali per ogni "
"byte nel buffer. ::"

#: ../Doc/library/stdtypes.rst:3613
msgid "Return the data in the buffer as a list of elements. ::"
msgstr "Restituisce i dati nel buffer come elenco di elementi. ::"

#: ../Doc/library/stdtypes.rst:3623
#, fuzzy
msgid ""
":meth:`tolist` now supports all single character native formats in :mod:"
"`struct` module syntax as well as multi-dimensional representations."
msgstr ""
":meth:`tolist` ora supporta tutti i formati nativi a carattere singolo in :"
"mod:`struct` module syntax così come le rappresentazioni multi-dimensionali."

#: ../Doc/library/stdtypes.rst:3630
#, fuzzy
msgid ""
"Release the underlying buffer exposed by the memoryview object.  Many "
"objects take special actions when a view is held on them (for example, a :"
"class:`bytearray` would temporarily forbid resizing); therefore, calling "
"release() is handy to remove these restrictions (and free any dangling "
"resources) as soon as possible."
msgstr ""
"Rilasciare il buffer sottostante esposto dall'oggetto memoryview.  Molti "
"oggetti intraprendono azioni speciali quando una vista è tenuta su di loro "
"(per esempio, un :class:`bytearray` vieterebbe temporaneamente il "
"ridimensionamento); quindi, chiamare release() è utile per rimuovere queste "
"restrizioni (e liberare qualsiasi risorsa penzolante) il più presto "
"possibile."

#: ../Doc/library/stdtypes.rst:3636
#, fuzzy
msgid ""
"After this method has been called, any further operation on the view raises "
"a :class:`ValueError` (except :meth:`release()` itself which can be called "
"multiple times)::"
msgstr ""
"Dopo che questo metodo è stato chiamato, ogni ulteriore operazione sulla "
"vista solleva una classe :class:`ValueError` (eccetto :meth:`release()` che "
"può essere chiamato più volte)::"

#: ../Doc/library/stdtypes.rst:3647
#, fuzzy
msgid ""
"The context management protocol can be used for a similar effect, using the "
"``with`` statement::"
msgstr ""
"Il protocollo di gestione del contesto può essere utilizzato per un effetto "
"simile, usando il comando ``with`````::"

#: ../Doc/library/stdtypes.rst:3663
#, fuzzy
msgid ""
"Cast a memoryview to a new format or shape. *shape* defaults to "
"``[byte_length//new_itemsize]``, which means that the result view will be "
"one-dimensional. The return value is a new memoryview, but the buffer itself "
"is not copied. Supported casts are 1D -> C-:term:`contiguous` and C-"
"contiguous -> 1D."
msgstr ""
"Getta una vista della memoria in un nuovo formato o forma. *shape* "
"predefinito a ``[byte_length///new_itemsize]```, il che significa che la "
"vista del risultato sarà unidimensionale. Il valore di ritorno è una nuova "
"visualizzazione della memoria, ma il buffer stesso non viene copiato. I "
"calchi supportati sono 1D -> C-:termine:`contiguous` e C-contiguous -> 1D."

#: ../Doc/library/stdtypes.rst:3669
#, fuzzy
msgid ""
"The destination format is restricted to a single element native format in :"
"mod:`struct` syntax. One of the formats must be a byte format ('B', 'b' or "
"'c'). The byte length of the result must be the same as the original length."
msgstr ""
"Il formato di destinazione è limitato ad un singolo elemento in formato "
"nativo in :mod:`struct` sintassi. Uno dei formati deve essere un formato "
"byte (\"B\", \"b\" o \"c\"). La lunghezza del byte del risultato deve essere "
"la stessa della lunghezza originale."

#: ../Doc/library/stdtypes.rst:3674
#, fuzzy
msgid "Cast 1D/long to 1D/unsigned bytes::"
msgstr "Da 1D/lungo a 1D/byte non firmati::"

#: ../Doc/library/stdtypes.rst:3697
#, fuzzy
msgid "Cast 1D/unsigned bytes to 1D/char::"
msgstr "Getti 1D/byte non firmati a 1D/char::"

#: ../Doc/library/stdtypes.rst:3710
#, fuzzy
msgid "Cast 1D/bytes to 3D/ints to 1D/signed char::"
msgstr "Cast 1D/bytes a 3D/ints a 1D/signed char::"

#: ../Doc/library/stdtypes.rst:3736
#, fuzzy
msgid "Cast 1D/unsigned char to 2D/unsigned long::"
msgstr "Cast 1D/unsigned char a 2D/unsigned long::"

#: ../Doc/library/stdtypes.rst:3750
#, fuzzy
msgid "The source format is no longer restricted when casting to a byte view."
msgstr ""
"Il formato sorgente non è più limitato quando si lancia in una vista byte."

#: ../Doc/library/stdtypes.rst:3753
#, fuzzy
msgid "There are also several readonly attributes available:"
msgstr "Ci sono anche diversi attributi di sola lettura disponibili:"

#: ../Doc/library/stdtypes.rst:3757
msgid "The underlying object of the memoryview::"
msgstr "L'oggetto sottostante della memoryview::"

#: ../Doc/library/stdtypes.rst:3768
#, fuzzy
msgid ""
"``nbytes == product(shape) * itemsize == len(m.tobytes())``. This is the "
"amount of space in bytes that the array would use in a contiguous "
"representation. It is not necessarily equal to ``len(m)``::"
msgstr ""
"``nbytes == prodotto (forma) * itemsize == len(m.tobytes())```. È la "
"quantità di spazio in byte che l'array utilizzerebbe in una rappresentazione "
"contigua. Non è necessariamente uguale a ``len(m)``::"

#: ../Doc/library/stdtypes.rst:3787
msgid "Multi-dimensional arrays::"
msgstr "Array multidimensionali::"

#: ../Doc/library/stdtypes.rst:3804
msgid "A bool indicating whether the memory is read only."
msgstr "Un booleano che indica se la memoria è di sola lettura."

#: ../Doc/library/stdtypes.rst:3808
#, fuzzy
msgid ""
"A string containing the format (in :mod:`struct` module style) for each "
"element in the view. A memoryview can be created from exporters with "
"arbitrary format strings, but some methods (e.g. :meth:`tolist`) are "
"restricted to native single element formats."
msgstr ""
"Una stringa contenente il formato (in :mod:`struct` module style) per ogni "
"elemento della vista. Una vista di memoria può essere creata dagli "
"esportatori con stringhe di formato arbitrario, ma alcuni metodi (ad "
"esempio :meth:`tolist`) sono limitati ai formati nativi per singolo elemento."

#: ../Doc/library/stdtypes.rst:3813
#, fuzzy
msgid ""
"format ``'B'`` is now handled according to the struct module syntax. This "
"means that ``memoryview(b'abc')[0] == b'abc'[0] == 97``."
msgstr ""
"formato ``'B'```` è ora gestito secondo la sintassi del modulo struct. "
"Questo significa che ``memoryview(b'abc')[0] ===b'abc'[0] == 97```."

#: ../Doc/library/stdtypes.rst:3819
#, fuzzy
msgid "The size in bytes of each element of the memoryview::"
msgstr "La dimensione in byte di ogni elemento della vista di memoria::"

#: ../Doc/library/stdtypes.rst:3832
#, fuzzy
msgid ""
"An integer indicating how many dimensions of a multi-dimensional array the "
"memory represents."
msgstr ""
"Un intero che indica quante dimensioni di una matrice multidimensionale che "
"la memoria rappresenta."

#: ../Doc/library/stdtypes.rst:3837
#, fuzzy
msgid ""
"A tuple of integers the length of :attr:`ndim` giving the shape of the "
"memory as an N-dimensional array."
msgstr ""
"Una tupla di numeri interi della lunghezza di :attr:`ndim` che dà la forma "
"della memoria come un array N-dimensionale."

#: ../Doc/library/stdtypes.rst:3840 ../Doc/library/stdtypes.rst:3848
#, fuzzy
msgid "An empty tuple instead of ``None`` when ndim = 0."
msgstr "Una tupla vuota invece di ```Nessuno``` quando ndim = 0."

#: ../Doc/library/stdtypes.rst:3845
#, fuzzy
msgid ""
"A tuple of integers the length of :attr:`ndim` giving the size in bytes to "
"access each element for each dimension of the array."
msgstr ""
"Una tupla di numeri interi la lunghezza di :attr:`ndim` che dà la dimensione "
"in byte per accedere ad ogni elemento per ogni dimensione della matrice."

#: ../Doc/library/stdtypes.rst:3853
#, fuzzy
msgid "Used internally for PIL-style arrays. The value is informational only."
msgstr ""
"Utilizzato internamente per array di tipo PIL. Il valore è solo informativo."

#: ../Doc/library/stdtypes.rst:3857
#, fuzzy
msgid "A bool indicating whether the memory is C-:term:`contiguous`."
msgstr "Una barra che indica se la memoria è C-:termine:`contiguous`."

#: ../Doc/library/stdtypes.rst:3863
#, fuzzy
msgid "A bool indicating whether the memory is Fortran :term:`contiguous`."
msgstr "Un bool che indica se la memoria è Fortran :termine:`contiguous`."

#: ../Doc/library/stdtypes.rst:3869
msgid "A bool indicating whether the memory is :term:`contiguous`."
msgstr "Un booleano che indica se la memoria è :termine:`contiguous`."

#: ../Doc/library/stdtypes.rst:3877
#, fuzzy
msgid "Set Types --- :class:`set`, :class:`frozenset`"
msgstr "Tipi di set ----- :class:`set`, :class:`frozenset`"

#: ../Doc/library/stdtypes.rst:3881
#, fuzzy
msgid ""
"A :dfn:`set` object is an unordered collection of distinct :term:`hashable` "
"objects. Common uses include membership testing, removing duplicates from a "
"sequence, and computing mathematical operations such as intersection, union, "
"difference, and symmetric difference. (For other containers see the built-"
"in :class:`dict`, :class:`list`, and :class:`tuple` classes, and the :mod:"
"`collections` module.)"
msgstr ""
"A :dfn:`set` object è una collezione non ordinata di oggetti distinti :"
"termine:`hashable`. Gli usi comuni includono il test di adesione, la "
"rimozione di duplicati da una sequenza e il calcolo di operazioni "
"matematiche come intersezione, unione, differenza e differenza simmetrica. "
"(Per gli altri contenitori vedere il built-in :class:`dict`, :class:`list`, "
"e :class:`tuple` classes, e il modulo :mod:`collections` module.)"

#: ../Doc/library/stdtypes.rst:3888
#, fuzzy
msgid ""
"Like other collections, sets support ``x in set``, ``len(set)``, and ``for x "
"in set``.  Being an unordered collection, sets do not record element "
"position or order of insertion.  Accordingly, sets do not support indexing, "
"slicing, or other sequence-like behavior."
msgstr ""
"Come altre collezioni, i set supportano ``x in set```, ``len(set)```, e "
"``for x in set```.  Trattandosi di una collezione non ordinata, i set non "
"registrano la posizione dell'elemento o l'ordine di inserimento.  Di "
"conseguenza, i set non supportano l'indicizzazione, il taglio o altri "
"comportamenti simili a sequenze."

#: ../Doc/library/stdtypes.rst:3893
#, fuzzy
msgid ""
"There are currently two built-in set types, :class:`set` and :class:"
"`frozenset`. The :class:`set` type is mutable --- the contents can be "
"changed using methods like :meth:`~set.add` and :meth:`~set.remove`.  Since "
"it is mutable, it has no hash value and cannot be used as either a "
"dictionary key or as an element of another set.  The :class:`frozenset` type "
"is immutable and :term:`hashable` --- its contents cannot be altered after "
"it is created; it can therefore be used as a dictionary key or as an element "
"of another set."
msgstr ""
"Attualmente ci sono due tipi di set integrati, :class:`set` e :class:"
"`frozenset`. Il tipo :class:`set` è mutevole --- il contenuto può essere "
"cambiato usando metodi come :meth:`~set.add` e :meth:`~set.remove`.  Poiché "
"è mutevole, non ha valore di hash e non può essere usato come chiave di "
"dizionario o come elemento di un altro set.  Il tipo :class:`frozenset` è "
"immutabile e :term:`hashable` --- il suo contenuto non può essere modificato "
"dopo la sua creazione; può quindi essere usato come chiave di dizionario o "
"come elemento di un altro set."

#: ../Doc/library/stdtypes.rst:3901
#, fuzzy
msgid ""
"Non-empty sets (not frozensets) can be created by placing a comma-separated "
"list of elements within braces, for example: ``{'jack', 'sjoerd'}``, in "
"addition to the :class:`set` constructor."
msgstr ""
"I set non vuoti (non frozensets) possono essere creati posizionando una "
"lista separata da virgole di elementi all'interno delle parentesi, per "
"esempio: ``{'jack', 'sjoerd'}````, oltre al costruttore :class:`set`."

#: ../Doc/library/stdtypes.rst:3905
#, fuzzy
msgid "The constructors for both classes work the same:"
msgstr "I costruttori di entrambe le classi lavorano allo stesso modo:"

#: ../Doc/library/stdtypes.rst:3910
#, fuzzy
msgid ""
"Return a new set or frozenset object whose elements are taken from "
"*iterable*.  The elements of a set must be :term:`hashable`.  To represent "
"sets of sets, the inner sets must be :class:`frozenset` objects.  If "
"*iterable* is not specified, a new empty set is returned."
msgstr ""
"Restituisce un nuovo oggetto set o frozenset i cui elementi sono presi da "
"*iterable*.  Gli elementi di un insieme devono essere: termine:`hashable`.  "
"Per rappresentare insiemi di insiemi, i set interni devono essere :class:"
"`frozenset` objects.  Se non viene specificato *iterable*, viene restituito "
"un nuovo set vuoto."

#: ../Doc/library/stdtypes.rst:3916
#, fuzzy
msgid ""
"Instances of :class:`set` and :class:`frozenset` provide the following "
"operations:"
msgstr ""
"Le istanze di :class:`set` e :class:`frozenset` forniscono le seguenti "
"operazioni:"

#: ../Doc/library/stdtypes.rst:3921
#, fuzzy
msgid "Return the number of elements in set *s* (cardinality of *s*)."
msgstr "Restituisce il numero di elementi nel set *s* (cardinalità di *s*)."

#: ../Doc/library/stdtypes.rst:3925
msgid "Test *x* for membership in *s*."
msgstr "Test *x* per l’appartenenza a *s*."

#: ../Doc/library/stdtypes.rst:3929
msgid "Test *x* for non-membership in *s*."
msgstr "Test *x* per la non appartenenza a *s*."

#: ../Doc/library/stdtypes.rst:3933
#, fuzzy
msgid ""
"Return ``True`` if the set has no elements in common with *other*.  Sets are "
"disjoint if and only if their intersection is the empty set."
msgstr ""
"Restituire ``True``` se il set non ha elementi in comune con *altro*.  I set "
"sono disgiunti se e solo se la loro intersezione è il set vuoto."

#: ../Doc/library/stdtypes.rst:3939
#, fuzzy
msgid "Test whether every element in the set is in *other*."
msgstr "Verificare se ogni elemento del set è in *altro*."

#: ../Doc/library/stdtypes.rst:3943
#, fuzzy
msgid ""
"Test whether the set is a proper subset of *other*, that is, ``set <= other "
"and set != other``."
msgstr ""
"Verificare se il set è un sottoinsieme corretto di *altro*, cioè, ``set <= "
"altro e set!"

#: ../Doc/library/stdtypes.rst:3949
#, fuzzy
msgid "Test whether every element in *other* is in the set."
msgstr "Verificare se ogni elemento in *altro* è nel set."

#: ../Doc/library/stdtypes.rst:3953
#, fuzzy
msgid ""
"Test whether the set is a proper superset of *other*, that is, ``set >= "
"other and set != other``."
msgstr ""
"Verificare se il set è un proprio superset di *altro*, cioè ``set >= altro e "
"set != altro```."

#: ../Doc/library/stdtypes.rst:3959
#, fuzzy
msgid "Return a new set with elements from the set and all others."
msgstr "Restituire un nuovo set con elementi del set e tutti gli altri."

#: ../Doc/library/stdtypes.rst:3964
#, fuzzy
msgid "Return a new set with elements common to the set and all others."
msgstr ""
"Restituisce un nuovo set con elementi comuni al set e a tutti gli altri."

#: ../Doc/library/stdtypes.rst:3969
#, fuzzy
msgid "Return a new set with elements in the set that are not in the others."
msgstr ""
"Restituisce un nuovo set con elementi del set che non sono negli altri."

#: ../Doc/library/stdtypes.rst:3974
#, fuzzy
msgid ""
"Return a new set with elements in either the set or *other* but not both."
msgstr ""
"Restituisce un nuovo set con elementi nel set o *altro* ma non entrambi."

#: ../Doc/library/stdtypes.rst:3978
msgid "Return a shallow copy of the set."
msgstr "Restituisce una shallow copy del set."

#: ../Doc/library/stdtypes.rst:3981
#, fuzzy
msgid ""
"Note, the non-operator versions of :meth:`union`, :meth:`intersection`, :"
"meth:`difference`, and :meth:`symmetric_difference`, :meth:`issubset`, and :"
"meth:`issuperset` methods will accept any iterable as an argument.  In "
"contrast, their operator based counterparts require their arguments to be "
"sets.  This precludes error-prone constructions like ``set('abc') & 'cbs'`` "
"in favor of the more readable ``set('abc').intersection('cbs')``."
msgstr ""
"Nota, le versioni non operative di :meth:`union`, :meth:`intersection`, :"
"meth:`differenza`, e :meth:`symmetric_difference`, :meth:`issubset`, e :meth:"
"`issuperset` metodi accetterà qualsiasi iterable come argomento.  Al "
"contrario, le loro controparti basate sull'operatore richiedono che le loro "
"argomentazioni siano definite.  Ciò preclude costruzioni soggette ad errori "
"come ``set('abc') & 'cbs'``` a favore del più leggibile ``set('abc')."
"intersection('cbs')```."

#: ../Doc/library/stdtypes.rst:3988
#, fuzzy
msgid ""
"Both :class:`set` and :class:`frozenset` support set to set comparisons. Two "
"sets are equal if and only if every element of each set is contained in the "
"other (each is a subset of the other). A set is less than another set if and "
"only if the first set is a proper subset of the second set (is a subset, but "
"is not equal). A set is greater than another set if and only if the first "
"set is a proper superset of the second set (is a superset, but is not equal)."
msgstr ""
"Entrambi :class:`set` e :class:`frozenset` set di supporto per impostare i "
"confronti. Due insiemi sono uguali se e solo se ogni elemento di ogni "
"insieme è contenuto nell'altro (ognuno è un sottoinsieme dell'altro). Un set "
"è inferiore ad un altro set se e solo se il primo set è un sottoinsieme "
"appropriato del secondo set (è un sottoinsieme, ma non è uguale). Un set è "
"maggiore di un altro set se e solo se il primo set è un proprio superset del "
"secondo set (è un superset, ma non è uguale)."

#: ../Doc/library/stdtypes.rst:3995
#, fuzzy
msgid ""
"Instances of :class:`set` are compared to instances of :class:`frozenset` "
"based on their members.  For example, ``set('abc') == frozenset('abc')`` "
"returns ``True`` and so does ``set('abc') in set([frozenset('abc')])``."
msgstr ""
"Le istanze di :class:`set` sono paragonate alle istanze di :class:"
"`frozenset` in base ai loro membri.  Per esempio, ```set('abc') == "
"frozenset('abc')``` restituisce ``True``` e così ``set('abc') in "
"set([frozenset('abc')])```."

#: ../Doc/library/stdtypes.rst:3999
#, fuzzy
msgid ""
"The subset and equality comparisons do not generalize to a total ordering "
"function.  For example, any two nonempty disjoint sets are not equal and are "
"not subsets of each other, so *all* of the following return ``False``: "
"``a<b``, ``a==b``, or ``a>b``."
msgstr ""
"I confronti tra il sottoinsieme e l'uguaglianza non generalizzano ad una "
"funzione di ordinazione totale.  Per esempio, due set di disgiunti non vuoti "
"non sono uguali e non sono sottoinsiemi l'uno dell'altro, così *tutti* dei "
"seguenti ritorni ``False```: ``a<b``, ``a===b```, o ``a>b```."

#: ../Doc/library/stdtypes.rst:4004
#, fuzzy
msgid ""
"Since sets only define partial ordering (subset relationships), the output "
"of the :meth:`list.sort` method is undefined for lists of sets."
msgstr ""
"Poiché gli insiemi definiscono solo l'ordinamento parziale (relazioni di "
"sottoinsieme), l'output del metodo :meth:`list.sort` è indefinito per le "
"liste di insiemi."

#: ../Doc/library/stdtypes.rst:4007
#, fuzzy
msgid "Set elements, like dictionary keys, must be :term:`hashable`."
msgstr ""
"Gli elementi del set, come i tasti del dizionario, devono essere: termine:"
"`hashable`."

#: ../Doc/library/stdtypes.rst:4009
#, fuzzy
msgid ""
"Binary operations that mix :class:`set` instances with :class:`frozenset` "
"return the type of the first operand.  For example: ``frozenset('ab') | "
"set('bc')`` returns an instance of :class:`frozenset`."
msgstr ""
"Le operazioni binarie che mescolano :class:`set` istanze con :class:"
"`frozenset` restituiscono il tipo del primo operando.  Per esempio: "
"``frozenset('ab') | set('bc'')`` restituisce un'istanza di :class:"
"`frozenset`."

#: ../Doc/library/stdtypes.rst:4013
#, fuzzy
msgid ""
"The following table lists operations available for :class:`set` that do not "
"apply to immutable instances of :class:`frozenset`:"
msgstr ""
"La seguente tabella elenca le operazioni disponibili per :class:`set` che "
"non si applicano alle istanze immutabili di :class:`frozenset`:"

#: ../Doc/library/stdtypes.rst:4019
msgid "Update the set, adding elements from all others."
msgstr "Aggiorna il set, aggiungendo elementi da tutti gli altri."

#: ../Doc/library/stdtypes.rst:4024
msgid "Update the set, keeping only elements found in it and all others."
msgstr ""
"Aggiorna il set, mantenendo solo gli elementi presenti sia in esso che in "
"tutti gli altri."

#: ../Doc/library/stdtypes.rst:4029
msgid "Update the set, removing elements found in others."
msgstr "Aggiorna il set, rimuovendo gli elementi trovati negli altri."

#: ../Doc/library/stdtypes.rst:4034
msgid ""
"Update the set, keeping only elements found in either set, but not in both."
msgstr ""
"Aggiorna il set, mantenendo solo gli elementi presenti in uno dei set, ma "
"non in entrambi."

#: ../Doc/library/stdtypes.rst:4038
msgid "Add element *elem* to the set."
msgstr "Aggiunge l’elemento *elem* al set."

#: ../Doc/library/stdtypes.rst:4042
msgid ""
"Remove element *elem* from the set.  Raises :exc:`KeyError` if *elem* is not "
"contained in the set."
msgstr ""
"Rimuovere l'elemento *elem* dal set. Solleva :exc:`KeyError` se *elem* non è "
"contenuto nel set."

#: ../Doc/library/stdtypes.rst:4047
msgid "Remove element *elem* from the set if it is present."
msgstr "Rimuove l'elemento *elem* dal set se presente."

#: ../Doc/library/stdtypes.rst:4051
msgid ""
"Remove and return an arbitrary element from the set.  Raises :exc:`KeyError` "
"if the set is empty."
msgstr ""
"Rimuove e restituisce un elemento arbitrario dal set. Solleva :exc:"
"`KeyError` se il set è vuoto."

#: ../Doc/library/stdtypes.rst:4056
msgid "Remove all elements from the set."
msgstr "Rimuove tutti gli elementi dal set."

#: ../Doc/library/stdtypes.rst:4059
#, fuzzy
msgid ""
"Note, the non-operator versions of the :meth:`update`, :meth:"
"`intersection_update`, :meth:`difference_update`, and :meth:"
"`symmetric_difference_update` methods will accept any iterable as an "
"argument."
msgstr ""
"Nota, le versioni non operative dei metodi :meth:`aggiornamento`, :meth:"
"`intersection_update`, :meth:`difference_update`, e :meth:"
"`symmetric_difference_difference_update` accettano qualsiasi iterable come "
"argomento."

#: ../Doc/library/stdtypes.rst:4064
#, fuzzy
msgid ""
"Note, the *elem* argument to the :meth:`__contains__`, :meth:`remove`, and :"
"meth:`discard` methods may be a set.  To support searching for an equivalent "
"frozenset, a temporary one is created from *elem*."
msgstr ""
"Nota, l'argomento *elem* a :meth:`__contains____`, :meth:`remove`, e :meth:"
"`discard` metodi possono essere un insieme.  Per supportare la ricerca di un "
"frozenset equivalente, ne viene creato uno temporaneo da *elem*."

#: ../Doc/library/stdtypes.rst:4072
msgid "Mapping Types --- :class:`dict`"
msgstr "Tipi mapping --- :class:`dict`"

#: ../Doc/library/stdtypes.rst:4082
#, fuzzy
msgid ""
"A :term:`mapping` object maps :term:`hashable` values to arbitrary objects. "
"Mappings are mutable objects.  There is currently only one standard mapping "
"type, the :dfn:`dictionary`.  (For other containers see the built-in :class:"
"`list`, :class:`set`, and :class:`tuple` classes, and the :mod:`collections` "
"module.)"
msgstr ""
"A :termine:`mappare` oggetti mappe :termine:`hashable` valori a oggetti "
"arbitrari. Le mappature sono oggetti mutevoli.  Attualmente esiste un solo "
"tipo di mappatura standard, il :dfn:`dizionario`.  (Per gli altri "
"contenitori vedere il built-in :class:`list`, :class:`set`, e :class:`tuple` "
"classes, e il modulo :mod:`collections` module.)"

#: ../Doc/library/stdtypes.rst:4088
#, fuzzy
msgid ""
"A dictionary's keys are *almost* arbitrary values.  Values that are not :"
"term:`hashable`, that is, values containing lists, dictionaries or other "
"mutable types (that are compared by value rather than by object identity) "
"may not be used as keys.  Numeric types used for keys obey the normal rules "
"for numeric comparison: if two numbers compare equal (such as ``1`` and "
"``1.0``) then they can be used interchangeably to index the same dictionary "
"entry.  (Note however, that since computers store floating-point numbers as "
"approximations it is usually unwise to use them as dictionary keys.)"
msgstr ""
"Le chiavi di un dizionario sono *quasi* valori arbitrari.  Valori che non "
"sono :termine:`hashable`, cioè valori contenenti liste, dizionari o altri "
"tipi mutevoli (che sono confrontati in base al valore piuttosto che "
"all'identità dell'oggetto) non possono essere usati come chiavi.  I tipi "
"numerici usati per i tasti obbediscono alle normali regole per il confronto "
"numerico: se due numeri sono uguali (come ``1``` e ``1.0```) allora possono "
"essere usati in modo intercambiabile per indicizzare la stessa voce del "
"dizionario.  (Si noti, tuttavia, che poiché i computer memorizzano numeri a "
"virgola mobile come approssimazioni, di solito non è saggio usarli come "
"chiavi di dizionario)"

#: ../Doc/library/stdtypes.rst:4097
#, fuzzy
msgid ""
"Dictionaries can be created by placing a comma-separated list of ``key: "
"value`` pairs within braces, for example: ``{'jack': 4098, 'sjoerd': 4127}`` "
"or ``{4098: 'jack', 4127: 'sjoerd'}``, or by the :class:`dict` constructor."
msgstr ""
"I dizionari possono essere creati posizionando una lista separata da virgole "
"di ``chiave: coppie di valori ```` all'interno delle parentesi, per esempio: "
"``{{'jack': 4098, 'sjoerd': 4127}``` o ``{4098: 'jack', 4127: 'sjoerd'}````, "
"o dal costruttore :class:`dict`."

#: ../Doc/library/stdtypes.rst:4105
#, fuzzy
msgid ""
"Return a new dictionary initialized from an optional positional argument and "
"a possibly empty set of keyword arguments."
msgstr ""
"Restituisce un nuovo dizionario inizializzato da un argomento posizionale "
"opzionale e da un insieme possibilmente vuoto di argomenti di parole chiave."

#: ../Doc/library/stdtypes.rst:4108
#, fuzzy
msgid ""
"If no positional argument is given, an empty dictionary is created. If a "
"positional argument is given and it is a mapping object, a dictionary is "
"created with the same key-value pairs as the mapping object.  Otherwise, the "
"positional argument must be an :term:`iterable` object.  Each item in the "
"iterable must itself be an iterable with exactly two objects.  The first "
"object of each item becomes a key in the new dictionary, and the second "
"object the corresponding value.  If a key occurs more than once, the last "
"value for that key becomes the corresponding value in the new dictionary."
msgstr ""
"Se non viene dato alcun argomento di posizione, viene creato un dizionario "
"vuoto. Se viene dato un argomento di posizione ed è un oggetto di mappatura, "
"viene creato un dizionario con le stesse coppie chiave-valore dell'oggetto "
"di mappatura.  Altrimenti, l'argomento di posizione deve essere un oggetto :"
"termine:`iterable`.  Ogni elemento dell'iterable deve essere esso stesso un "
"iterable con esattamente due oggetti.  Il primo oggetto di ogni elemento "
"diventa una chiave nel nuovo dizionario e il secondo oggetto il valore "
"corrispondente.  Se una chiave si verifica più di una volta, l'ultimo valore "
"per quella chiave diventa il valore corrispondente nel nuovo dizionario."

#: ../Doc/library/stdtypes.rst:4118
#, fuzzy
msgid ""
"If keyword arguments are given, the keyword arguments and their values are "
"added to the dictionary created from the positional argument.  If a key "
"being added is already present, the value from the keyword argument replaces "
"the value from the positional argument."
msgstr ""
"Se vengono forniti argomenti di parole chiave, gli argomenti delle parole "
"chiave e i loro valori sono aggiunti al dizionario creato dall'argomento di "
"posizione.  Se una chiave aggiunta è già presente, il valore dell'argomento "
"parola chiave sostituisce il valore dell'argomento posizionale."

#: ../Doc/library/stdtypes.rst:4123
#, fuzzy
msgid ""
"To illustrate, the following examples all return a dictionary equal to "
"``{\"one\": 1, \"two\": 2, \"three\": 3}``::"
msgstr ""
"Per illustrare, i seguenti esempi restituiscono tutti un dizionario uguale a "
"``{{{\"uno\": 1, \"due\": 2, \"tre\": 3}``::"

#: ../Doc/library/stdtypes.rst:4134
#, fuzzy
msgid ""
"Providing keyword arguments as in the first example only works for keys that "
"are valid Python identifiers.  Otherwise, any valid keys can be used."
msgstr ""
"Fornire argomenti di parole chiave come nel primo esempio funziona solo per "
"chiavi che sono identificatori Python validi.  In caso contrario, è "
"possibile utilizzare qualsiasi chiave valida."

#: ../Doc/library/stdtypes.rst:4138
#, fuzzy
msgid ""
"These are the operations that dictionaries support (and therefore, custom "
"mapping types should support too):"
msgstr ""
"Queste sono le operazioni che i dizionari supportano (e quindi anche i tipi "
"di mappatura personalizzati dovrebbero supportare):"

#: ../Doc/library/stdtypes.rst:4143
msgid "Return the number of items in the dictionary *d*."
msgstr "Restituisce il numero di elementi nel dizionario *d*."

#: ../Doc/library/stdtypes.rst:4147
msgid ""
"Return the item of *d* with key *key*.  Raises a :exc:`KeyError` if *key* is "
"not in the map."
msgstr ""
"Restituire l’elemento di *d* con la chiave *key*. Solleva un :exc:`KeyError` "
"se *key* non è nel mapping."

#: ../Doc/library/stdtypes.rst:4152
#, fuzzy
msgid ""
"If a subclass of dict defines a method :meth:`__missing__` and *key* is not "
"present, the ``d[key]`` operation calls that method with the key *key* as "
"argument.  The ``d[key]`` operation then returns or raises whatever is "
"returned or raised by the ``__missing__(key)`` call. No other operations or "
"methods invoke :meth:`__missing__`. If :meth:`__missing__` is not defined, :"
"exc:`KeyError` is raised. :meth:`__missing__` must be a method; it cannot be "
"an instance variable::"
msgstr ""
"Se una sottoclasse di dict definisce un metodo :meth:`__missing__`` e "
"*chiave* non è presente, l'operazione ``d[key]``` chiama quel metodo con il "
"tasto *chiave* come argomento.  L'operazione ```d[key]```` restituisce o "
"solleva tutto ciò che viene restituito o sollevato dalla "
"``__missing__(key)``` chiamata. Nessun'altra operazione o metodo invoca: "
"meth:`__missing____`. Se :meth:`__missing__` non è definito, :exc:`KeyError` "
"è sollevato. :meth:`__missing__` deve essere un metodo; non può essere una "
"variabile di istanza::"

#: ../Doc/library/stdtypes.rst:4170
#, fuzzy
msgid ""
"The example above shows part of the implementation of :class:`collections."
"Counter`.  A different ``__missing__`` method is used by :class:`collections."
"defaultdict`."
msgstr ""
"L'esempio precedente mostra parte dell'implementazione di :class:"
"`collections.Counter`.  Un diverso metodo ``__missing__```` è usato da :"
"class:`collections.defaultdict`."

#: ../Doc/library/stdtypes.rst:4176
msgid "Set ``d[key]`` to *value*."
msgstr "Imposta ``d[key]`` a *value*."

#: ../Doc/library/stdtypes.rst:4180
#, fuzzy
msgid ""
"Remove ``d[key]`` from *d*.  Raises a :exc:`KeyError` if *key* is not in the "
"map."
msgstr ""
"Rimuovere ````d[key]``` da *d*.  Solleva un :exc:`KeyError` se *chiave* non "
"è nella mappa."

#: ../Doc/library/stdtypes.rst:4185
msgid "Return ``True`` if *d* has a key *key*, else ``False``."
msgstr "Restituisce ``True`` se *d* ha una chiave *key*, altrimenti ``False``."

#: ../Doc/library/stdtypes.rst:4189
msgid "Equivalent to ``not key in d``."
msgstr "Equivalente a ``not key in d``."

#: ../Doc/library/stdtypes.rst:4193
#, fuzzy
msgid ""
"Return an iterator over the keys of the dictionary.  This is a shortcut for "
"``iter(d.keys())``."
msgstr ""
"Restituire un iteratore sulle chiavi del dizionario.  Questa è una "
"scorciatoia per ``iter(d.keys())```."

#: ../Doc/library/stdtypes.rst:4198
msgid "Remove all items from the dictionary."
msgstr "Rimuove tutte le voci dal dizionario."

#: ../Doc/library/stdtypes.rst:4202
msgid "Return a shallow copy of the dictionary."
msgstr "Restituisce una shallow copy del dizionario."

#: ../Doc/library/stdtypes.rst:4206
#, fuzzy
msgid ""
"Create a new dictionary with keys from *iterable* and values set to *value*."
msgstr ""
"Crea un nuovo dizionario con i tasti da *iterable* e i valori impostati su "
"*valore*."

#: ../Doc/library/stdtypes.rst:4208
#, fuzzy
msgid ""
":meth:`fromkeys` is a class method that returns a new dictionary. *value* "
"defaults to ``None``."
msgstr ""
":meth:`fromkeys` è un metodo di classe che restituisce un nuovo dizionario. "
"** è impostato su ````Nessuno```."

#: ../Doc/library/stdtypes.rst:4213
#, fuzzy
msgid ""
"Return the value for *key* if *key* is in the dictionary, else *default*. If "
"*default* is not given, it defaults to ``None``, so that this method never "
"raises a :exc:`KeyError`."
msgstr ""
"Restituisce il valore di *chiave* se *chiave* è nel dizionario, altrimenti "
"*default*. Se non viene dato *default*, il valore predefinito è "
"```Nessuno```, in modo che questo metodo non solleva mai un :exc:`KeyError``."

#: ../Doc/library/stdtypes.rst:4219
#, fuzzy
msgid ""
"Return a new view of the dictionary's items (``(key, value)`` pairs). See "
"the :ref:`documentation of view objects <dict-views>`."
msgstr ""
"Ritorna una nuova vista degli elementi del dizionario (``(chiave, valore)``` "
"coppie). Vedere :ref:`documentazione degli oggetti di visualizzazione <dict-"
"views>`.</dict-views>"

#: ../Doc/library/stdtypes.rst:4224
#, fuzzy
msgid ""
"Return a new view of the dictionary's keys.  See the :ref:`documentation of "
"view objects <dict-views>`."
msgstr ""
"Restituisce una nuova visualizzazione delle chiavi del dizionario.  Vedere :"
"ref:`documentazione degli oggetti di visualizzazione <dict-views>`.</dict-"
"views>"

#: ../Doc/library/stdtypes.rst:4229
#, fuzzy
msgid ""
"If *key* is in the dictionary, remove it and return its value, else return "
"*default*.  If *default* is not given and *key* is not in the dictionary, a :"
"exc:`KeyError` is raised."
msgstr ""
"Se *chiave* è nel dizionario, rimuoverlo e restituire il suo valore, "
"altrimenti restituire *default*.  Se *default* non è dato e *chiave* non è "
"nel dizionario, viene sollevato un :exc:`KeyError`."

#: ../Doc/library/stdtypes.rst:4235
#, fuzzy
msgid ""
"Remove and return a ``(key, value)`` pair from the dictionary. Pairs are "
"returned in :abbr:`LIFO (last-in, first-out)` order."
msgstr ""
"Rimuovere e restituire una coppia ``(chiave, valore)`` dal dizionario. Le "
"coppie vengono restituite in :abbr:`LIFO (ultimo in, primo fuori)`ordine."

#: ../Doc/library/stdtypes.rst:4238
#, fuzzy
msgid ""
":meth:`popitem` is useful to destructively iterate over a dictionary, as "
"often used in set algorithms.  If the dictionary is empty, calling :meth:"
"`popitem` raises a :exc:`KeyError`."
msgstr ""
":meth:`popitem` è utile per iterare distruttivamente su un dizionario, come "
"spesso utilizzato in algoritmi di set.  Se il dizionario è vuoto, chiamando :"
"meth:`popitem` solleva un :exc:`KeyError`."

#: ../Doc/library/stdtypes.rst:4242
#, fuzzy
msgid ""
"LIFO order is now guaranteed. In prior versions, :meth:`popitem` would "
"return an arbitrary key/value pair."
msgstr ""
"L'ordine LIFO è ora garantito. Nelle versioni precedenti, :meth:`popitem` "
"restituirebbe una coppia chiave/valore arbitrario."

#: ../Doc/library/stdtypes.rst:4248
#, fuzzy
msgid ""
"If *key* is in the dictionary, return its value.  If not, insert *key* with "
"a value of *default* and return *default*.  *default* defaults to ``None``."
msgstr ""
"Se *chiave* è nel dizionario, restituire il suo valore.  In caso contrario, "
"inserire *chiave* con un valore di *default* e restituire *default*.  "
"*default* è impostato su ````Nessuno```."

#: ../Doc/library/stdtypes.rst:4254
#, fuzzy
msgid ""
"Update the dictionary with the key/value pairs from *other*, overwriting "
"existing keys.  Return ``None``."
msgstr ""
"Aggiornare il dizionario con le coppie chiave/valore da *altro*, "
"sovrascrivendo le chiavi esistenti.  Ritorno ````No````."

#: ../Doc/library/stdtypes.rst:4257
#, fuzzy
msgid ""
":meth:`update` accepts either another dictionary object or an iterable of "
"key/value pairs (as tuples or other iterables of length two).  If keyword "
"arguments are specified, the dictionary is then updated with those key/value "
"pairs: ``d.update(red=1, blue=2)``."
msgstr ""
"meth:`aggiornamento` accetta o un altro oggetto dizionario o un iterable "
"delle coppie chiave/valore (come tuple o altri iterables di lunghezza due).  "
"Se vengono specificati gli argomenti delle parole chiave, il dizionario "
"viene aggiornato con le coppie chiave/valore: ``d.update(red=1, blue=2)``."

#: ../Doc/library/stdtypes.rst:4264
#, fuzzy
msgid ""
"Return a new view of the dictionary's values.  See the :ref:`documentation "
"of view objects <dict-views>`."
msgstr ""
"Restituisce una nuova visualizzazione dei valori del dizionario.  Vedere :"
"ref:`documentazione degli oggetti di visualizzazione <dict-views>`.</dict-"
"views>"

#: ../Doc/library/stdtypes.rst:4267
#, fuzzy
msgid ""
"Dictionaries compare equal if and only if they have the same ``(key, "
"value)`` pairs. Order comparisons ('<', '<=', '>=', '>') raise :exc:"
"`TypeError`."
msgstr ""
"I dizionari confrontare uguale se e solo se hanno la stessa ```(chiave, "
"valore)`` coppie. I confronti degli ordini ('<', '<=', '>=', '>=', '>') "
"aumentano :exc:`TypeError`."

#: ../Doc/library/stdtypes.rst:4271
#, fuzzy
msgid ""
"Dictionaries preserve insertion order.  Note that updating a key does not "
"affect the order.  Keys added after deletion are inserted at the end. ::"
msgstr ""
"I dizionari conservano l'ordine di inserimento.  Si noti che l'aggiornamento "
"di una chiave non influisce sull'ordine.  Le chiavi aggiunte dopo la "
"cancellazione sono inserite alla fine:"

#: ../Doc/library/stdtypes.rst:4289
#, fuzzy
msgid ""
"Dictionary order is guaranteed to be insertion order.  This behavior was an "
"implementation detail of CPython from 3.6."
msgstr ""
"L'ordine del dizionario è garantito come ordine di inserimento.  Questo "
"comportamento è stato un dettaglio di implementazione di CPython da 3.6."

#: ../Doc/library/stdtypes.rst:4294
#, fuzzy
msgid ""
":class:`types.MappingProxyType` can be used to create a read-only view of a :"
"class:`dict`."
msgstr ""
"class:`types.MappingProxyType` può essere usato per creare una vista in sola "
"lettura di una :class:`dict`."

#: ../Doc/library/stdtypes.rst:4301
#, fuzzy
msgid "Dictionary view objects"
msgstr "Oggetti della vista del dizionario"

#: ../Doc/library/stdtypes.rst:4303
#, fuzzy
msgid ""
"The objects returned by :meth:`dict.keys`, :meth:`dict.values` and :meth:"
"`dict.items` are *view objects*.  They provide a dynamic view on the "
"dictionary's entries, which means that when the dictionary changes, the view "
"reflects these changes."
msgstr ""
"Gli oggetti restituiti da :meth:`dict.keys`, :meth:`dict.values` e :meth:"
"`dict.items` sono *oggetti di visualizzazione*.  Essi forniscono una visione "
"dinamica delle voci del dizionario, il che significa che quando il "
"dizionario cambia, la vista riflette questi cambiamenti."

#: ../Doc/library/stdtypes.rst:4308
#, fuzzy
msgid ""
"Dictionary views can be iterated over to yield their respective data, and "
"support membership tests:"
msgstr ""
"Le visualizzazioni dei dizionari possono essere iterate per fornire i "
"rispettivi dati e supportare i test di adesione:"

#: ../Doc/library/stdtypes.rst:4313
#, fuzzy
msgid "Return the number of entries in the dictionary."
msgstr "Restituire il numero di voci nel dizionario."

#: ../Doc/library/stdtypes.rst:4317
#, fuzzy
msgid ""
"Return an iterator over the keys, values or items (represented as tuples of "
"``(key, value)``) in the dictionary."
msgstr ""
"Restituire un iteratore sulle chiavi, i valori o gli elementi (rappresentati "
"come tuple di ``(chiave, valore)```) nel dizionario."

#: ../Doc/library/stdtypes.rst:4320
#, fuzzy
msgid ""
"Keys and values are iterated over in insertion order. This allows the "
"creation of ``(value, key)`` pairs using :func:`zip`: ``pairs = zip(d."
"values(), d.keys())``.  Another way to create the same list is ``pairs = "
"[(v, k) for (k, v) in d.items()]``."
msgstr ""
"Le chiavi e i valori sono riportati in ordine di inserimento. Questo "
"permette la creazione di ``(valore, chiave)``` coppie utilizzando :func:"
"`zip`: ``pairs = zip(d.values(), d.keys())``.  Un altro modo per creare la "
"stessa lista è ``pairs = [(v, k) per (k, v) in d.items()]```."

#: ../Doc/library/stdtypes.rst:4325
#, fuzzy
msgid ""
"Iterating views while adding or deleting entries in the dictionary may raise "
"a :exc:`RuntimeError` or fail to iterate over all entries."
msgstr ""
"L'iterazione delle viste mentre si aggiungono o si cancellano le voci del "
"dizionario può generare un:exc:`RuntimeError` o non riuscire ad iterare "
"tutte le voci."

#: ../Doc/library/stdtypes.rst:4328
#, fuzzy
msgid "Dictionary order is guaranteed to be insertion order."
msgstr "L'ordine del dizionario è garantito come ordine di inserimento."

#: ../Doc/library/stdtypes.rst:4333
#, fuzzy
msgid ""
"Return ``True`` if *x* is in the underlying dictionary's keys, values or "
"items (in the latter case, *x* should be a ``(key, value)`` tuple)."
msgstr ""
"Ritorna ``True```` se *x* è nelle chiavi, valori o elementi del dizionario "
"sottostante (in quest'ultimo caso, *x* dovrebbe essere una ``(chiave, "
"valore)`` tupla)."

#: ../Doc/library/stdtypes.rst:4337
#, fuzzy
msgid ""
"Keys views are set-like since their entries are unique and hashable.  If all "
"values are hashable, so that ``(key, value)`` pairs are unique and hashable, "
"then the items view is also set-like.  (Values views are not treated as set-"
"like since the entries are generally not unique.)  For set-like views, all "
"of the operations defined for the abstract base class :class:`collections."
"abc.Set` are available (for example, ``==``, ``<``, or ``^``)."
msgstr ""
"Le visualizzazioni delle chiavi sono impostate in modo simile, poiché le "
"loro voci sono uniche ed hashable.  Se tutti i valori sono hashable, in modo "
"che ``(chiave, valore)`` le coppie sono uniche e hashable, allora la vista "
"degli elementi è anche set-like.  (Le visualizzazioni dei valori non sono "
"trattate come set-like in quanto le voci non sono generalmente uniche.)  Per "
"le viste set-like, sono disponibili tutte le operazioni definite per la "
"classe base astratta :class:`collections.abc.set`` (per esempio, ``====```, "
"``<```, o ``^````)."

#: ../Doc/library/stdtypes.rst:4344
#, fuzzy
msgid "An example of dictionary view usage::"
msgstr "Un esempio di utilizzo del dizionario:.:"

#: ../Doc/library/stdtypes.rst:4379
#, fuzzy
msgid "Context Manager Types"
msgstr "Tipi di gestione del contesto"

#: ../Doc/library/stdtypes.rst:4386
#, fuzzy
msgid ""
"Python's :keyword:`with` statement supports the concept of a runtime context "
"defined by a context manager.  This is implemented using a pair of methods "
"that allow user-defined classes to define a runtime context that is entered "
"before the statement body is executed and exited when the statement ends:"
msgstr ""
"Python's :keyword:`with` statement supporta il concetto di un contesto "
"runtime definito da un context manager.  Questo è implementato usando una "
"coppia di metodi che permettono alle classi definite dall'utente di definire "
"un contesto di runtime che viene inserito prima che il corpo dell'istruzione "
"venga eseguito e chiuso quando l'istruzione finisce:"

#: ../Doc/library/stdtypes.rst:4394
#, fuzzy
msgid ""
"Enter the runtime context and return either this object or another object "
"related to the runtime context. The value returned by this method is bound "
"to the identifier in the :keyword:`!as` clause of :keyword:`with` statements "
"using this context manager."
msgstr ""
"Inserire il contesto di runtime e restituire questo oggetto o un altro "
"oggetto relativo al contesto di runtime. Il valore restituito con questo "
"metodo è legato all'identificatore della parola chiave :keyword:`!as` clause "
"di :keyword:`with` statements using this context manager."

#: ../Doc/library/stdtypes.rst:4399
#, fuzzy
msgid ""
"An example of a context manager that returns itself is a :term:`file "
"object`. File objects return themselves from __enter__() to allow :func:"
"`open` to be used as the context expression in a :keyword:`with` statement."
msgstr ""
"Un esempio di un context manager che si restituisce è un :termine:`oggetto "
"file`. Gli oggetti file ritornano da __enter__() per permettere che :func:"
"`open` to be used come espressione di contesto in una parola chiave :`with` "
"statement."

#: ../Doc/library/stdtypes.rst:4403
#, fuzzy
msgid ""
"An example of a context manager that returns a related object is the one "
"returned by :func:`decimal.localcontext`. These managers set the active "
"decimal context to a copy of the original decimal context and then return "
"the copy. This allows changes to be made to the current decimal context in "
"the body of the :keyword:`with` statement without affecting code outside "
"the :keyword:`!with` statement."
msgstr ""
"Un esempio di context manager che restituisce un oggetto correlato è quello "
"restituito da :func:`decimal.localcontext`. Questi manager impostano il "
"contesto decimale attivo su una copia del contesto decimale originale e poi "
"restituiscono la copia. Questo permette di apportare modifiche al contesto "
"decimale corrente nel corpo della parola chiave :keyword:`with` statement "
"senza influenzare il codice al di fuori della parola chiave :`!with` "
"statement."

#: ../Doc/library/stdtypes.rst:4413
#, fuzzy
msgid ""
"Exit the runtime context and return a Boolean flag indicating if any "
"exception that occurred should be suppressed. If an exception occurred while "
"executing the body of the :keyword:`with` statement, the arguments contain "
"the exception type, value and traceback information. Otherwise, all three "
"arguments are ``None``."
msgstr ""
"Uscire dal contesto di runtime e restituire un flag booleano che indica se "
"un'eccezione che si è verificata deve essere soppressa. Se si è verificata "
"un'eccezione durante l'esecuzione del corpo della parola chiave :keyword:"
"`with` statement, gli argomenti contengono il tipo di eccezione, il valore e "
"le informazioni di traceback. Altrimenti, tutti e tre gli argomenti sono "
"\"Nessuno\"."

#: ../Doc/library/stdtypes.rst:4418
#, fuzzy
msgid ""
"Returning a true value from this method will cause the :keyword:`with` "
"statement to suppress the exception and continue execution with the "
"statement immediately following the :keyword:`!with` statement. Otherwise "
"the exception continues propagating after this method has finished "
"executing. Exceptions that occur during execution of this method will "
"replace any exception that occurred in the body of the :keyword:`!with` "
"statement."
msgstr ""
"Restituire un valore vero da questo metodo farà sì che la parola chiave:"
"`with` dichiarazione per sopprimere l'eccezione e continuare l'esecuzione "
"con la dichiarazione immediatamente dopo la parola chiave:`!con` "
"dichiarazione. Altrimenti l'eccezione continua a propagarsi dopo che questo "
"metodo ha terminato l'esecuzione. Le eccezioni che si verificano durante "
"l'esecuzione di questo metodo sostituiranno qualsiasi eccezione che si è "
"verificata nel corpo della parola chiave: :`!con` dichiarazione."

#: ../Doc/library/stdtypes.rst:4425
#, fuzzy
msgid ""
"The exception passed in should never be reraised explicitly - instead, this "
"method should return a false value to indicate that the method completed "
"successfully and does not want to suppress the raised exception. This allows "
"context management code to easily detect whether or not an :meth:`__exit__` "
"method has actually failed."
msgstr ""
"L'eccezione passata non dovrebbe mai essere richiamata esplicitamente - "
"invece, questo metodo dovrebbe restituire un valore falso per indicare che "
"il metodo è stato completato con successo e non vuole sopprimere l'eccezione "
"sollevata. Questo permette al codice di gestione del contesto di rilevare "
"facilmente se un metodo :meth:`__exit____` ha effettivamente fallito."

#: ../Doc/library/stdtypes.rst:4431
#, fuzzy
msgid ""
"Python defines several context managers to support easy thread "
"synchronisation, prompt closure of files or other objects, and simpler "
"manipulation of the active decimal arithmetic context. The specific types "
"are not treated specially beyond their implementation of the context "
"management protocol. See the :mod:`contextlib` module for some examples."
msgstr ""
"Python definisce diversi context manager per supportare una facile "
"sincronizzazione del thread, la chiusura rapida di file o altri oggetti e "
"una più semplice manipolazione del contesto aritmetico decimale attivo. I "
"tipi specifici non sono trattati in modo particolare al di là della loro "
"attuazione del protocollo di gestione del contesto. Vedere il modulo :mod:"
"`contextlib` per alcuni esempi."

#: ../Doc/library/stdtypes.rst:4437
#, fuzzy
msgid ""
"Python's :term:`generator`\\s and the :class:`contextlib.contextmanager` "
"decorator provide a convenient way to implement these protocols.  If a "
"generator function is decorated with the :class:`contextlib.contextmanager` "
"decorator, it will return a context manager implementing the necessary :meth:"
"`__enter__` and :meth:`__exit__` methods, rather than the iterator produced "
"by an undecorated generator function."
msgstr ""
"Il termine :term:`generator`\\s e il decoratore :class:`contextlib."
"contextmanager` forniscono un modo conveniente per implementare questi "
"protocolli.  Se una funzione generatore è decorata con il decoratore :class:"
"`contextlib.contextmanager`, restituirà un context manager che implementa i "
"necessari metodi :meth:`__enter____` e :meth:`__exit__`, piuttosto che "
"l'iteratore prodotto da una funzione generatore non decorata."

#: ../Doc/library/stdtypes.rst:4444
#, fuzzy
msgid ""
"Note that there is no specific slot for any of these methods in the type "
"structure for Python objects in the Python/C API. Extension types wanting to "
"define these methods must provide them as a normal Python accessible method. "
"Compared to the overhead of setting up the runtime context, the overhead of "
"a single class dictionary lookup is negligible."
msgstr ""
"Si noti che non c'è uno slot specifico per nessuno di questi metodi nella "
"struttura dei tipi di oggetti Python nelle API Python/C. I tipi di "
"estensioni che vogliono definire questi metodi devono fornirli come un "
"normale metodo accessibile in Python. Rispetto all'overhead di "
"configurazione del contesto di runtime, l'overhead di un singolo dizionario "
"di classe è trascurabile."

#: ../Doc/library/stdtypes.rst:4454
msgid "Other Built-in Types"
msgstr "Altri tipi built-in"

#: ../Doc/library/stdtypes.rst:4456
#, fuzzy
msgid ""
"The interpreter supports several other kinds of objects. Most of these "
"support only one or two operations."
msgstr ""
"L'interprete supporta diversi altri tipi di oggetti. La maggior parte di "
"essi sostiene solo una o due operazioni."

#: ../Doc/library/stdtypes.rst:4463
msgid "Modules"
msgstr "Moduli"

#: ../Doc/library/stdtypes.rst:4465
#, fuzzy
msgid ""
"The only special operation on a module is attribute access: ``m.name``, "
"where *m* is a module and *name* accesses a name defined in *m*'s symbol "
"table. Module attributes can be assigned to.  (Note that the :keyword:"
"`import` statement is not, strictly speaking, an operation on a module "
"object; ``import foo`` does not require a module object named *foo* to "
"exist, rather it requires an (external) *definition* for a module named "
"*foo* somewhere.)"
msgstr ""
"L'unica operazione speciale su un modulo è l'accesso agli attributi: ```m."
"name```, dove *m* è un modulo e *name* accede ad un nome definito nella "
"tabella dei simboli di *m*. Gli attributi del modulo possono essere "
"assegnati.  (Notare che la parola chiave:``import` statement non è, a rigor "
"di termini, un'operazione su un oggetto modulo; ``import foo``` non richiede "
"un oggetto modulo chiamato *foo* per esistere, ma piuttosto richiede una "
"*definizione* (esterna) per un modulo chiamato *foo* da qualche parte.)"

#: ../Doc/library/stdtypes.rst:4472
#, fuzzy
msgid ""
"A special attribute of every module is :attr:`~object.__dict__`. This is the "
"dictionary containing the module's symbol table. Modifying this dictionary "
"will actually change the module's symbol table, but direct assignment to "
"the :attr:`~object.__dict__` attribute is not possible (you can write ``m."
"__dict__['a'] = 1``, which defines ``m.a`` to be ``1``, but you can't write "
"``m.__dict__ = {}``).  Modifying :attr:`~object.__dict__` directly is not "
"recommended."
msgstr ""
"Un attributo speciale di ogni modulo è: attr:`~object.__dict__`. Questo è il "
"dizionario contenente la tabella dei simboli del modulo. Modificare questo "
"dizionario cambierà effettivamente la tabella dei simboli del modulo, ma "
"l'assegnazione diretta all'attributo :attr:`~object.__dict__`` non è "
"possibile (si può scrivere ``m.__dict__['a''] = 1```, che definisce ``m."
"a```` per essere ``1``, ma non si può scrivere ``m.__dict__ = {}````).  "
"Modificare:attr:`~object.__dict__` direttamente non è raccomandato."

#: ../Doc/library/stdtypes.rst:4480
#, fuzzy
msgid ""
"Modules built into the interpreter are written like this: ``<module "
"'sys' (built-in)>``.  If loaded from a file, they are written as ``<module "
"'os' from '/usr/local/lib/pythonX.Y/os.pyc'>``."
msgstr ""
"I moduli integrati nell'interprete sono scritti in questo modo: ```<modulo "
"'sys' (integrato)>```.  Se caricati da un file, sono scritti come ``<<modulo "
"'os' da '/usr/local/lib/pythonX.Y/os.pyc'>```."

#: ../Doc/library/stdtypes.rst:4488
msgid "Classes and Class Instances"
msgstr "Classi e istanze di classe"

#: ../Doc/library/stdtypes.rst:4490
#, fuzzy
msgid "See :ref:`objects` and :ref:`class` for these."
msgstr "Vedere :ref:`oggetti` e :ref:`classe` per questi."

#: ../Doc/library/stdtypes.rst:4496
msgid "Functions"
msgstr "Funzioni"

#: ../Doc/library/stdtypes.rst:4498
#, fuzzy
msgid ""
"Function objects are created by function definitions.  The only operation on "
"a function object is to call it: ``func(argument-list)``."
msgstr ""
"Gli oggetti funzione sono creati dalle definizioni delle funzioni.  L'unica "
"operazione su un oggetto funzione è di chiamarlo: ``func(argument-list)``."

#: ../Doc/library/stdtypes.rst:4501
#, fuzzy
msgid ""
"There are really two flavors of function objects: built-in functions and "
"user-defined functions.  Both support the same operation (to call the "
"function), but the implementation is different, hence the different object "
"types."
msgstr ""
"Ci sono davvero due gusti di oggetti funzionali: funzioni integrate e "
"funzioni definite dall'utente.  Entrambi supportano la stessa operazione "
"(per chiamare la funzione), ma l'implementazione è diversa, quindi i diversi "
"tipi di oggetti."

#: ../Doc/library/stdtypes.rst:4505
#, fuzzy
msgid "See :ref:`function` for more information."
msgstr "Vedere :ref:`funzione` per maggiori informazioni."

#: ../Doc/library/stdtypes.rst:4511
msgid "Methods"
msgstr "Metodologie"

#: ../Doc/library/stdtypes.rst:4515
#, fuzzy
msgid ""
"Methods are functions that are called using the attribute notation. There "
"are two flavors: built-in methods (such as :meth:`append` on lists) and "
"class instance methods.  Built-in methods are described with the types that "
"support them."
msgstr ""
"I metodi sono funzioni che vengono chiamate utilizzando la notazione degli "
"attributi. Ci sono due gusti: metodi incorporati (come :meth:`append` on "
"lists) e metodi di istanza di classe.  I metodi integrati sono descritti con "
"i tipi che li supportano."

#: ../Doc/library/stdtypes.rst:4520
#, fuzzy
msgid ""
"If you access a method (a function defined in a class namespace) through an "
"instance, you get a special object: a :dfn:`bound method` (also called :dfn:"
"`instance method`) object. When called, it will add the ``self`` argument to "
"the argument list.  Bound methods have two special read-only attributes: ``m."
"__self__`` is the object on which the method operates, and ``m.__func__`` is "
"the function implementing the method.  Calling ``m(arg-1, arg-2, ..., arg-"
"n)`` is completely equivalent to calling ``m.__func__(m.__self__, arg-1, "
"arg-2, ..., arg-n)``."
msgstr ""
"Se si accede a un metodo (una funzione definita in uno spazio dei nomi di "
"classe) attraverso un'istanza, si ottiene un oggetto speciale: un oggetto :"
"dfn:`bound method` (chiamato anche :dfn:`instance method`). Quando viene "
"chiamato, aggiungerà l'argomento ``self````` all'elenco degli argomenti.  I "
"metodi rilegati hanno due attributi speciali di sola lettura: ``m."
"__self__```` è l'oggetto su cui opera il metodo, e ``m.__func__``` è la "
"funzione che implementa il metodo.  Chiamare ``m(arg-1, arg-2, arg-2, ...., "
"arg-n)``` equivale completamente a chiamare ``m.__func__(m.__self__, arg-1, "
"arg-2, arg-2, ...., arg-n)```."

#: ../Doc/library/stdtypes.rst:4529
#, fuzzy
msgid ""
"Like function objects, bound method objects support getting arbitrary "
"attributes.  However, since method attributes are actually stored on the "
"underlying function object (``meth.__func__``), setting method attributes on "
"bound methods is disallowed.  Attempting to set an attribute on a method "
"results in an :exc:`AttributeError` being raised.  In order to set a method "
"attribute, you need to explicitly set it on the underlying function object::"
msgstr ""
"Come gli oggetti funzione, gli oggetti metodo legato supportano "
"l'ottenimento di attributi arbitrari.  Tuttavia, poiché gli attributi del "
"metodo sono effettivamente memorizzati sull'oggetto funzione sottostante "
"(``meth.__func__````), l'impostazione degli attributi del metodo sui metodi "
"legati non è consentita.  Il tentativo di impostare un attributo su un "
"metodo si traduce in un aumento di :exc:`AttributeError`.  Per impostare un "
"attributo metodo, è necessario impostarlo esplicitamente sull'oggetto "
"funzione sottostante::"

#: ../Doc/library/stdtypes.rst:4549 ../Doc/library/stdtypes.rst:4577
#, fuzzy
msgid "See :ref:`types` for more information."
msgstr "Vedere :ref:`type` per maggiori informazioni."

#: ../Doc/library/stdtypes.rst:4557
#, fuzzy
msgid "Code Objects"
msgstr "Codice Oggetti"

#: ../Doc/library/stdtypes.rst:4563
#, fuzzy
msgid ""
"Code objects are used by the implementation to represent \"pseudo-compiled\" "
"executable Python code such as a function body. They differ from function "
"objects because they don't contain a reference to their global execution "
"environment.  Code objects are returned by the built-in :func:`compile` "
"function and can be extracted from function objects through their :attr:"
"`__code__` attribute. See also the :mod:`code` module."
msgstr ""
"Gli oggetti di codice sono usati dall'implementazione per rappresentare "
"codice eseguibile Python \"pseudo-compilato\", come un corpo funzionale. Si "
"differenziano dagli oggetti funzionali perché non contengono un riferimento "
"al loro ambiente di esecuzione globale.  Gli oggetti di codice sono "
"restituiti dalla funzione incorporata :func:`compilare` e possono essere "
"estratti dagli oggetti di funzione attraverso il loro attributo :attr:"
"`__code____`. Vedere anche il modulo :mod:`code`."

#: ../Doc/library/stdtypes.rst:4574
#, fuzzy
msgid ""
"A code object can be executed or evaluated by passing it (instead of a "
"source string) to the :func:`exec` or :func:`eval`  built-in functions."
msgstr ""
"Un oggetto di codice può essere eseguito o valutato passandolo (invece di "
"una stringa sorgente) alle funzioni incorporate in :func:`exec` o :func:"
"`eval`."

#: ../Doc/library/stdtypes.rst:4583
#, fuzzy
msgid "Type Objects"
msgstr "Tipo Oggetti"

#: ../Doc/library/stdtypes.rst:4589
#, fuzzy
msgid ""
"Type objects represent the various object types.  An object's type is "
"accessed by the built-in function :func:`type`.  There are no special "
"operations on types.  The standard module :mod:`types` defines names for all "
"standard built-in types."
msgstr ""
"Gli oggetti tipo rappresentano i vari tipi di oggetti.  Al tipo di oggetto "
"si accede tramite la funzione integrata :func:`type`.  Non ci sono "
"operazioni speciali sui tipi.  Il modulo standard: mod:`types` definisce i "
"nomi di tutti i tipi standard incorporati."

#: ../Doc/library/stdtypes.rst:4594
#, fuzzy
msgid "Types are written like this: ``<class 'int'>``."
msgstr "I tipi sono scritti in questo modo: ```<classe 'int'>````."

#: ../Doc/library/stdtypes.rst:4600
msgid "The Null Object"
msgstr "L'Oggetto Null"

#: ../Doc/library/stdtypes.rst:4602
#, fuzzy
msgid ""
"This object is returned by functions that don't explicitly return a value.  "
"It supports no special operations.  There is exactly one null object, named "
"``None`` (a built-in name).  ``type(None)()`` produces the same singleton."
msgstr ""
"Questo oggetto è restituito da funzioni che non restituiscono esplicitamente "
"un valore.  Non supporta operazioni speciali.  C'è esattamente un oggetto "
"nullo, chiamato ```Nessuno``` (nome incorporato).  ``type(None)()`` produce "
"lo stesso singleton."

#: ../Doc/library/stdtypes.rst:4606
msgid "It is written as ``None``."
msgstr "È scritto come ``None``."

#: ../Doc/library/stdtypes.rst:4613
#, fuzzy
msgid "The Ellipsis Object"
msgstr "L'oggetto ellissi"

#: ../Doc/library/stdtypes.rst:4615
#, fuzzy
msgid ""
"This object is commonly used by slicing (see :ref:`slicings`).  It supports "
"no special operations.  There is exactly one ellipsis object, named :const:"
"`Ellipsis` (a built-in name).  ``type(Ellipsis)()`` produces the :const:"
"`Ellipsis` singleton."
msgstr ""
"Questo oggetto è comunemente usato per affettare (vedi :ref:`slicings`).  "
"Non supporta operazioni speciali.  C'è esattamente un oggetto ellissi, "
"chiamato :const:`Ellipsis` (nome incorporato).  ``type(Ellipsis)()`` produce "
"il :const:`Ellipsis` singleton."

#: ../Doc/library/stdtypes.rst:4620
msgid "It is written as ``Ellipsis`` or ``...``."
msgstr "È scritto come ``Ellipsis`` o ``…``."

#: ../Doc/library/stdtypes.rst:4626
msgid "The NotImplemented Object"
msgstr "L'oggetto NotImplemented"

#: ../Doc/library/stdtypes.rst:4628
#, fuzzy
msgid ""
"This object is returned from comparisons and binary operations when they are "
"asked to operate on types they don't support. See :ref:`comparisons` for "
"more information.  There is exactly one ``NotImplemented`` object. "
"``type(NotImplemented)()`` produces the singleton instance."
msgstr ""
"Questo oggetto viene restituito da confronti e operazioni binarie quando "
"viene chiesto loro di operare su tipi che non supportano. Vedere :ref:"
"`comparazioni` per maggiori informazioni.  C'è esattamente un oggetto "
"```NotImplemented```. ``type(NotImplemented)()`` produce l'istanza singleton."

#: ../Doc/library/stdtypes.rst:4633
msgid "It is written as ``NotImplemented``."
msgstr "È scritto come ``NotImplemented``."

#: ../Doc/library/stdtypes.rst:4639
msgid "Boolean Values"
msgstr "Valori booleani"

#: ../Doc/library/stdtypes.rst:4641
#, fuzzy
msgid ""
"Boolean values are the two constant objects ``False`` and ``True``.  They "
"are used to represent truth values (although other values can also be "
"considered false or true).  In numeric contexts (for example when used as "
"the argument to an arithmetic operator), they behave like the integers 0 and "
"1, respectively. The built-in function :func:`bool` can be used to convert "
"any value to a Boolean, if the value can be interpreted as a truth value "
"(see section :ref:`truth` above)."
msgstr ""
"I valori booleani sono i due oggetti costanti ``False``` e ``True```.  Sono "
"usati per rappresentare valori di verità (anche se altri valori possono "
"essere considerati falsi o veri).  In contesti numerici (ad esempio quando "
"sono usati come argomento per un operatore aritmetico), si comportano come "
"gli interi 0 e 1, rispettivamente. La funzione incorporata:func:`bool` può "
"essere usata per convertire qualsiasi valore in booleano, se il valore può "
"essere interpretato come valore di verità (vedere la sezione :ref:`verità` "
"sopra)."

#: ../Doc/library/stdtypes.rst:4654
msgid "They are written as ``False`` and ``True``, respectively."
msgstr "Sono scritti rispettivamente come ``False`` e ``True``."

#: ../Doc/library/stdtypes.rst:4660
msgid "Internal Objects"
msgstr "Oggetti interni"

#: ../Doc/library/stdtypes.rst:4662
#, fuzzy
msgid ""
"See :ref:`types` for this information.  It describes stack frame objects, "
"traceback objects, and slice objects."
msgstr ""
"Vedere :ref:`type` per questa informazione.  Descrive gli oggetti a cornice "
"impilati, gli oggetti di traceback e gli oggetti a fetta."

#: ../Doc/library/stdtypes.rst:4669
msgid "Special Attributes"
msgstr "Attributi speciali"

#: ../Doc/library/stdtypes.rst:4671
#, fuzzy
msgid ""
"The implementation adds a few special read-only attributes to several object "
"types, where they are relevant.  Some of these are not reported by the :func:"
"`dir` built-in function."
msgstr ""
"L'implementazione aggiunge alcuni attributi speciali in sola lettura a "
"diversi tipi di oggetti, dove sono rilevanti.  Alcuni di questi non sono "
"segnalati dalla funzione :func:`dir` built-in function."

#: ../Doc/library/stdtypes.rst:4678
#, fuzzy
msgid ""
"A dictionary or other mapping object used to store an object's (writable) "
"attributes."
msgstr ""
"Dizionario o altro oggetto di mappatura usato per memorizzare gli attributi "
"(scrivibili) di un oggetto."

#: ../Doc/library/stdtypes.rst:4684
msgid "The class to which a class instance belongs."
msgstr "La classe a cui appartiene un'istanza di classe."

#: ../Doc/library/stdtypes.rst:4689
#, fuzzy
msgid "The tuple of base classes of a class object."
msgstr "La tupla delle classi base di un oggetto classe."

#: ../Doc/library/stdtypes.rst:4694
#, fuzzy
msgid ""
"The name of the class, function, method, descriptor, or generator instance."
msgstr ""
"Il nome della classe, della funzione, del metodo, del descrittore o "
"dell'istanza del generatore."

#: ../Doc/library/stdtypes.rst:4700
#, fuzzy
msgid ""
"The :term:`qualified name` of the class, function, method, descriptor, or "
"generator instance."
msgstr ""
"Il termine:`nome qualificato` della classe, funzione, metodo, descrittore o "
"istanza del generatore."

#: ../Doc/library/stdtypes.rst:4708
#, fuzzy
msgid ""
"This attribute is a tuple of classes that are considered when looking for "
"base classes during method resolution."
msgstr ""
"Questo attributo è una tupla di classi che sono considerate quando si "
"cercano classi base durante la risoluzione del metodo."

#: ../Doc/library/stdtypes.rst:4714
#, fuzzy
msgid ""
"This method can be overridden by a metaclass to customize the method "
"resolution order for its instances.  It is called at class instantiation, "
"and its result is stored in :attr:`~class.__mro__`."
msgstr ""
"Questo metodo può essere sovrascritto da una metaclasse per personalizzare "
"l'ordine di risoluzione del metodo per le sue istanze.  Viene chiamata "
"all'istanziazione della classe e il suo risultato è memorizzato in :attr:"
"`~class.__mro____`."

#: ../Doc/library/stdtypes.rst:4721
#, fuzzy
msgid ""
"Each class keeps a list of weak references to its immediate subclasses.  "
"This method returns a list of all those references still alive. Example::"
msgstr ""
"Ogni classe mantiene un elenco di riferimenti deboli alle sue sottoclassi "
"immediate.  Questo metodo restituisce una lista di tutti i riferimenti "
"ancora vivi. Esempio::"

#: ../Doc/library/stdtypes.rst:4730
msgid "Footnotes"
msgstr "Note"

#: ../Doc/library/stdtypes.rst:4731
#, fuzzy
msgid ""
"Additional information on these special methods may be found in the Python "
"Reference Manual (:ref:`customization`)."
msgstr ""
"Ulteriori informazioni su questi metodi speciali possono essere trovate nel "
"manuale di riferimento Python (:ref:`customization`)."

#: ../Doc/library/stdtypes.rst:4734
#, fuzzy
msgid ""
"As a consequence, the list ``[1, 2]`` is considered equal to ``[1.0, 2.0]``, "
"and similarly for tuples."
msgstr ""
"Di conseguenza, la lista ```[1, 2]```` è considerata uguale a ``[1.0, "
"2.0]```, e analogamente per le tuple."

#: ../Doc/library/stdtypes.rst:4737
#, fuzzy
msgid "They must have since the parser can't tell the type of the operands."
msgstr ""
"Devono averlo fatto, dato che l'analizzatore non può dire il tipo di "
"operandi."

#: ../Doc/library/stdtypes.rst:4739
#, fuzzy
msgid ""
"Cased characters are those with general category property being one of \"Lu"
"\" (Letter, uppercase), \"Ll\" (Letter, lowercase), or \"Lt\" (Letter, "
"titlecase)."
msgstr ""
"I caratteri maiuscoli sono quelli con proprietà di categoria generale che "
"sono una \"Lu\" (lettera, maiuscola), \"Ll\" (lettera, minuscola), o \"Lt"
"\" (lettera, maiuscola)."

#: ../Doc/library/stdtypes.rst:4742
#, fuzzy
msgid ""
"To format only a tuple you should therefore provide a singleton tuple whose "
"only element is the tuple to be formatted."
msgstr ""
"Per formattare solo una tupla si dovrebbe quindi fornire una tupla singleton "
"il cui unico elemento è la tupla da formattare."
